// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package scb provides access to the registers of the SystemControl peripheral.
//
// Instances:
//
//	SystemControl  SystemControl_BASE  -  -  System Control Block
//
// Registers:
//
//	0x008 32  ACTLR       Auxiliary Control Register,
//	0xD00 32  CPUID       CPUID Base Register
//	0xD04 32  ICSR        Interrupt Control and State Register
//	0xD08 32  VTOR        Vector Table Offset Register
//	0xD0C 32  AIRCR       Application Interrupt and Reset Control Register
//	0xD10 32  SCR         System Control Register
//	0xD14 32  CCR         Configuration and Control Register
//	0xD18 32  SHPR1       System Handler Priority Register 1
//	0xD1C 32  SHPR2       System Handler Priority Register 2
//	0xD20 32  SHPR3       System Handler Priority Register 3
//	0xD24 32  SHCSR       System Handler Control and State Register
//	0xD28 32  CFSR        Configurable Fault Status Register
//	0xD2C 32  HFSR        HardFault Status register
//	0xD30 32  DFSR        Debug Fault Status Register
//	0xD34 32  MMFAR       MemManage Fault Address Register
//	0xD38 32  BFAR        BusFault Address Register
//	0xD40 32  ID_PFR0     Processor Feature Register 0
//	0xD44 32  ID_PFR1     Processor Feature Register 1
//	0xD48 32  ID_DFR0     Debug Feature Register
//	0xD4C 32  ID_AFR0     Auxiliary Feature Register
//	0xD50 32  ID_MMFR0    Memory Model Feature Register 0
//	0xD54 32  ID_MMFR1    Memory Model Feature Register 1
//	0xD58 32  ID_MMFR2    Memory Model Feature Register 2
//	0xD5C 32  ID_MMFR3    Memory Model Feature Register 3
//	0xD60 32  ID_ISAR0    Instruction Set Attributes Register 0
//	0xD64 32  ID_ISAR1    Instruction Set Attributes Register 1
//	0xD68 32  ID_ISAR2    Instruction Set Attributes Register 2
//	0xD6C 32  ID_ISAR3    Instruction Set Attributes Register 3
//	0xD70 32  ID_ISAR4    Instruction Set Attributes Register 4
//	0xD78 32  CLIDR       Cache Level ID register
//	0xD7C 32  CTR         Cache Type register
//	0xD80 32  CCSIDR      Cache Size ID Register
//	0xD84 32  CSSELR      Cache Size Selection Register
//	0xD88 32  CPACR       Coprocessor Access Control Register
//	0xF00 32  STIR        Instruction cache invalidate all to Point of Unification (PoU)
//	0xF50 32  ICIALLU     Instruction cache invalidate all to Point of Unification (PoU)
//	0xF58 32  ICIMVAU     Instruction cache invalidate by address to PoU
//	0xF5C 32  DCIMVAC     Data cache invalidate by address to Point of Coherency (PoC)
//	0xF60 32  DCISW       Data cache invalidate by set/way
//	0xF64 32  DCCMVAU     Data cache by address to PoU
//	0xF68 32  DCCMVAC     Data cache clean by address to PoC
//	0xF6C 32  DCCSW       Data cache clean by set/way
//	0xF70 32  DCCIMVAC    Data cache clean and invalidate by address to PoC
//	0xF74 32  DCCISW      Data cache clean and invalidate by set/way
//	0xF90 32  CM7_ITCMCR  Instruction Tightly-Coupled Memory Control Register
//	0xF94 32  CM7_DTCMCR  Data Tightly-Coupled Memory Control Register
//	0xF98 32  CM7_AHBPCR  AHBP Control Register
//	0xF9C 32  CM7_CACR    L1 Cache Control Register
//	0xFA0 32  CM7_AHBSCR  AHB Slave Control Register
//	0xFA8 32  CM7_ABFSR   Auxiliary Bus Fault Status Register
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package scb

const (
	DISFOLD        ACTLR = 0x01 << 2  //+ Disables folding of IT instructions.
	FPEXCODIS      ACTLR = 0x01 << 10 //+ Disables FPU exception outputs.
	DISRAMODE      ACTLR = 0x01 << 11 //+ Disables dynamic read allocate mode for Write-Back Write-Allocate memory regions.
	DISITMATBFLUSH ACTLR = 0x01 << 12 //+ Disables ITM and DWT ATB flush.
	DISBTACREAD    ACTLR = 0x01 << 13 //+ Disables BTAC read.
	DISBTACALLOC   ACTLR = 0x01 << 14 //+ Disables BTAC allocate.
	DISCRITAXIRUR  ACTLR = 0x01 << 15 //+ Disables critical AXI Read-Under-Read.
	DISDI          ACTLR = 0x1F << 16 //+ Disables dual-issued.
	DISDI_0        ACTLR = 0x00 << 16 //  Normal operation.
	DISDI_1        ACTLR = 0x01 << 16 //  Nothing can be dual-issued when this instruction type is in channel 0.
	DISISSCH1      ACTLR = 0x1F << 21 //+ Disables dual-issued.
	DISISSCH1_0    ACTLR = 0x00 << 21 //  Normal operation.
	DISISSCH1_1    ACTLR = 0x01 << 21 //  Nothing can be dual-issued when this instruction type is in channel 1.
	DISDYNADD      ACTLR = 0x01 << 26 //+ Disables dynamic allocation of ADD and SUB instructions
	DISCRITAXIRUW  ACTLR = 0x01 << 27 //+ Disables critical AXI read-under-write
	DISFPUISSOPT   ACTLR = 0x01 << 28 //+ Disables critical AXI read-under-write
)

const (
	DISFOLDn        = 2
	FPEXCODISn      = 10
	DISRAMODEn      = 11
	DISITMATBFLUSHn = 12
	DISBTACREADn    = 13
	DISBTACALLOCn   = 14
	DISCRITAXIRURn  = 15
	DISDIn          = 16
	DISISSCH1n      = 21
	DISDYNADDn      = 26
	DISCRITAXIRUWn  = 27
	DISFPUISSOPTn   = 28
)

const (
	REVISION     CPUID = 0x0F << 0  //+ Indicates patch release: 0x0 = Patch 0
	PARTNO       CPUID = 0xFFF << 4 //+ Indicates part number
	ARCHITECTURE CPUID = 0x0F << 16 //+ ARCHITECTURE
	VARIANT      CPUID = 0x0F << 20 //+ Indicates processor revision: 0x2 = Revision 2
	IMPLEMENTER  CPUID = 0xFF << 24 //+ Implementer code
)

const (
	REVISIONn     = 0
	PARTNOn       = 4
	ARCHITECTUREn = 16
	VARIANTn      = 20
	IMPLEMENTERn  = 24
)

const (
	VECTACTIVE  ICSR = 0x1FF << 0  //+ Active exception number
	RETTOBASE   ICSR = 0x01 << 11  //+ Indicates whether there are preempted active exceptions
	VECTPENDING ICSR = 0x1FF << 12 //+ Exception number of the highest priority pending enabled exception
	ISRPENDING  ICSR = 0x01 << 22  //+ Interrupt pending flag, excluding NMI and Faults
	PENDSTCLR   ICSR = 0x01 << 25  //+ SysTick exception clear-pending bit
	PENDSTSET   ICSR = 0x01 << 26  //+ SysTick exception set-pending bit
	PENDSVCLR   ICSR = 0x01 << 27  //+ PendSV clear-pending bit
	PENDSVSET   ICSR = 0x01 << 28  //+ PendSV set-pending bit
	NMIPENDSET  ICSR = 0x01 << 31  //+ NMI set-pending bit
)

const (
	VECTACTIVEn  = 0
	RETTOBASEn   = 11
	VECTPENDINGn = 12
	ISRPENDINGn  = 22
	PENDSTCLRn   = 25
	PENDSTSETn   = 26
	PENDSVCLRn   = 27
	PENDSVSETn   = 28
	NMIPENDSETn  = 31
)

const (
	TBLOFF VTOR = 0x1FFFFFF << 7 //+ Vector table base offset
)

const (
	TBLOFFn = 7
)

const (
	VECTRESET     AIRCR = 0x01 << 0    //+ Writing 1 to this bit causes a local system reset
	VECTCLRACTIVE AIRCR = 0x01 << 1    //+ Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
	SYSRESETREQ   AIRCR = 0x01 << 2    //+ System reset request
	PRIGROUP      AIRCR = 0x07 << 8    //+ Interrupt priority grouping field. This field determines the split of group priority from subpriority.
	ENDIANNESS    AIRCR = 0x01 << 15   //+ Data endianness
	VECTKEY       AIRCR = 0xFFFF << 16 //+ Register key
)

const (
	VECTRESETn     = 0
	VECTCLRACTIVEn = 1
	SYSRESETREQn   = 2
	PRIGROUPn      = 8
	ENDIANNESSn    = 15
	VECTKEYn       = 16
)

const (
	SLEEPONEXIT SCR = 0x01 << 1 //+ Indicates sleep-on-exit when returning from Handler mode to Thread mode
	SLEEPDEEP   SCR = 0x01 << 2 //+ Controls whether the processor uses sleep or deep sleep as its low power mode
	SEVONPEND   SCR = 0x01 << 4 //+ Send Event on Pending bit
)

const (
	SLEEPONEXITn = 1
	SLEEPDEEPn   = 2
	SEVONPENDn   = 4
)

const (
	NONBASETHRDENA CCR = 0x01 << 0  //+ Indicates how the processor enters Thread mode
	USERSETMPEND   CCR = 0x01 << 1  //+ Enables unprivileged software access to the STIR
	UNALIGN_TRP    CCR = 0x01 << 3  //+ Enables unaligned access traps
	DIV_0_TRP      CCR = 0x01 << 4  //+ Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
	BFHFNMIGN      CCR = 0x01 << 8  //+ Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
	STKALIGN       CCR = 0x01 << 9  //+ Indicates stack alignment on exception entry
	DC             CCR = 0x01 << 16 //+ Enables L1 data cache.
	IC             CCR = 0x01 << 17 //+ Enables L1 instruction cache.
	BP             CCR = 0x01 << 18 //+ Always reads-as-one. It indicates branch prediction is enabled.
)

const (
	NONBASETHRDENAn = 0
	USERSETMPENDn   = 1
	UNALIGN_TRPn    = 3
	DIV_0_TRPn      = 4
	BFHFNMIGNn      = 8
	STKALIGNn       = 9
	DCn             = 16
	ICn             = 17
	BPn             = 18
)

const (
	PRI_4 SHPR1 = 0xFF << 0  //+ Priority of system handler 4, MemManage
	PRI_5 SHPR1 = 0xFF << 8  //+ Priority of system handler 5, BusFault
	PRI_6 SHPR1 = 0xFF << 16 //+ Priority of system handler 6, UsageFault
)

const (
	PRI_4n = 0
	PRI_5n = 8
	PRI_6n = 16
)

const (
	PRI_11 SHPR2 = 0xFF << 24 //+ Priority of system handler 11, SVCall
)

const (
	PRI_11n = 24
)

const (
	PRI_14 SHPR3 = 0xFF << 16 //+ Priority of system handler 14, PendSV
	PRI_15 SHPR3 = 0xFF << 24 //+ Priority of system handler 15, SysTick exception
)

const (
	PRI_14n = 16
	PRI_15n = 24
)

const (
	MEMFAULTACT    SHCSR = 0x01 << 0  //+ MemManage exception active bit
	BUSFAULTACT    SHCSR = 0x01 << 1  //+ BusFault exception active bit
	USGFAULTACT    SHCSR = 0x01 << 3  //+ UsageFault exception active bit
	SVCALLACT      SHCSR = 0x01 << 7  //+ SVCall active bit
	MONITORACT     SHCSR = 0x01 << 8  //+ Debug monitor active bit
	PENDSVACT      SHCSR = 0x01 << 10 //+ PendSV exception active bit
	SYSTICKACT     SHCSR = 0x01 << 11 //+ SysTick exception active bit
	USGFAULTPENDED SHCSR = 0x01 << 12 //+ UsageFault exception pending bit
	MEMFAULTPENDED SHCSR = 0x01 << 13 //+ MemManage exception pending bit
	BUSFAULTPENDED SHCSR = 0x01 << 14 //+ BusFault exception pending bit
	SVCALLPENDED   SHCSR = 0x01 << 15 //+ SVCall pending bit
	MEMFAULTENA    SHCSR = 0x01 << 16 //+ MemManage enable bit
	BUSFAULTENA    SHCSR = 0x01 << 17 //+ BusFault enable bit
	USGFAULTENA    SHCSR = 0x01 << 18 //+ UsageFault enable bit
)

const (
	MEMFAULTACTn    = 0
	BUSFAULTACTn    = 1
	USGFAULTACTn    = 3
	SVCALLACTn      = 7
	MONITORACTn     = 8
	PENDSVACTn      = 10
	SYSTICKACTn     = 11
	USGFAULTPENDEDn = 12
	MEMFAULTPENDEDn = 13
	BUSFAULTPENDEDn = 14
	SVCALLPENDEDn   = 15
	MEMFAULTENAn    = 16
	BUSFAULTENAn    = 17
	USGFAULTENAn    = 18
)

const (
	IACCVIOL    CFSR = 0x01 << 0  //+ Instruction access violation flag
	DACCVIOL    CFSR = 0x01 << 1  //+ Data access violation flag
	MUNSTKERR   CFSR = 0x01 << 3  //+ MemManage fault on unstacking for a return from exception
	MSTKERR     CFSR = 0x01 << 4  //+ MemManage fault on stacking for exception entry
	MLSPERR     CFSR = 0x01 << 5  //+ MemManage fault occurred during floating-point lazy state preservation
	MMARVALID   CFSR = 0x01 << 7  //+ MemManage Fault Address Register (MMFAR) valid flag
	IBUSERR     CFSR = 0x01 << 8  //+ Instruction bus error
	PRECISERR   CFSR = 0x01 << 9  //+ Precise data bus error
	IMPRECISERR CFSR = 0x01 << 10 //+ Imprecise data bus error
	UNSTKERR    CFSR = 0x01 << 11 //+ BusFault on unstacking for a return from exception
	STKERR      CFSR = 0x01 << 12 //+ BusFault on stacking for exception entry
	LSPERR      CFSR = 0x01 << 13 //+ Bus fault occurred during floating-point lazy state preservation
	BFARVALID   CFSR = 0x01 << 15 //+ BusFault Address Register (BFAR) valid flag
	UNDEFINSTR  CFSR = 0x01 << 16 //+ Undefined instruction UsageFault
	INVSTATE    CFSR = 0x01 << 17 //+ Invalid state UsageFault
	INVPC       CFSR = 0x01 << 18 //+ Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
	NOCP        CFSR = 0x01 << 19 //+ No coprocessor UsageFault
	UNALIGNED   CFSR = 0x01 << 24 //+ Unaligned access UsageFault
	DIVBYZERO   CFSR = 0x01 << 25 //+ Divide by zero UsageFault
)

const (
	IACCVIOLn    = 0
	DACCVIOLn    = 1
	MUNSTKERRn   = 3
	MSTKERRn     = 4
	MLSPERRn     = 5
	MMARVALIDn   = 7
	IBUSERRn     = 8
	PRECISERRn   = 9
	IMPRECISERRn = 10
	UNSTKERRn    = 11
	STKERRn      = 12
	LSPERRn      = 13
	BFARVALIDn   = 15
	UNDEFINSTRn  = 16
	INVSTATEn    = 17
	INVPCn       = 18
	NOCPn        = 19
	UNALIGNEDn   = 24
	DIVBYZEROn   = 25
)

const (
	VECTTBL  HFSR = 0x01 << 1  //+ Indicates a BusFault on a vector table read during exception processing.
	FORCED   HFSR = 0x01 << 30 //+ Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled.
	DEBUGEVT HFSR = 0x01 << 31 //+ Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
)

const (
	VECTTBLn  = 1
	FORCEDn   = 30
	DEBUGEVTn = 31
)

const (
	HALTED   DFSR = 0x01 << 0 //+ Indicates a debug event generated by either a C_HALT or C_STEP request, triggered by a write to the DHCSR or a step request triggered by setting DEMCR.MON_STEP to 1.
	BKPT     DFSR = 0x01 << 1 //+ Debug event generated by BKPT instruction execution or a breakpoint match in FPB
	DWTTRAP  DFSR = 0x01 << 2 //+ Debug event generated by the DWT
	VCATCH   DFSR = 0x01 << 3 //+ Indicates triggering of a Vector catch
	EXTERNAL DFSR = 0x01 << 4 //+ Debug event generated because of the assertion of an external debug request
)

const (
	HALTEDn   = 0
	BKPTn     = 1
	DWTTRAPn  = 2
	VCATCHn   = 3
	EXTERNALn = 4
)

const (
	ADDRESS MMFAR = 0xFFFFFFFF << 0 //+ Address of MemManage fault location
)

const (
	ADDRESSn = 0
)

const (
	ADDRESS BFAR = 0xFFFFFFFF << 0 //+ Address of the BusFault location
)

const (
	ADDRESSn = 0
)

const (
	STATE0   ID_PFR0 = 0x0F << 0  //+ ARM instruction set support
	STATE0_0 ID_PFR0 = 0x00 << 0  //  ARMv7-M unused
	STATE0_1 ID_PFR0 = 0x01 << 0  //  ARMv7-M unused
	STATE0_2 ID_PFR0 = 0x02 << 0  //  ARMv7-M unused
	STATE0_3 ID_PFR0 = 0x03 << 0  //  Support for Thumb encoding including Thumb-2 technology, with all basic 16-bit and 32-bit instructions.
	STATE1   ID_PFR0 = 0x0F << 4  //+ Thumb instruction set support
	STATE1_0 ID_PFR0 = 0x00 << 4  //  The processor does not support the ARM instruction set.
	STATE1_1 ID_PFR0 = 0x01 << 4  //  ARMv7-M unused
	STATE2   ID_PFR0 = 0x0F << 8  //+ ARMv7-M unused
	STATE3   ID_PFR0 = 0x0F << 12 //+ ARMv7-M unused
)

const (
	STATE0n = 0
	STATE1n = 4
	STATE2n = 8
	STATE3n = 12
)

const (
	PROGMODEL   ID_PFR1 = 0x0F << 8 //+ M profile programmers' model
	PROGMODEL_0 ID_PFR1 = 0x00 << 8 //  ARMv7-M unused
	PROGMODEL_2 ID_PFR1 = 0x02 << 8 //  Two-stack programmers' model supported
)

const (
	PROGMODELn = 8
)

const (
	DEBUGMODEL   ID_DFR0 = 0x0F << 20 //+ Support for memory-mapped debug model for M profile processors
	DEBUGMODEL_0 ID_DFR0 = 0x00 << 20 //  Not supported
	DEBUGMODEL_1 ID_DFR0 = 0x01 << 20 //  Support for M profile Debug architecture, with memory-mapped access.
)

const (
	DEBUGMODELn = 20
)

const (
	IMPLEMENTATION_DEFINED0 ID_AFR0 = 0x0F << 0  //+ Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
	IMPLEMENTATION_DEFINED1 ID_AFR0 = 0x0F << 4  //+ Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
	IMPLEMENTATION_DEFINED2 ID_AFR0 = 0x0F << 8  //+ Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
	IMPLEMENTATION_DEFINED3 ID_AFR0 = 0x0F << 12 //+ Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
)

const (
	IMPLEMENTATION_DEFINED0n = 0
	IMPLEMENTATION_DEFINED1n = 4
	IMPLEMENTATION_DEFINED2n = 8
	IMPLEMENTATION_DEFINED3n = 12
)

const (
	PMSASUPPORT               ID_MMFR0 = 0x0F << 4  //+ Indicates support for a PMSA
	PMSASUPPORT_0             ID_MMFR0 = 0x00 << 4  //  Not supported
	PMSASUPPORT_1             ID_MMFR0 = 0x01 << 4  //  ARMv7-M unused
	PMSASUPPORT_2             ID_MMFR0 = 0x02 << 4  //  ARMv7-M unused
	PMSASUPPORT_3             ID_MMFR0 = 0x03 << 4  //  PMSAv7, providing support for a base region and subregions.
	OUTERMOST_SHAREABILITY    ID_MMFR0 = 0x0F << 8  //+ Indicates the outermost shareability domain implemented
	OUTERMOST_SHAREABILITY_0  ID_MMFR0 = 0x00 << 8  //  Implemented as Non-cacheable
	OUTERMOST_SHAREABILITY_1  ID_MMFR0 = 0x01 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_2  ID_MMFR0 = 0x02 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_3  ID_MMFR0 = 0x03 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_4  ID_MMFR0 = 0x04 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_5  ID_MMFR0 = 0x05 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_6  ID_MMFR0 = 0x06 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_7  ID_MMFR0 = 0x07 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_8  ID_MMFR0 = 0x08 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_9  ID_MMFR0 = 0x09 << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_10 ID_MMFR0 = 0x0A << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_11 ID_MMFR0 = 0x0B << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_12 ID_MMFR0 = 0x0C << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_13 ID_MMFR0 = 0x0D << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_14 ID_MMFR0 = 0x0E << 8  //  ARMv7-M unused
	OUTERMOST_SHAREABILITY_15 ID_MMFR0 = 0x0F << 8  //  Shareability ignored.
	SHAREABILITY_LEVELS       ID_MMFR0 = 0x0F << 12 //+ Indicates the number of shareability levels implemented
	SHAREABILITY_LEVELS_0     ID_MMFR0 = 0x00 << 12 //  One level of shareability implemented
	SHAREABILITY_LEVELS_1     ID_MMFR0 = 0x01 << 12 //  ARMv7-M unused
	TCM_SUPPORT               ID_MMFR0 = 0x0F << 16 //+ Indicates the support for Tightly Coupled Memory
	TCM_SUPPORT_0             ID_MMFR0 = 0x00 << 16 //  No tightly coupled memories implemented.
	TCM_SUPPORT_1             ID_MMFR0 = 0x01 << 16 //  Tightly coupled memories implemented with IMPLEMENTATION DEFINED control.
	TCM_SUPPORT_2             ID_MMFR0 = 0x02 << 16 //  ARMv7-M unused
	AUXILIARY_REGISTERS       ID_MMFR0 = 0x0F << 20 //+ Indicates the support for Auxiliary registers
	AUXILIARY_REGISTERS_0     ID_MMFR0 = 0x00 << 20 //  Not supported
	AUXILIARY_REGISTERS_1     ID_MMFR0 = 0x01 << 20 //  Support for Auxiliary Control Register only.
	AUXILIARY_REGISTERS_2     ID_MMFR0 = 0x02 << 20 //  ARMv7-M unused
)

const (
	PMSASUPPORTn            = 4
	OUTERMOST_SHAREABILITYn = 8
	SHAREABILITY_LEVELSn    = 12
	TCM_SUPPORTn            = 16
	AUXILIARY_REGISTERSn    = 20
)

const (
	ID_MMFR1 ID_MMFR1 = 0xFFFFFFFF << 0 //+ Gives information about the implemented memory model and memory management support.
)

const (
	ID_MMFR1n = 0
)

const (
	WFI_STALL   ID_MMFR2 = 0x0F << 24 //+ Indicates the support for Wait For Interrupt (WFI) stalling
	WFI_STALL_0 ID_MMFR2 = 0x00 << 24 //  Not supported
	WFI_STALL_1 ID_MMFR2 = 0x01 << 24 //  Support for WFI stalling
)

const (
	WFI_STALLn = 24
)

const (
	ID_MMFR3 ID_MMFR3 = 0xFFFFFFFF << 0 //+ Gives information about the implemented memory model and memory management support.
)

const (
	ID_MMFR3n = 0
)

const (
	BITCOUNT_INSTRS    ID_ISAR0 = 0x0F << 4  //+ Indicates the supported Bit Counting instructions
	BITCOUNT_INSTRS_0  ID_ISAR0 = 0x00 << 4  //  None supported, ARMv7-M unused
	BITCOUNT_INSTRS_1  ID_ISAR0 = 0x01 << 4  //  Adds support for the CLZ instruction
	BITFIELD_INSTRS    ID_ISAR0 = 0x0F << 8  //+ Indicates the supported BitField instructions
	BITFIELD_INSTRS_0  ID_ISAR0 = 0x00 << 8  //  None supported, ARMv7-M unused
	BITFIELD_INSTRS_1  ID_ISAR0 = 0x01 << 8  //  Adds support for the BFC, BFI, SBFX, and UBFX instructions
	CMPBRANCH_INSTRS   ID_ISAR0 = 0x0F << 12 //+ Indicates the supported combined Compare and Branch instructions
	CMPBRANCH_INSTRS_0 ID_ISAR0 = 0x00 << 12 //  None supported, ARMv7-M unused
	CMPBRANCH_INSTRS_1 ID_ISAR0 = 0x01 << 12 //  Adds support for the CBNZ and CBZ instructions
	COPROC_INSTRS      ID_ISAR0 = 0x0F << 16 //+ Indicates the supported Coprocessor instructions
	COPROC_INSTRS_0    ID_ISAR0 = 0x00 << 16 //  None supported, except for separately attributed architectures, for example the Floating-point extension
	COPROC_INSTRS_1    ID_ISAR0 = 0x01 << 16 //  Adds support for generic CDP, LDC, MCR, MRC, and STC instructions
	COPROC_INSTRS_2    ID_ISAR0 = 0x02 << 16 //  As for 1, and adds support for generic CDP2, LDC2, MCR2, MRC2, and STC2 instructions
	COPROC_INSTRS_3    ID_ISAR0 = 0x03 << 16 //  As for 2, and adds support for generic MCRR and MRRC instructions
	COPROC_INSTRS_4    ID_ISAR0 = 0x04 << 16 //  As for 3, and adds support for generic MCRR2 and MRRC2 instructions
	DEBUG_INSTRS       ID_ISAR0 = 0x0F << 20 //+ Indicates the supported Debug instructions
	DEBUG_INSTRS_0     ID_ISAR0 = 0x00 << 20 //  None supported, ARMv7-M unused
	DEBUG_INSTRS_1     ID_ISAR0 = 0x01 << 20 //  Adds support for the BKPT instruction
	DIVIDE_INSTRS      ID_ISAR0 = 0x0F << 24 //+ Indicates the supported Divide instructions
	DIVIDE_INSTRS_0    ID_ISAR0 = 0x00 << 24 //  None supported, ARMv7-M unused
	DIVIDE_INSTRS_1    ID_ISAR0 = 0x01 << 24 //  Adds support for the SDIV and UDIV instructions
)

const (
	BITCOUNT_INSTRSn  = 4
	BITFIELD_INSTRSn  = 8
	CMPBRANCH_INSTRSn = 12
	COPROC_INSTRSn    = 16
	DEBUG_INSTRSn     = 20
	DIVIDE_INSTRSn    = 24
)

const (
	EXTEND_INSTRS      ID_ISAR1 = 0x0F << 12 //+ Indicates the supported Extend instructions
	EXTEND_INSTRS_0    ID_ISAR1 = 0x00 << 12 //  None supported, ARMv7-M unused
	EXTEND_INSTRS_1    ID_ISAR1 = 0x01 << 12 //  Adds support for the SXTB, SXTH, UXTB, and UXTH instructions
	EXTEND_INSTRS_2    ID_ISAR1 = 0x02 << 12 //  As for 1, and adds support for the SXTAB, SXTAB16, SXTAH, SXTB16, UXTAB, UXTAB16, UXTAH, and UXTB16 instructions
	IFTHEN_INSTRS      ID_ISAR1 = 0x0F << 16 //+ Indicates the supported IfThen instructions
	IFTHEN_INSTRS_0    ID_ISAR1 = 0x00 << 16 //  None supported, ARMv7-M unused
	IFTHEN_INSTRS_1    ID_ISAR1 = 0x01 << 16 //  Adds support for the IT instructions, and for the IT bits in the PSRs
	IMMEDIATE_INSTRS   ID_ISAR1 = 0x0F << 20 //+ Indicates the support for data-processing instructions with long immediate
	IMMEDIATE_INSTRS_0 ID_ISAR1 = 0x00 << 20 //  None supported, ARMv7-M unused
	IMMEDIATE_INSTRS_1 ID_ISAR1 = 0x01 << 20 //  Adds support for the ADDW, MOVW, MOVT, and SUBW instructions
	INTERWORK_INSTRS   ID_ISAR1 = 0x0F << 24 //+ Indicates the supported Interworking instructions
	INTERWORK_INSTRS_0 ID_ISAR1 = 0x00 << 24 //  None supported, ARMv7-M unused
	INTERWORK_INSTRS_1 ID_ISAR1 = 0x01 << 24 //  Adds support for the BX instruction, and the T bit in the PSR
	INTERWORK_INSTRS_2 ID_ISAR1 = 0x02 << 24 //  As for 1, and adds support for the BLX instruction, and PC loads have BX-like behavior
	INTERWORK_INSTRS_3 ID_ISAR1 = 0x03 << 24 //  ARMv7-M unused
)

const (
	EXTEND_INSTRSn    = 12
	IFTHEN_INSTRSn    = 16
	IMMEDIATE_INSTRSn = 20
	INTERWORK_INSTRSn = 24
)

const (
	LOADSTORE_INSTRS        ID_ISAR2 = 0x0F << 0  //+ Indicates the supported additional load and store instructions
	LOADSTORE_INSTRS_0      ID_ISAR2 = 0x00 << 0  //  None supported, ARMv7-M unused
	LOADSTORE_INSTRS_1      ID_ISAR2 = 0x01 << 0  //  Adds support for the LDRD and STRD instructions
	MEMHINT_INSTRS          ID_ISAR2 = 0x0F << 4  //+ Indicates the supported Memory Hint instructions
	MEMHINT_INSTRS_0        ID_ISAR2 = 0x00 << 4  //  None supported, ARMv7-M unused.
	MEMHINT_INSTRS_1        ID_ISAR2 = 0x01 << 4  //  Adds support for the PLD instruction, ARMv7-M unused.
	MEMHINT_INSTRS_2        ID_ISAR2 = 0x02 << 4  //  As for 1, ARMv7-M unused.
	MEMHINT_INSTRS_3        ID_ISAR2 = 0x03 << 4  //  As for 1 or 2, and adds support for the PLI instruction.
	MULTIACCESSINT_INSTRS   ID_ISAR2 = 0x0F << 8  //+ Indicates the support for multi-access interruptible instructions
	MULTIACCESSINT_INSTRS_0 ID_ISAR2 = 0x00 << 8  //  None supported. This means the LDM and STM instructions are not interruptible. ARMv7-M unused.
	MULTIACCESSINT_INSTRS_1 ID_ISAR2 = 0x01 << 8  //  LDM and STM instructions are restartable.
	MULTIACCESSINT_INSTRS_2 ID_ISAR2 = 0x02 << 8  //  LDM and STM instructions are continuable.
	MULT_INSTRS             ID_ISAR2 = 0x0F << 12 //+ Indicates the supported additional Multiply instructions
	MULT_INSTRS_0           ID_ISAR2 = 0x00 << 12 //  None supported. This means only MUL is supported. ARMv7-M unused.
	MULT_INSTRS_1           ID_ISAR2 = 0x01 << 12 //  Adds support for the MLA instruction, ARMv7-M unused.
	MULT_INSTRS_2           ID_ISAR2 = 0x02 << 12 //  As for 1, and adds support for the MLS instruction.
	MULTS_INSTRS            ID_ISAR2 = 0x0F << 16 //+ Indicates the supported advanced signed Multiply instructions
	MULTS_INSTRS_0          ID_ISAR2 = 0x00 << 16 //  None supported, ARMv7-M unused
	MULTS_INSTRS_1          ID_ISAR2 = 0x01 << 16 //  Adds support for the SMULL and SMLAL instructions
	MULTS_INSTRS_2          ID_ISAR2 = 0x02 << 16 //  As for 1, and adds support for the SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, and SMULWT instructions.
	MULTS_INSTRS_3          ID_ISAR2 = 0x03 << 16 //  As for 2, and adds support for the SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, and SMUSDX instructions.
	MULTU_INSTRS            ID_ISAR2 = 0x0F << 20 //+ Indicates the supported advanced unsigned Multiply instructions
	MULTU_INSTRS_0          ID_ISAR2 = 0x00 << 20 //  None supported, ARMv7-M unused
	MULTU_INSTRS_1          ID_ISAR2 = 0x01 << 20 //  Adds support for the UMULL and UMLAL instructions.
	MULTU_INSTRS_2          ID_ISAR2 = 0x02 << 20 //  As for 1, and adds support for the UMAAL instruction.
	REVERSAL_INSTRS         ID_ISAR2 = 0x0F << 28 //+ Indicates the supported Reversal instructions
	REVERSAL_INSTRS_0       ID_ISAR2 = 0x00 << 28 //  None supported, ARMv7-M unused
	REVERSAL_INSTRS_1       ID_ISAR2 = 0x01 << 28 //  Adds support for the REV, REV16, and REVSH instructions, ARMv7-M unused.
	REVERSAL_INSTRS_2       ID_ISAR2 = 0x02 << 28 //  As for 1, and adds support for the RBIT instruction.
)

const (
	LOADSTORE_INSTRSn      = 0
	MEMHINT_INSTRSn        = 4
	MULTIACCESSINT_INSTRSn = 8
	MULT_INSTRSn           = 12
	MULTS_INSTRSn          = 16
	MULTU_INSTRSn          = 20
	REVERSAL_INSTRSn       = 28
)

const (
	SATURATE_INSTRS    ID_ISAR3 = 0x0F << 0  //+ Indicates the supported Saturate instructions
	SATURATE_INSTRS_0  ID_ISAR3 = 0x00 << 0  //  None supported
	SATURATE_INSTRS_1  ID_ISAR3 = 0x01 << 0  //  Adds support for the QADD, QDADD, QDSUB, and QSUB instructions, and for the Q bit in the PSRs.
	SIMD_INSTRS        ID_ISAR3 = 0x0F << 4  //+ Indicates the supported SIMD instructions
	SIMD_INSTRS_0      ID_ISAR3 = 0x00 << 4  //  None supported, ARMv7-M unused.
	SIMD_INSTRS_1      ID_ISAR3 = 0x01 << 4  //  Adds support for the SSAT and USAT instructions, and for the Q bit in the PSRs.
	SIMD_INSTRS_3      ID_ISAR3 = 0x03 << 4  //  As for 1, and adds support for the PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, SXTAB16, SXTB16, UADD16, UADD8, UASX, UHADD16, UHADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX, UXTAB16, and UXTB16 instructions. Also adds support for the GE[3:0] bits in the PSRs.
	SVC_INSTRS         ID_ISAR3 = 0x0F << 8  //+ Indicates the supported SVC instructions
	SVC_INSTRS_0       ID_ISAR3 = 0x00 << 8  //  None supported, ARMv7-M unused.
	SVC_INSTRS_1       ID_ISAR3 = 0x01 << 8  //  Adds support for the SVC instruction.
	SYNCHPRIM_INSTRS   ID_ISAR3 = 0x0F << 12 //+ Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the supported Synchronization Primitives
	TABBRANCH_INSTRS   ID_ISAR3 = 0x0F << 16 //+ Indicates the supported Table Branch instructions
	TABBRANCH_INSTRS_0 ID_ISAR3 = 0x00 << 16 //  None supported, ARMv7-M unused.
	TABBRANCH_INSTRS_1 ID_ISAR3 = 0x01 << 16 //  Adds support for the TBB and TBH instructions.
	THUMBCOPY_INSTRS   ID_ISAR3 = 0x0F << 20 //+ Indicates the supported non flag-setting MOV instructions
	THUMBCOPY_INSTRS_0 ID_ISAR3 = 0x00 << 20 //  None supported, ARMv7-M unused.
	THUMBCOPY_INSTRS_1 ID_ISAR3 = 0x01 << 20 //  Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
	TRUENOP_INSTRS     ID_ISAR3 = 0x0F << 24 //+ Indicates the supported non flag-setting MOV instructions
	TRUENOP_INSTRS_0   ID_ISAR3 = 0x00 << 24 //  None supported, ARMv7-M unused.
	TRUENOP_INSTRS_1   ID_ISAR3 = 0x01 << 24 //  Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
)

const (
	SATURATE_INSTRSn  = 0
	SIMD_INSTRSn      = 4
	SVC_INSTRSn       = 8
	SYNCHPRIM_INSTRSn = 12
	TABBRANCH_INSTRSn = 16
	THUMBCOPY_INSTRSn = 20
	TRUENOP_INSTRSn   = 24
)

const (
	UNPRIV_INSTRS         ID_ISAR4 = 0x0F << 0  //+ Indicates the supported unprivileged instructions. These are the instruction variants indicated by a T suffix.
	UNPRIV_INSTRS_0       ID_ISAR4 = 0x00 << 0  //  None supported, ARMv7-M unused.
	UNPRIV_INSTRS_1       ID_ISAR4 = 0x01 << 0  //  Adds support for the LDRBT, LDRT, STRBT, and STRT instructions.
	UNPRIV_INSTRS_2       ID_ISAR4 = 0x02 << 0  //  As for 1, and adds support for the LDRHT, LDRSBT, LDRSHT, and STRHT instructions.
	WITHSHIFTS_INSTRS     ID_ISAR4 = 0x0F << 4  //+ Indicates the support for instructions with shifts
	WITHSHIFTS_INSTRS_0   ID_ISAR4 = 0x00 << 4  //  Nonzero shifts supported only in MOV and shift instructions.
	WITHSHIFTS_INSTRS_1   ID_ISAR4 = 0x01 << 4  //  Adds support for shifts of loads and stores over the range LSL 0-3.
	WITHSHIFTS_INSTRS_3   ID_ISAR4 = 0x03 << 4  //  As for 1, and adds support for other constant shift options, on loads, stores, and other instructions.
	WITHSHIFTS_INSTRS_4   ID_ISAR4 = 0x04 << 4  //  ARMv7-M unused.
	WRITEBACK_INSTRS      ID_ISAR4 = 0x0F << 8  //+ Indicates the support for Writeback addressing modes
	WRITEBACK_INSTRS_0    ID_ISAR4 = 0x00 << 8  //  Basic support. Only the LDM, STM, PUSH, and POP instructions support writeback addressing modes. ARMv7-M unused.
	WRITEBACK_INSTRS_1    ID_ISAR4 = 0x01 << 8  //  Adds support for all of the writeback addressing modes defined in the ARMv7-M architecture.
	BARRIER_INSTRS        ID_ISAR4 = 0x0F << 16 //+ Indicates the supported Barrier instructions
	BARRIER_INSTRS_0      ID_ISAR4 = 0x00 << 16 //  None supported, ARMv7-M unused.
	BARRIER_INSTRS_1      ID_ISAR4 = 0x01 << 16 //  Adds support for the DMB, DSB, and ISB barrier instructions.
	SYNCHPRIM_INSTRS_FRAC ID_ISAR4 = 0x0F << 20 //+ Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported Synchronization Primitives
	PSR_M_INSTRS          ID_ISAR4 = 0x0F << 24 //+ Indicates the supported M profile instructions to modify the PSRs
	PSR_M_INSTRS_0        ID_ISAR4 = 0x00 << 24 //  None supported, ARMv7-M unused.
	PSR_M_INSTRS_1        ID_ISAR4 = 0x01 << 24 //  Adds support for the M-profile forms of the CPS, MRS, and MSR instructions, to access the PSRs.
)

const (
	UNPRIV_INSTRSn         = 0
	WITHSHIFTS_INSTRSn     = 4
	WRITEBACK_INSTRSn      = 8
	BARRIER_INSTRSn        = 16
	SYNCHPRIM_INSTRS_FRACn = 20
	PSR_M_INSTRSn          = 24
)

const (
	CL1     CLIDR = 0x07 << 0  //+ Indicate the type of cache implemented at level 1.
	CL1_0   CLIDR = 0x00 << 0  //  No cache
	CL1_1   CLIDR = 0x01 << 0  //  Instruction cache only
	CL1_2   CLIDR = 0x02 << 0  //  Data cache only
	CL1_3   CLIDR = 0x03 << 0  //  Separate instruction and data caches
	CL1_4   CLIDR = 0x04 << 0  //  Unified cache
	CL2     CLIDR = 0x07 << 3  //+ Indicate the type of cache implemented at level 2.
	CL2_0   CLIDR = 0x00 << 3  //  No cache
	CL2_1   CLIDR = 0x01 << 3  //  Instruction cache only
	CL2_2   CLIDR = 0x02 << 3  //  Data cache only
	CL2_3   CLIDR = 0x03 << 3  //  Separate instruction and data caches
	CL2_4   CLIDR = 0x04 << 3  //  Unified cache
	CL3     CLIDR = 0x07 << 6  //+ Indicate the type of cache implemented at level 3.
	CL3_0   CLIDR = 0x00 << 6  //  No cache
	CL3_1   CLIDR = 0x01 << 6  //  Instruction cache only
	CL3_2   CLIDR = 0x02 << 6  //  Data cache only
	CL3_3   CLIDR = 0x03 << 6  //  Separate instruction and data caches
	CL3_4   CLIDR = 0x04 << 6  //  Unified cache
	CL4     CLIDR = 0x07 << 9  //+ Indicate the type of cache implemented at level 4.
	CL4_0   CLIDR = 0x00 << 9  //  No cache
	CL4_1   CLIDR = 0x01 << 9  //  Instruction cache only
	CL4_2   CLIDR = 0x02 << 9  //  Data cache only
	CL4_3   CLIDR = 0x03 << 9  //  Separate instruction and data caches
	CL4_4   CLIDR = 0x04 << 9  //  Unified cache
	CL5     CLIDR = 0x07 << 12 //+ Indicate the type of cache implemented at level 5.
	CL5_0   CLIDR = 0x00 << 12 //  No cache
	CL5_1   CLIDR = 0x01 << 12 //  Instruction cache only
	CL5_2   CLIDR = 0x02 << 12 //  Data cache only
	CL5_3   CLIDR = 0x03 << 12 //  Separate instruction and data caches
	CL5_4   CLIDR = 0x04 << 12 //  Unified cache
	CL6     CLIDR = 0x07 << 15 //+ Indicate the type of cache implemented at level 6.
	CL6_0   CLIDR = 0x00 << 15 //  No cache
	CL6_1   CLIDR = 0x01 << 15 //  Instruction cache only
	CL6_2   CLIDR = 0x02 << 15 //  Data cache only
	CL6_3   CLIDR = 0x03 << 15 //  Separate instruction and data caches
	CL6_4   CLIDR = 0x04 << 15 //  Unified cache
	CL7     CLIDR = 0x07 << 18 //+ Indicate the type of cache implemented at level 7.
	CL7_0   CLIDR = 0x00 << 18 //  No cache
	CL7_1   CLIDR = 0x01 << 18 //  Instruction cache only
	CL7_2   CLIDR = 0x02 << 18 //  Data cache only
	CL7_3   CLIDR = 0x03 << 18 //  Separate instruction and data caches
	CL7_4   CLIDR = 0x04 << 18 //  Unified cache
	LOUIS   CLIDR = 0x07 << 21 //+ Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ.
	LOUIS_0 CLIDR = 0x00 << 21 //  0
	LOUIS_1 CLIDR = 0x01 << 21 //  1
	LOUIS_2 CLIDR = 0x02 << 21 //  2
	LOUIS_3 CLIDR = 0x03 << 21 //  3
	LOUIS_4 CLIDR = 0x04 << 21 //  4
	LOUIS_5 CLIDR = 0x05 << 21 //  5
	LOUIS_6 CLIDR = 0x06 << 21 //  6
	LOUIS_7 CLIDR = 0x07 << 21 //  7
	LOC     CLIDR = 0x07 << 24 //+ Level of Coherency for the cache hierarchy
	LOC_0   CLIDR = 0x00 << 24 //  0
	LOC_1   CLIDR = 0x01 << 24 //  1
	LOC_2   CLIDR = 0x02 << 24 //  2
	LOC_3   CLIDR = 0x03 << 24 //  3
	LOC_4   CLIDR = 0x04 << 24 //  4
	LOC_5   CLIDR = 0x05 << 24 //  5
	LOC_6   CLIDR = 0x06 << 24 //  6
	LOC_7   CLIDR = 0x07 << 24 //  7
	LOU     CLIDR = 0x07 << 27 //+ Level of Unification for the cache hierarchy
	LOU_0   CLIDR = 0x00 << 27 //  0
	LOU_1   CLIDR = 0x01 << 27 //  1
	LOU_2   CLIDR = 0x02 << 27 //  2
	LOU_3   CLIDR = 0x03 << 27 //  3
	LOU_4   CLIDR = 0x04 << 27 //  4
	LOU_5   CLIDR = 0x05 << 27 //  5
	LOU_6   CLIDR = 0x06 << 27 //  6
	LOU_7   CLIDR = 0x07 << 27 //  7
)

const (
	CL1n   = 0
	CL2n   = 3
	CL3n   = 6
	CL4n   = 9
	CL5n   = 12
	CL6n   = 15
	CL7n   = 18
	LOUISn = 21
	LOCn   = 24
	LOUn   = 27
)

const (
	IMINLINE CTR = 0x0F << 0  //+ Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the processor.
	DMINLINE CTR = 0x0F << 16 //+ Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the processor.
	ERG      CTR = 0x0F << 20 //+ Exclusives Reservation Granule. The maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions, encoded as Log2 of the number of words.
	CWG      CTR = 0x0F << 24 //+ Cache Write-back Granule. The maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified, encoded as Log2 of the number of words.
	FORMAT   CTR = 0x07 << 29 //+ Indicates the implemented CTR format.
	FORMAT_4 CTR = 0x04 << 29 //  ARMv7 format.
)

const (
	IMINLINEn = 0
	DMINLINEn = 16
	ERGn      = 20
	CWGn      = 24
	FORMATn   = 29
)

const (
	LINESIZE      CCSIDR = 0x07 << 0    //+ (Log2(Number of words in cache line)) - 2.
	LINESIZE_0    CCSIDR = 0x00 << 0    //  The line length of 4 words.
	LINESIZE_1    CCSIDR = 0x01 << 0    //  The line length of 8 words.
	LINESIZE_2    CCSIDR = 0x02 << 0    //  The line length of 16 words.
	LINESIZE_3    CCSIDR = 0x03 << 0    //  The line length of 32 words.
	LINESIZE_4    CCSIDR = 0x04 << 0    //  The line length of 64 words.
	LINESIZE_5    CCSIDR = 0x05 << 0    //  The line length of 128 words.
	LINESIZE_6    CCSIDR = 0x06 << 0    //  The line length of 256 words.
	LINESIZE_7    CCSIDR = 0x07 << 0    //  The line length of 512 words.
	ASSOCIATIVITY CCSIDR = 0x3FF << 3   //+ (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.
	NUMSETS       CCSIDR = 0x7FFF << 13 //+ (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
	WA            CCSIDR = 0x01 << 28   //+ Indicates whether the cache level supports write-allocation
	RA            CCSIDR = 0x01 << 29   //+ Indicates whether the cache level supports read-allocation
	WB            CCSIDR = 0x01 << 30   //+ Indicates whether the cache level supports write-back
	WT            CCSIDR = 0x01 << 31   //+ Indicates whether the cache level supports write-through
)

const (
	LINESIZEn      = 0
	ASSOCIATIVITYn = 3
	NUMSETSn       = 13
	WAn            = 28
	RAn            = 29
	WBn            = 30
	WTn            = 31
)

const (
	IND     CSSELR = 0x01 << 0 //+ Instruction not data bit
	LEVEL   CSSELR = 0x07 << 1 //+ Cache level of required cache
	LEVEL_0 CSSELR = 0x00 << 1 //  Level 1 cache.
	LEVEL_1 CSSELR = 0x01 << 1 //  Level 2 cache.
	LEVEL_2 CSSELR = 0x02 << 1 //  Level 3 cache.
	LEVEL_3 CSSELR = 0x03 << 1 //  Level 4 cache.
	LEVEL_4 CSSELR = 0x04 << 1 //  Level 5 cache.
	LEVEL_5 CSSELR = 0x05 << 1 //  Level 6 cache.
	LEVEL_6 CSSELR = 0x06 << 1 //  Level 7 cache.
)

const (
	INDn   = 0
	LEVELn = 1
)

const (
	CP0    CPACR = 0x03 << 0  //+ Access privileges for coprocessor 0.
	CP0_0  CPACR = 0x00 << 0  //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP0_1  CPACR = 0x01 << 0  //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP0_3  CPACR = 0x03 << 0  //  Full access.
	CP1    CPACR = 0x03 << 2  //+ Access privileges for coprocessor 1.
	CP1_0  CPACR = 0x00 << 2  //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP1_1  CPACR = 0x01 << 2  //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP1_3  CPACR = 0x03 << 2  //  Full access.
	CP2    CPACR = 0x03 << 4  //+ Access privileges for coprocessor 2.
	CP2_0  CPACR = 0x00 << 4  //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP2_1  CPACR = 0x01 << 4  //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP2_3  CPACR = 0x03 << 4  //  Full access.
	CP3    CPACR = 0x03 << 6  //+ Access privileges for coprocessor 3.
	CP3_0  CPACR = 0x00 << 6  //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP3_1  CPACR = 0x01 << 6  //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP3_3  CPACR = 0x03 << 6  //  Full access.
	CP4    CPACR = 0x03 << 8  //+ Access privileges for coprocessor 4.
	CP4_0  CPACR = 0x00 << 8  //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP4_1  CPACR = 0x01 << 8  //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP4_3  CPACR = 0x03 << 8  //  Full access.
	CP5    CPACR = 0x03 << 10 //+ Access privileges for coprocessor 5.
	CP5_0  CPACR = 0x00 << 10 //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP5_1  CPACR = 0x01 << 10 //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP5_3  CPACR = 0x03 << 10 //  Full access.
	CP6    CPACR = 0x03 << 12 //+ Access privileges for coprocessor 6.
	CP6_0  CPACR = 0x00 << 12 //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP6_1  CPACR = 0x01 << 12 //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP6_3  CPACR = 0x03 << 12 //  Full access.
	CP7    CPACR = 0x03 << 14 //+ Access privileges for coprocessor 7.
	CP7_0  CPACR = 0x00 << 14 //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP7_1  CPACR = 0x01 << 14 //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP7_3  CPACR = 0x03 << 14 //  Full access.
	CP10   CPACR = 0x03 << 20 //+ Access privileges for coprocessor 10.
	CP10_0 CPACR = 0x00 << 20 //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP10_1 CPACR = 0x01 << 20 //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP10_3 CPACR = 0x03 << 20 //  Full access.
	CP11   CPACR = 0x03 << 22 //+ Access privileges for coprocessor 11.
	CP11_0 CPACR = 0x00 << 22 //  Access denied. Any attempted access generates a NOCP UsageFault.
	CP11_1 CPACR = 0x01 << 22 //  Privileged access only. An unprivileged access generates a NOCP UsageFault.
	CP11_3 CPACR = 0x03 << 22 //  Full access.
)

const (
	CP0n  = 0
	CP1n  = 2
	CP2n  = 4
	CP3n  = 6
	CP4n  = 8
	CP5n  = 10
	CP6n  = 12
	CP7n  = 14
	CP10n = 20
	CP11n = 22
)

const (
	INTID STIR = 0x1FF << 0 //+ Indicates the interrupt to be triggered
)

const (
	INTIDn = 0
)

const (
	ICIALLU ICIALLU = 0xFFFFFFFF << 0 //+ I-cache invalidate all to PoU
)

const (
	ICIALLUn = 0
)

const (
	ICIMVAU ICIMVAU = 0xFFFFFFFF << 0 //+ I-cache invalidate by MVA to PoU
)

const (
	ICIMVAUn = 0
)

const (
	DCIMVAC DCIMVAC = 0xFFFFFFFF << 0 //+ D-cache invalidate by MVA to PoC
)

const (
	DCIMVACn = 0
)

const (
	DCISW DCISW = 0xFFFFFFFF << 0 //+ D-cache invalidate by set-way
)

const (
	DCISWn = 0
)

const (
	DCCMVAU DCCMVAU = 0xFFFFFFFF << 0 //+ D-cache clean by MVA to PoU
)

const (
	DCCMVAUn = 0
)

const (
	DCCMVAC DCCMVAC = 0xFFFFFFFF << 0 //+ D-cache clean by MVA to PoC
)

const (
	DCCMVACn = 0
)

const (
	DCCSW DCCSW = 0xFFFFFFFF << 0 //+ D-cache clean by set-way
)

const (
	DCCSWn = 0
)

const (
	DCCIMVAC DCCIMVAC = 0xFFFFFFFF << 0 //+ D-cache clean and invalidate by MVA to PoC
)

const (
	DCCIMVACn = 0
)

const (
	DCCISW DCCISW = 0xFFFFFFFF << 0 //+ D-cache clean and invalidate by set-way
)

const (
	DCCISWn = 0
)

const (
	EN    CM7_ITCMCR = 0x01 << 0 //+ TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
	RMW   CM7_ITCMCR = 0x01 << 1 //+ Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
	RETEN CM7_ITCMCR = 0x01 << 2 //+ Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
	SZ    CM7_ITCMCR = 0x0F << 3 //+ TCM size. Indicates the size of the relevant TCM.
	SZ_0  CM7_ITCMCR = 0x00 << 3 //  No TCM implemented.
	SZ_3  CM7_ITCMCR = 0x03 << 3 //  4KB.
	SZ_4  CM7_ITCMCR = 0x04 << 3 //  8KB.
	SZ_5  CM7_ITCMCR = 0x05 << 3 //  16KB.
	SZ_6  CM7_ITCMCR = 0x06 << 3 //  32KB.
	SZ_7  CM7_ITCMCR = 0x07 << 3 //  64KB.
	SZ_8  CM7_ITCMCR = 0x08 << 3 //  128KB.
	SZ_9  CM7_ITCMCR = 0x09 << 3 //  256KB.
	SZ_10 CM7_ITCMCR = 0x0A << 3 //  512KB.
	SZ_11 CM7_ITCMCR = 0x0B << 3 //  1MB.
	SZ_12 CM7_ITCMCR = 0x0C << 3 //  2MB.
	SZ_13 CM7_ITCMCR = 0x0D << 3 //  4MB.
	SZ_14 CM7_ITCMCR = 0x0E << 3 //  8MB.
	SZ_15 CM7_ITCMCR = 0x0F << 3 //  16MB.
)

const (
	ENn    = 0
	RMWn   = 1
	RETENn = 2
	SZn    = 3
)

const (
	EN    CM7_DTCMCR = 0x01 << 0 //+ TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
	RMW   CM7_DTCMCR = 0x01 << 1 //+ Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
	RETEN CM7_DTCMCR = 0x01 << 2 //+ Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
	SZ    CM7_DTCMCR = 0x0F << 3 //+ TCM size. Indicates the size of the relevant TCM.
	SZ_0  CM7_DTCMCR = 0x00 << 3 //  No TCM implemented.
	SZ_3  CM7_DTCMCR = 0x03 << 3 //  4KB.
	SZ_4  CM7_DTCMCR = 0x04 << 3 //  8KB.
	SZ_5  CM7_DTCMCR = 0x05 << 3 //  16KB.
	SZ_6  CM7_DTCMCR = 0x06 << 3 //  32KB.
	SZ_7  CM7_DTCMCR = 0x07 << 3 //  64KB.
	SZ_8  CM7_DTCMCR = 0x08 << 3 //  128KB.
	SZ_9  CM7_DTCMCR = 0x09 << 3 //  256KB.
	SZ_10 CM7_DTCMCR = 0x0A << 3 //  512KB.
	SZ_11 CM7_DTCMCR = 0x0B << 3 //  1MB.
	SZ_12 CM7_DTCMCR = 0x0C << 3 //  2MB.
	SZ_13 CM7_DTCMCR = 0x0D << 3 //  4MB.
	SZ_14 CM7_DTCMCR = 0x0E << 3 //  8MB.
	SZ_15 CM7_DTCMCR = 0x0F << 3 //  16MB.
)

const (
	ENn    = 0
	RMWn   = 1
	RETENn = 2
	SZn    = 3
)

const (
	EN   CM7_AHBPCR = 0x01 << 0 //+ AHBP enable.
	SZ   CM7_AHBPCR = 0x07 << 1 //+ AHBP size.
	SZ_0 CM7_AHBPCR = 0x00 << 1 //  0MB. AHBP disabled.
	SZ_1 CM7_AHBPCR = 0x01 << 1 //  64MB.
	SZ_2 CM7_AHBPCR = 0x02 << 1 //  128MB.
	SZ_3 CM7_AHBPCR = 0x03 << 1 //  256MB.
	SZ_4 CM7_AHBPCR = 0x04 << 1 //  512MB.
)

const (
	ENn = 0
	SZn = 1
)

const (
	SIWT    CM7_CACR = 0x01 << 0 //+ Shared cacheable-is-WT for data cache. Enables limited cache coherency usage.
	ECCDIS  CM7_CACR = 0x01 << 1 //+ Enables ECC in the instruction and data cache.
	FORCEWT CM7_CACR = 0x01 << 2 //+ Enables Force Write-Through in the data cache.
)

const (
	SIWTn    = 0
	ECCDISn  = 1
	FORCEWTn = 2
)

const (
	CTL       CM7_AHBSCR = 0x03 << 0  //+ AHBS prioritization control.
	CTL_0     CM7_AHBSCR = 0x00 << 0  //  AHBS access priority demoted. This is the reset value.
	CTL_1     CM7_AHBSCR = 0x01 << 0  //  Software access priority demoted.
	CTL_2     CM7_AHBSCR = 0x02 << 0  //  AHBS access priority demoted by initializing the fairness counter to the CM7_AHBSCR[INITCOUNT] value when the software execution priority is higher than or equal to the threshold level programed in CM7_AHBSCR[TPRI].
	CTL_3     CM7_AHBSCR = 0x03 << 0  //  AHBSPRI signal has control of access priority.
	TPRI      CM7_AHBSCR = 0x1FF << 2 //+ Threshold execution priority for AHBS traffic demotion.
	INITCOUNT CM7_AHBSCR = 0x1F << 11 //+ Fairness counter initialization value.
)

const (
	CTLn       = 0
	TPRIn      = 2
	INITCOUNTn = 11
)

const (
	ITCM       CM7_ABFSR = 0x01 << 0 //+ Asynchronous fault on ITCM interface.
	DTCM       CM7_ABFSR = 0x01 << 1 //+ Asynchronous fault on DTCM interface.
	AHBP       CM7_ABFSR = 0x01 << 2 //+ Asynchronous fault on AHBP interface.
	AXIM       CM7_ABFSR = 0x01 << 3 //+ Asynchronous fault on AXIM interface.
	EPPB       CM7_ABFSR = 0x01 << 4 //+ Asynchronous fault on EPPB interface.
	AXIMTYPE   CM7_ABFSR = 0x03 << 8 //+ Indicates the type of fault on the AXIM interface. Only valid when AXIM is 1.
	AXIMTYPE_0 CM7_ABFSR = 0x00 << 8 //  OKAY.
	AXIMTYPE_1 CM7_ABFSR = 0x01 << 8 //  EXOKAY.
	AXIMTYPE_2 CM7_ABFSR = 0x02 << 8 //  SLVERR.
	AXIMTYPE_3 CM7_ABFSR = 0x03 << 8 //  DECERR.
)

const (
	ITCMn     = 0
	DTCMn     = 1
	AHBPn     = 2
	AXIMn     = 3
	EPPBn     = 4
	AXIMTYPEn = 8
)
