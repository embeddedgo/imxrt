// Code generated by xgen -g; DO NOT EDIT.

//go:build imxrt1060

package usbphy

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	PWD           mmio.R32[PWD]
	PWD_SET       mmio.R32[PWD]
	PWD_CLR       mmio.R32[PWD]
	PWD_TOG       mmio.R32[PWD]
	TX            mmio.R32[TX]
	TX_SET        mmio.R32[TX]
	TX_CLR        mmio.R32[TX]
	TX_TOG        mmio.R32[TX]
	RX            mmio.R32[RX]
	RX_SET        mmio.R32[RX]
	RX_CLR        mmio.R32[RX]
	RX_TOG        mmio.R32[RX]
	CTRL          mmio.R32[CTRL]
	CTRL_SET      mmio.R32[CTRL]
	CTRL_CLR      mmio.R32[CTRL]
	CTRL_TOG      mmio.R32[CTRL]
	STATUS        mmio.R32[STATUS]
	_             [3]uint32
	DEBUG         mmio.R32[DEBUG]
	DEBUG_SET     mmio.R32[DEBUG]
	DEBUG_CLR     mmio.R32[DEBUG]
	DEBUG_TOG     mmio.R32[DEBUG]
	DEBUG0_STATUS mmio.R32[DEBUG0_STATUS]
	_             [3]uint32
	DEBUG1        mmio.R32[DEBUG1]
	DEBUG1_SET    mmio.R32[DEBUG1]
	DEBUG1_CLR    mmio.R32[DEBUG1]
	DEBUG1_TOG    mmio.R32[DEBUG1]
	VERSION       mmio.R32[VERSION]
}

func USBPHY1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USBPHY1_BASE))) }
func USBPHY2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USBPHY2_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type PWD uint32

func TXPWDFS_(p *Periph) mmio.RM32[PWD]    { return mmio.RM32[PWD]{R: &p.PWD, Mask: TXPWDFS} }
func TXPWDIBIAS_(p *Periph) mmio.RM32[PWD] { return mmio.RM32[PWD]{R: &p.PWD, Mask: TXPWDIBIAS} }
func TXPWDV2I_(p *Periph) mmio.RM32[PWD]   { return mmio.RM32[PWD]{R: &p.PWD, Mask: TXPWDV2I} }
func RXPWDENV_(p *Periph) mmio.RM32[PWD]   { return mmio.RM32[PWD]{R: &p.PWD, Mask: RXPWDENV} }
func RXPWD1PT1_(p *Periph) mmio.RM32[PWD]  { return mmio.RM32[PWD]{R: &p.PWD, Mask: RXPWD1PT1} }
func RXPWDDIFF_(p *Periph) mmio.RM32[PWD]  { return mmio.RM32[PWD]{R: &p.PWD, Mask: RXPWDDIFF} }
func RXPWDRX_(p *Periph) mmio.RM32[PWD]    { return mmio.RM32[PWD]{R: &p.PWD, Mask: RXPWDRX} }

type TX uint32

func D_CAL_(p *Periph) mmio.RM32[TX]     { return mmio.RM32[TX]{R: &p.TX, Mask: D_CAL} }
func TXCAL45DN_(p *Periph) mmio.RM32[TX] { return mmio.RM32[TX]{R: &p.TX, Mask: TXCAL45DN} }
func TXCAL45DP_(p *Periph) mmio.RM32[TX] { return mmio.RM32[TX]{R: &p.TX, Mask: TXCAL45DP} }
func USBPHY_TX_EDGECTRL_(p *Periph) mmio.RM32[TX] {
	return mmio.RM32[TX]{R: &p.TX, Mask: USBPHY_TX_EDGECTRL}
}

type RX uint32

func ENVADJ_(p *Periph) mmio.RM32[RX]    { return mmio.RM32[RX]{R: &p.RX, Mask: ENVADJ} }
func DISCONADJ_(p *Periph) mmio.RM32[RX] { return mmio.RM32[RX]{R: &p.RX, Mask: DISCONADJ} }
func RXDBYPASS_(p *Periph) mmio.RM32[RX] { return mmio.RM32[RX]{R: &p.RX, Mask: RXDBYPASS} }

type CTRL uint32

func ENOTG_ID_CHG_IRQ_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENOTG_ID_CHG_IRQ}
}
func ENHOSTDISCONDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENHOSTDISCONDETECT}
}
func ENIRQHOSTDISCON_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENIRQHOSTDISCON}
}
func HOSTDISCONDETECT_IRQ_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: HOSTDISCONDETECT_IRQ}
}
func ENDEVPLUGINDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENDEVPLUGINDETECT}
}
func DEVPLUGIN_POLARITY_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: DEVPLUGIN_POLARITY}
}
func OTG_ID_CHG_IRQ_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: OTG_ID_CHG_IRQ}
}
func ENOTGIDDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENOTGIDDETECT}
}
func RESUMEIRQSTICKY_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: RESUMEIRQSTICKY}
}
func ENIRQRESUMEDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENIRQRESUMEDETECT}
}
func RESUME_IRQ_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: RESUME_IRQ} }
func ENIRQDEVPLUGIN_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENIRQDEVPLUGIN}
}
func DEVPLUGIN_IRQ_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: DEVPLUGIN_IRQ}
}
func DATA_ON_LRADC_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: DATA_ON_LRADC}
}
func ENUTMILEVEL2_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENUTMILEVEL2} }
func ENUTMILEVEL3_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENUTMILEVEL3} }
func ENIRQWAKEUP_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENIRQWAKEUP} }
func WAKEUP_IRQ_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: WAKEUP_IRQ} }
func ENAUTO_PWRON_PLL_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENAUTO_PWRON_PLL}
}
func ENAUTOCLR_CLKGATE_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENAUTOCLR_CLKGATE}
}
func ENAUTOCLR_PHY_PWD_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENAUTOCLR_PHY_PWD}
}
func ENDPDMCHG_WKUP_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENDPDMCHG_WKUP}
}
func ENIDCHG_WKUP_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENIDCHG_WKUP} }
func ENVBUSCHG_WKUP_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ENVBUSCHG_WKUP}
}
func FSDLL_RST_EN_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: FSDLL_RST_EN} }
func OTG_ID_VALUE_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: OTG_ID_VALUE} }
func HOST_FORCE_LS_SE0_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: HOST_FORCE_LS_SE0}
}
func UTMI_SUSPENDM_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: UTMI_SUSPENDM}
}
func CLKGATE_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: CLKGATE} }
func SFTRST_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: SFTRST} }

type STATUS uint32

func HOSTDISCONDETECT_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.STATUS, Mask: HOSTDISCONDETECT_STATUS}
}
func DEVPLUGIN_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.STATUS, Mask: DEVPLUGIN_STATUS}
}
func OTGID_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.STATUS, Mask: OTGID_STATUS}
}
func RESUME_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.STATUS, Mask: RESUME_STATUS}
}

type DEBUG uint32

func OTGIDPIOLOCK_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: OTGIDPIOLOCK}
}
func DEBUG_INTERFACE_HOLD_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: DEBUG_INTERFACE_HOLD}
}
func HSTPULLDOWN_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: HSTPULLDOWN}
}
func ENHSTPULLDOWN_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: ENHSTPULLDOWN}
}
func TX2RXCOUNT_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: TX2RXCOUNT} }
func ENTX2RXCOUNT_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: ENTX2RXCOUNT}
}
func SQUELCHRESETCOUNT_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: SQUELCHRESETCOUNT}
}
func ENSQUELCHRESET_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: ENSQUELCHRESET}
}
func SQUELCHRESETLENGTH_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: SQUELCHRESETLENGTH}
}
func HOST_RESUME_DEBUG_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: HOST_RESUME_DEBUG}
}
func GATECLK_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{R: &p.DEBUG, Mask: GATECLK} }

type DEBUG0_STATUS uint32

func LOOP_BACK_FAIL_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{R: &p.DEBUG0_STATUS, Mask: LOOP_BACK_FAIL_COUNT}
}
func UTMI_RXERROR_FAIL_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{R: &p.DEBUG0_STATUS, Mask: UTMI_RXERROR_FAIL_COUNT}
}
func SQUELCH_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{R: &p.DEBUG0_STATUS, Mask: SQUELCH_COUNT}
}

type DEBUG1 uint32

func ENTAILADJVD_(p *Periph) mmio.RM32[DEBUG1] {
	return mmio.RM32[DEBUG1]{R: &p.DEBUG1, Mask: ENTAILADJVD}
}

type VERSION uint32

func STEP_(p *Periph) mmio.RM32[VERSION]  { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: STEP} }
func MINOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: MINOR} }
func MAJOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: MAJOR} }
