// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build imxrt1060

package usbphy

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	PWD           mmio.R32[PWD]
	PWD_SET       mmio.R32[PWD]
	PWD_CLR       mmio.R32[PWD]
	PWD_TOG       mmio.R32[PWD]
	TX            mmio.R32[TX]
	TX_SET        mmio.R32[TX]
	TX_CLR        mmio.R32[TX]
	TX_TOG        mmio.R32[TX]
	RX            mmio.R32[RX]
	RX_SET        mmio.R32[RX]
	RX_CLR        mmio.R32[RX]
	RX_TOG        mmio.R32[RX]
	CTRL          mmio.R32[CTRL]
	CTRL_SET      mmio.R32[CTRL]
	CTRL_CLR      mmio.R32[CTRL]
	CTRL_TOG      mmio.R32[CTRL]
	STATUS        mmio.R32[STATUS]
	_             [3]uint32
	DEBUG         mmio.R32[DEBUG]
	DEBUG_SET     mmio.R32[DEBUG]
	DEBUG_CLR     mmio.R32[DEBUG]
	DEBUG_TOG     mmio.R32[DEBUG]
	DEBUG0_STATUS mmio.R32[DEBUG0_STATUS]
	_             [3]uint32
	DEBUG1        mmio.R32[DEBUG1]
	DEBUG1_SET    mmio.R32[DEBUG1]
	DEBUG1_CLR    mmio.R32[DEBUG1]
	DEBUG1_TOG    mmio.R32[DEBUG1]
	VERSION       mmio.R32[VERSION]
}

func USBPHY1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USBPHY1_BASE))) }
func USBPHY2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USBPHY2_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type PWD uint32

func TXPWDFS_(p *Periph) mmio.RM32[PWD]    { return mmio.RM32[PWD]{&p.PWD, TXPWDFS} }
func TXPWDIBIAS_(p *Periph) mmio.RM32[PWD] { return mmio.RM32[PWD]{&p.PWD, TXPWDIBIAS} }
func TXPWDV2I_(p *Periph) mmio.RM32[PWD]   { return mmio.RM32[PWD]{&p.PWD, TXPWDV2I} }
func RXPWDENV_(p *Periph) mmio.RM32[PWD]   { return mmio.RM32[PWD]{&p.PWD, RXPWDENV} }
func RXPWD1PT1_(p *Periph) mmio.RM32[PWD]  { return mmio.RM32[PWD]{&p.PWD, RXPWD1PT1} }
func RXPWDDIFF_(p *Periph) mmio.RM32[PWD]  { return mmio.RM32[PWD]{&p.PWD, RXPWDDIFF} }
func RXPWDRX_(p *Periph) mmio.RM32[PWD]    { return mmio.RM32[PWD]{&p.PWD, RXPWDRX} }

type TX uint32

func D_CAL_(p *Periph) mmio.RM32[TX]              { return mmio.RM32[TX]{&p.TX, D_CAL} }
func TXCAL45DN_(p *Periph) mmio.RM32[TX]          { return mmio.RM32[TX]{&p.TX, TXCAL45DN} }
func TXCAL45DP_(p *Periph) mmio.RM32[TX]          { return mmio.RM32[TX]{&p.TX, TXCAL45DP} }
func USBPHY_TX_EDGECTRL_(p *Periph) mmio.RM32[TX] { return mmio.RM32[TX]{&p.TX, USBPHY_TX_EDGECTRL} }

type RX uint32

func ENVADJ_(p *Periph) mmio.RM32[RX]    { return mmio.RM32[RX]{&p.RX, ENVADJ} }
func DISCONADJ_(p *Periph) mmio.RM32[RX] { return mmio.RM32[RX]{&p.RX, DISCONADJ} }
func RXDBYPASS_(p *Periph) mmio.RM32[RX] { return mmio.RM32[RX]{&p.RX, RXDBYPASS} }

type CTRL uint32

func ENOTG_ID_CHG_IRQ_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, ENOTG_ID_CHG_IRQ} }
func ENHOSTDISCONDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, ENHOSTDISCONDETECT}
}
func ENIRQHOSTDISCON_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, ENIRQHOSTDISCON} }
func HOSTDISCONDETECT_IRQ_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, HOSTDISCONDETECT_IRQ}
}
func ENDEVPLUGINDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, ENDEVPLUGINDETECT}
}
func DEVPLUGIN_POLARITY_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, DEVPLUGIN_POLARITY}
}
func OTG_ID_CHG_IRQ_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{&p.CTRL, OTG_ID_CHG_IRQ} }
func ENOTGIDDETECT_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{&p.CTRL, ENOTGIDDETECT} }
func RESUMEIRQSTICKY_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, RESUMEIRQSTICKY} }
func ENIRQRESUMEDETECT_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, ENIRQRESUMEDETECT}
}
func RESUME_IRQ_(p *Periph) mmio.RM32[CTRL]       { return mmio.RM32[CTRL]{&p.CTRL, RESUME_IRQ} }
func ENIRQDEVPLUGIN_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{&p.CTRL, ENIRQDEVPLUGIN} }
func DEVPLUGIN_IRQ_(p *Periph) mmio.RM32[CTRL]    { return mmio.RM32[CTRL]{&p.CTRL, DEVPLUGIN_IRQ} }
func DATA_ON_LRADC_(p *Periph) mmio.RM32[CTRL]    { return mmio.RM32[CTRL]{&p.CTRL, DATA_ON_LRADC} }
func ENUTMILEVEL2_(p *Periph) mmio.RM32[CTRL]     { return mmio.RM32[CTRL]{&p.CTRL, ENUTMILEVEL2} }
func ENUTMILEVEL3_(p *Periph) mmio.RM32[CTRL]     { return mmio.RM32[CTRL]{&p.CTRL, ENUTMILEVEL3} }
func ENIRQWAKEUP_(p *Periph) mmio.RM32[CTRL]      { return mmio.RM32[CTRL]{&p.CTRL, ENIRQWAKEUP} }
func WAKEUP_IRQ_(p *Periph) mmio.RM32[CTRL]       { return mmio.RM32[CTRL]{&p.CTRL, WAKEUP_IRQ} }
func ENAUTO_PWRON_PLL_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, ENAUTO_PWRON_PLL} }
func ENAUTOCLR_CLKGATE_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, ENAUTOCLR_CLKGATE}
}
func ENAUTOCLR_PHY_PWD_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, ENAUTOCLR_PHY_PWD}
}
func ENDPDMCHG_WKUP_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, ENDPDMCHG_WKUP} }
func ENIDCHG_WKUP_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{&p.CTRL, ENIDCHG_WKUP} }
func ENVBUSCHG_WKUP_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, ENVBUSCHG_WKUP} }
func FSDLL_RST_EN_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{&p.CTRL, FSDLL_RST_EN} }
func OTG_ID_VALUE_(p *Periph) mmio.RM32[CTRL]   { return mmio.RM32[CTRL]{&p.CTRL, OTG_ID_VALUE} }
func HOST_FORCE_LS_SE0_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CTRL, HOST_FORCE_LS_SE0}
}
func UTMI_SUSPENDM_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, UTMI_SUSPENDM} }
func CLKGATE_(p *Periph) mmio.RM32[CTRL]       { return mmio.RM32[CTRL]{&p.CTRL, CLKGATE} }
func SFTRST_(p *Periph) mmio.RM32[CTRL]        { return mmio.RM32[CTRL]{&p.CTRL, SFTRST} }

type STATUS uint32

func HOSTDISCONDETECT_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{&p.STATUS, HOSTDISCONDETECT_STATUS}
}
func DEVPLUGIN_STATUS_(p *Periph) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{&p.STATUS, DEVPLUGIN_STATUS}
}
func OTGID_STATUS_(p *Periph) mmio.RM32[STATUS]  { return mmio.RM32[STATUS]{&p.STATUS, OTGID_STATUS} }
func RESUME_STATUS_(p *Periph) mmio.RM32[STATUS] { return mmio.RM32[STATUS]{&p.STATUS, RESUME_STATUS} }

type DEBUG uint32

func OTGIDPIOLOCK_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{&p.DEBUG, OTGIDPIOLOCK} }
func DEBUG_INTERFACE_HOLD_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{&p.DEBUG, DEBUG_INTERFACE_HOLD}
}
func HSTPULLDOWN_(p *Periph) mmio.RM32[DEBUG]   { return mmio.RM32[DEBUG]{&p.DEBUG, HSTPULLDOWN} }
func ENHSTPULLDOWN_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{&p.DEBUG, ENHSTPULLDOWN} }
func TX2RXCOUNT_(p *Periph) mmio.RM32[DEBUG]    { return mmio.RM32[DEBUG]{&p.DEBUG, TX2RXCOUNT} }
func ENTX2RXCOUNT_(p *Periph) mmio.RM32[DEBUG]  { return mmio.RM32[DEBUG]{&p.DEBUG, ENTX2RXCOUNT} }
func SQUELCHRESETCOUNT_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{&p.DEBUG, SQUELCHRESETCOUNT}
}
func ENSQUELCHRESET_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{&p.DEBUG, ENSQUELCHRESET} }
func SQUELCHRESETLENGTH_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{&p.DEBUG, SQUELCHRESETLENGTH}
}
func HOST_RESUME_DEBUG_(p *Periph) mmio.RM32[DEBUG] {
	return mmio.RM32[DEBUG]{&p.DEBUG, HOST_RESUME_DEBUG}
}
func GATECLK_(p *Periph) mmio.RM32[DEBUG] { return mmio.RM32[DEBUG]{&p.DEBUG, GATECLK} }

type DEBUG0_STATUS uint32

func LOOP_BACK_FAIL_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{&p.DEBUG0_STATUS, LOOP_BACK_FAIL_COUNT}
}
func UTMI_RXERROR_FAIL_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{&p.DEBUG0_STATUS, UTMI_RXERROR_FAIL_COUNT}
}
func SQUELCH_COUNT_(p *Periph) mmio.RM32[DEBUG0_STATUS] {
	return mmio.RM32[DEBUG0_STATUS]{&p.DEBUG0_STATUS, SQUELCH_COUNT}
}

type DEBUG1 uint32

func ENTAILADJVD_(p *Periph) mmio.RM32[DEBUG1] { return mmio.RM32[DEBUG1]{&p.DEBUG1, ENTAILADJVD} }

type VERSION uint32

func STEP_(p *Periph) mmio.RM32[VERSION]  { return mmio.RM32[VERSION]{&p.VERSION, STEP} }
func MINOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{&p.VERSION, MINOR} }
func MAJOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{&p.VERSION, MAJOR} }
