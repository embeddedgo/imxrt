// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package can3 provides access to the registers of the CAN peripheral.
//
// Instances:
//  CAN3  CAN3_BASE  -  CAN3*  CAN
// Registers:
//  0x000  32  MCR                Module Configuration Register
//  0x004  32  CTRL1              Control 1 register
//  0x008  32  TIMER              Free Running Timer
//  0x010  32  RXMGMASK           Rx Mailboxes Global Mask Register
//  0x014  32  RX14MASK           Rx 14 Mask register
//  0x018  32  RX15MASK           Rx 15 Mask register
//  0x01C  32  ECR                Error Counter
//  0x020  32  ESR1               Error and Status 1 register
//  0x024  32  IMASK2             Interrupt Masks 2 register
//  0x028  32  IMASK1             Interrupt Masks 1 register
//  0x02C  32  IFLAG2             Interrupt Flags 2 register
//  0x030  32  IFLAG1             Interrupt Flags 1 register
//  0x034  32  CTRL2              Control 2 register
//  0x038  32  ESR2               Error and Status 2 register
//  0x044  32  CRCR               CRC Register
//  0x048  32  RXFGMASK           Legacy Rx FIFO Global Mask register
//  0x04C  32  RXFIR              Legacy Rx FIFO Information Register
//  0x050  32  CBT                CAN Bit Timing Register
//  0x080  32  CS0                Message Buffer 0 CS Register
//  0x080  32  MB0_16B_CS         Message Buffer 0 CS Register
//  0x080  32  MB0_32B_CS         Message Buffer 0 CS Register
//  0x080  32  MB0_64B_CS         Message Buffer 0 CS Register
//  0x080  32  MB0_8B_CS          Message Buffer 0 CS Register
//  0x084  32  MB0_8B_ID          Message Buffer 0 ID Register
//  0x084  32  MB0_16B_ID         Message Buffer 0 ID Register
//  0x084  32  MB0_32B_ID         Message Buffer 0 ID Register
//  0x084  32  MB0_64B_ID         Message Buffer 0 ID Register
//  0x084  32  ID0                Message Buffer 0 ID Register
//  0x088  32  MB0_16B_WORD0      Message Buffer 0 WORD_16B Register
//  0x088  32  MB0_32B_WORD0      Message Buffer 0 WORD_32B Register
//  0x088  32  MB0_64B_WORD0      Message Buffer 0 WORD_64B Register
//  0x088  32  MB0_8B_WORD0       Message Buffer 0 WORD_8B Register
//  0x088  32  WORD00             Message Buffer 0 WORD0 Register
//  0x08C  32  MB0_16B_WORD1      Message Buffer 0 WORD_16B Register
//  0x08C  32  MB0_32B_WORD1      Message Buffer 0 WORD_32B Register
//  0x08C  32  MB0_64B_WORD1      Message Buffer 0 WORD_64B Register
//  0x08C  32  MB0_8B_WORD1       Message Buffer 0 WORD_8B Register
//  0x08C  32  WORD10             Message Buffer 0 WORD1 Register
//  0x090  32  CS1                Message Buffer 1 CS Register
//  0x090  32  MB0_16B_WORD2      Message Buffer 0 WORD_16B Register
//  0x090  32  MB0_32B_WORD2      Message Buffer 0 WORD_32B Register
//  0x090  32  MB1_8B_CS          Message Buffer 1 CS Register
//  0x090  32  MB0_64B_WORD2      Message Buffer 0 WORD_64B Register
//  0x094  32  MB0_64B_WORD3      Message Buffer 0 WORD_64B Register
//  0x094  32  MB1_8B_ID          Message Buffer 1 ID Register
//  0x094  32  MB0_16B_WORD3      Message Buffer 0 WORD_16B Register
//  0x094  32  MB0_32B_WORD3      Message Buffer 0 WORD_32B Register
//  0x094  32  ID1                Message Buffer 1 ID Register
//  0x098  32  MB0_32B_WORD4      Message Buffer 0 WORD_32B Register
//  0x098  32  MB0_64B_WORD4      Message Buffer 0 WORD_64B Register
//  0x098  32  MB1_16B_CS         Message Buffer 1 CS Register
//  0x098  32  MB1_8B_WORD0       Message Buffer 1 WORD_8B Register
//  0x098  32  WORD01             Message Buffer 1 WORD0 Register
//  0x09C  32  MB0_32B_WORD5      Message Buffer 0 WORD_32B Register
//  0x09C  32  MB0_64B_WORD5      Message Buffer 0 WORD_64B Register
//  0x09C  32  MB1_16B_ID         Message Buffer 1 ID Register
//  0x09C  32  MB1_8B_WORD1       Message Buffer 1 WORD_8B Register
//  0x09C  32  WORD11             Message Buffer 1 WORD1 Register
//  0x0A0  32  CS2                Message Buffer 2 CS Register
//  0x0A0  32  MB0_32B_WORD6      Message Buffer 0 WORD_32B Register
//  0x0A0  32  MB0_64B_WORD6      Message Buffer 0 WORD_64B Register
//  0x0A0  32  MB1_16B_WORD0      Message Buffer 1 WORD_16B Register
//  0x0A0  32  MB2_8B_CS          Message Buffer 2 CS Register
//  0x0A4  32  ID2                Message Buffer 2 ID Register
//  0x0A4  32  MB0_32B_WORD7      Message Buffer 0 WORD_32B Register
//  0x0A4  32  MB0_64B_WORD7      Message Buffer 0 WORD_64B Register
//  0x0A4  32  MB1_16B_WORD1      Message Buffer 1 WORD_16B Register
//  0x0A4  32  MB2_8B_ID          Message Buffer 2 ID Register
//  0x0A8  32  MB0_64B_WORD8      Message Buffer 0 WORD_64B Register
//  0x0A8  32  MB1_16B_WORD2      Message Buffer 1 WORD_16B Register
//  0x0A8  32  MB1_32B_CS         Message Buffer 1 CS Register
//  0x0A8  32  MB2_8B_WORD0       Message Buffer 2 WORD_8B Register
//  0x0A8  32  WORD02             Message Buffer 2 WORD0 Register
//  0x0AC  32  MB0_64B_WORD9      Message Buffer 0 WORD_64B Register
//  0x0AC  32  MB1_16B_WORD3      Message Buffer 1 WORD_16B Register
//  0x0AC  32  MB1_32B_ID         Message Buffer 1 ID Register
//  0x0AC  32  WORD12             Message Buffer 2 WORD1 Register
//  0x0AC  32  MB2_8B_WORD1       Message Buffer 2 WORD_8B Register
//  0x0B0  32  CS3                Message Buffer 3 CS Register
//  0x0B0  32  MB0_64B_WORD10     Message Buffer 0 WORD_64B Register
//  0x0B0  32  MB2_16B_CS         Message Buffer 2 CS Register
//  0x0B0  32  MB3_8B_CS          Message Buffer 3 CS Register
//  0x0B0  32  MB1_32B_WORD0      Message Buffer 1 WORD_32B Register
//  0x0B4  32  MB2_16B_ID         Message Buffer 2 ID Register
//  0x0B4  32  MB3_8B_ID          Message Buffer 3 ID Register
//  0x0B4  32  MB0_64B_WORD11     Message Buffer 0 WORD_64B Register
//  0x0B4  32  MB1_32B_WORD1      Message Buffer 1 WORD_32B Register
//  0x0B4  32  ID3                Message Buffer 3 ID Register
//  0x0B8  32  MB0_64B_WORD12     Message Buffer 0 WORD_64B Register
//  0x0B8  32  MB1_32B_WORD2      Message Buffer 1 WORD_32B Register
//  0x0B8  32  MB2_16B_WORD0      Message Buffer 2 WORD_16B Register
//  0x0B8  32  MB3_8B_WORD0       Message Buffer 3 WORD_8B Register
//  0x0B8  32  WORD03             Message Buffer 3 WORD0 Register
//  0x0BC  32  MB0_64B_WORD13     Message Buffer 0 WORD_64B Register
//  0x0BC  32  MB1_32B_WORD3      Message Buffer 1 WORD_32B Register
//  0x0BC  32  MB2_16B_WORD1      Message Buffer 2 WORD_16B Register
//  0x0BC  32  MB3_8B_WORD1       Message Buffer 3 WORD_8B Register
//  0x0BC  32  WORD13             Message Buffer 3 WORD1 Register
//  0x0C0  32  CS4                Message Buffer 4 CS Register
//  0x0C0  32  MB0_64B_WORD14     Message Buffer 0 WORD_64B Register
//  0x0C0  32  MB1_32B_WORD4      Message Buffer 1 WORD_32B Register
//  0x0C0  32  MB2_16B_WORD2      Message Buffer 2 WORD_16B Register
//  0x0C0  32  MB4_8B_CS          Message Buffer 4 CS Register
//  0x0C4  32  ID4                Message Buffer 4 ID Register
//  0x0C4  32  MB0_64B_WORD15     Message Buffer 0 WORD_64B Register
//  0x0C4  32  MB1_32B_WORD5      Message Buffer 1 WORD_32B Register
//  0x0C4  32  MB2_16B_WORD3      Message Buffer 2 WORD_16B Register
//  0x0C4  32  MB4_8B_ID          Message Buffer 4 ID Register
//  0x0C8  32  MB1_32B_WORD6      Message Buffer 1 WORD_32B Register
//  0x0C8  32  MB1_64B_CS         Message Buffer 1 CS Register
//  0x0C8  32  MB3_16B_CS         Message Buffer 3 CS Register
//  0x0C8  32  MB4_8B_WORD0       Message Buffer 4 WORD_8B Register
//  0x0C8  32  WORD04             Message Buffer 4 WORD0 Register
//  0x0CC  32  MB1_32B_WORD7      Message Buffer 1 WORD_32B Register
//  0x0CC  32  MB1_64B_ID         Message Buffer 1 ID Register
//  0x0CC  32  MB3_16B_ID         Message Buffer 3 ID Register
//  0x0CC  32  MB4_8B_WORD1       Message Buffer 4 WORD_8B Register
//  0x0CC  32  WORD14             Message Buffer 4 WORD1 Register
//  0x0D0  32  CS5                Message Buffer 5 CS Register
//  0x0D0  32  MB1_64B_WORD0      Message Buffer 1 WORD_64B Register
//  0x0D0  32  MB2_32B_CS         Message Buffer 2 CS Register
//  0x0D0  32  MB3_16B_WORD0      Message Buffer 3 WORD_16B Register
//  0x0D0  32  MB5_8B_CS          Message Buffer 5 CS Register
//  0x0D4  32  ID5                Message Buffer 5 ID Register
//  0x0D4  32  MB1_64B_WORD1      Message Buffer 1 WORD_64B Register
//  0x0D4  32  MB2_32B_ID         Message Buffer 2 ID Register
//  0x0D4  32  MB3_16B_WORD1      Message Buffer 3 WORD_16B Register
//  0x0D4  32  MB5_8B_ID          Message Buffer 5 ID Register
//  0x0D8  32  MB1_64B_WORD2      Message Buffer 1 WORD_64B Register
//  0x0D8  32  MB2_32B_WORD0      Message Buffer 2 WORD_32B Register
//  0x0D8  32  MB3_16B_WORD2      Message Buffer 3 WORD_16B Register
//  0x0D8  32  MB5_8B_WORD0       Message Buffer 5 WORD_8B Register
//  0x0D8  32  WORD05             Message Buffer 5 WORD0 Register
//  0x0DC  32  MB1_64B_WORD3      Message Buffer 1 WORD_64B Register
//  0x0DC  32  MB2_32B_WORD1      Message Buffer 2 WORD_32B Register
//  0x0DC  32  MB3_16B_WORD3      Message Buffer 3 WORD_16B Register
//  0x0DC  32  MB5_8B_WORD1       Message Buffer 5 WORD_8B Register
//  0x0DC  32  WORD15             Message Buffer 5 WORD1 Register
//  0x0E0  32  CS6                Message Buffer 6 CS Register
//  0x0E0  32  MB1_64B_WORD4      Message Buffer 1 WORD_64B Register
//  0x0E0  32  MB2_32B_WORD2      Message Buffer 2 WORD_32B Register
//  0x0E0  32  MB4_16B_CS         Message Buffer 4 CS Register
//  0x0E0  32  MB6_8B_CS          Message Buffer 6 CS Register
//  0x0E4  32  ID6                Message Buffer 6 ID Register
//  0x0E4  32  MB1_64B_WORD5      Message Buffer 1 WORD_64B Register
//  0x0E4  32  MB2_32B_WORD3      Message Buffer 2 WORD_32B Register
//  0x0E4  32  MB4_16B_ID         Message Buffer 4 ID Register
//  0x0E4  32  MB6_8B_ID          Message Buffer 6 ID Register
//  0x0E8  32  MB1_64B_WORD6      Message Buffer 1 WORD_64B Register
//  0x0E8  32  MB2_32B_WORD4      Message Buffer 2 WORD_32B Register
//  0x0E8  32  MB4_16B_WORD0      Message Buffer 4 WORD_16B Register
//  0x0E8  32  MB6_8B_WORD0       Message Buffer 6 WORD_8B Register
//  0x0E8  32  WORD06             Message Buffer 6 WORD0 Register
//  0x0EC  32  MB1_64B_WORD7      Message Buffer 1 WORD_64B Register
//  0x0EC  32  MB2_32B_WORD5      Message Buffer 2 WORD_32B Register
//  0x0EC  32  MB4_16B_WORD1      Message Buffer 4 WORD_16B Register
//  0x0EC  32  MB6_8B_WORD1       Message Buffer 6 WORD_8B Register
//  0x0EC  32  WORD16             Message Buffer 6 WORD1 Register
//  0x0F0  32  CS7                Message Buffer 7 CS Register
//  0x0F0  32  MB1_64B_WORD8      Message Buffer 1 WORD_64B Register
//  0x0F0  32  MB2_32B_WORD6      Message Buffer 2 WORD_32B Register
//  0x0F0  32  MB4_16B_WORD2      Message Buffer 4 WORD_16B Register
//  0x0F0  32  MB7_8B_CS          Message Buffer 7 CS Register
//  0x0F4  32  MB7_8B_ID          Message Buffer 7 ID Register
//  0x0F4  32  MB1_64B_WORD9      Message Buffer 1 WORD_64B Register
//  0x0F4  32  MB2_32B_WORD7      Message Buffer 2 WORD_32B Register
//  0x0F4  32  MB4_16B_WORD3      Message Buffer 4 WORD_16B Register
//  0x0F4  32  ID7                Message Buffer 7 ID Register
//  0x0F8  32  MB1_64B_WORD10     Message Buffer 1 WORD_64B Register
//  0x0F8  32  MB3_32B_CS         Message Buffer 3 CS Register
//  0x0F8  32  MB5_16B_CS         Message Buffer 5 CS Register
//  0x0F8  32  MB7_8B_WORD0       Message Buffer 7 WORD_8B Register
//  0x0F8  32  WORD07             Message Buffer 7 WORD0 Register
//  0x0FC  32  MB1_64B_WORD11     Message Buffer 1 WORD_64B Register
//  0x0FC  32  MB3_32B_ID         Message Buffer 3 ID Register
//  0x0FC  32  MB5_16B_ID         Message Buffer 5 ID Register
//  0x0FC  32  MB7_8B_WORD1       Message Buffer 7 WORD_8B Register
//  0x0FC  32  WORD17             Message Buffer 7 WORD1 Register
//  0x100  32  CS8                Message Buffer 8 CS Register
//  0x100  32  MB1_64B_WORD12     Message Buffer 1 WORD_64B Register
//  0x100  32  MB3_32B_WORD0      Message Buffer 3 WORD_32B Register
//  0x100  32  MB5_16B_WORD0      Message Buffer 5 WORD_16B Register
//  0x100  32  MB8_8B_CS          Message Buffer 8 CS Register
//  0x104  32  ID8                Message Buffer 8 ID Register
//  0x104  32  MB1_64B_WORD13     Message Buffer 1 WORD_64B Register
//  0x104  32  MB3_32B_WORD1      Message Buffer 3 WORD_32B Register
//  0x104  32  MB5_16B_WORD1      Message Buffer 5 WORD_16B Register
//  0x104  32  MB8_8B_ID          Message Buffer 8 ID Register
//  0x108  32  MB1_64B_WORD14     Message Buffer 1 WORD_64B Register
//  0x108  32  MB3_32B_WORD2      Message Buffer 3 WORD_32B Register
//  0x108  32  MB5_16B_WORD2      Message Buffer 5 WORD_16B Register
//  0x108  32  MB8_8B_WORD0       Message Buffer 8 WORD_8B Register
//  0x108  32  WORD08             Message Buffer 8 WORD0 Register
//  0x10C  32  MB1_64B_WORD15     Message Buffer 1 WORD_64B Register
//  0x10C  32  MB3_32B_WORD3      Message Buffer 3 WORD_32B Register
//  0x10C  32  MB5_16B_WORD3      Message Buffer 5 WORD_16B Register
//  0x10C  32  MB8_8B_WORD1       Message Buffer 8 WORD_8B Register
//  0x10C  32  WORD18             Message Buffer 8 WORD1 Register
//  0x110  32  CS9                Message Buffer 9 CS Register
//  0x110  32  MB2_64B_CS         Message Buffer 2 CS Register
//  0x110  32  MB3_32B_WORD4      Message Buffer 3 WORD_32B Register
//  0x110  32  MB6_16B_CS         Message Buffer 6 CS Register
//  0x110  32  MB9_8B_CS          Message Buffer 9 CS Register
//  0x114  32  ID9                Message Buffer 9 ID Register
//  0x114  32  MB2_64B_ID         Message Buffer 2 ID Register
//  0x114  32  MB3_32B_WORD5      Message Buffer 3 WORD_32B Register
//  0x114  32  MB6_16B_ID         Message Buffer 6 ID Register
//  0x114  32  MB9_8B_ID          Message Buffer 9 ID Register
//  0x118  32  MB2_64B_WORD0      Message Buffer 2 WORD_64B Register
//  0x118  32  MB3_32B_WORD6      Message Buffer 3 WORD_32B Register
//  0x118  32  MB6_16B_WORD0      Message Buffer 6 WORD_16B Register
//  0x118  32  MB9_8B_WORD0       Message Buffer 9 WORD_8B Register
//  0x118  32  WORD09             Message Buffer 9 WORD0 Register
//  0x11C  32  MB2_64B_WORD1      Message Buffer 2 WORD_64B Register
//  0x11C  32  MB3_32B_WORD7      Message Buffer 3 WORD_32B Register
//  0x11C  32  MB6_16B_WORD1      Message Buffer 6 WORD_16B Register
//  0x11C  32  MB9_8B_WORD1       Message Buffer 9 WORD_8B Register
//  0x11C  32  WORD19             Message Buffer 9 WORD1 Register
//  0x120  32  CS10               Message Buffer 10 CS Register
//  0x120  32  MB10_8B_CS         Message Buffer 10 CS Register
//  0x120  32  MB2_64B_WORD2      Message Buffer 2 WORD_64B Register
//  0x120  32  MB4_32B_CS         Message Buffer 4 CS Register
//  0x120  32  MB6_16B_WORD2      Message Buffer 6 WORD_16B Register
//  0x124  32  ID10               Message Buffer 10 ID Register
//  0x124  32  MB10_8B_ID         Message Buffer 10 ID Register
//  0x124  32  MB2_64B_WORD3      Message Buffer 2 WORD_64B Register
//  0x124  32  MB4_32B_ID         Message Buffer 4 ID Register
//  0x124  32  MB6_16B_WORD3      Message Buffer 6 WORD_16B Register
//  0x128  32  MB10_8B_WORD0      Message Buffer 10 WORD_8B Register
//  0x128  32  MB2_64B_WORD4      Message Buffer 2 WORD_64B Register
//  0x128  32  MB4_32B_WORD0      Message Buffer 4 WORD_32B Register
//  0x128  32  MB7_16B_CS         Message Buffer 7 CS Register
//  0x128  32  WORD010            Message Buffer 10 WORD0 Register
//  0x12C  32  MB10_8B_WORD1      Message Buffer 10 WORD_8B Register
//  0x12C  32  MB2_64B_WORD5      Message Buffer 2 WORD_64B Register
//  0x12C  32  MB4_32B_WORD1      Message Buffer 4 WORD_32B Register
//  0x12C  32  MB7_16B_ID         Message Buffer 7 ID Register
//  0x12C  32  WORD110            Message Buffer 10 WORD1 Register
//  0x130  32  CS11               Message Buffer 11 CS Register
//  0x130  32  MB11_8B_CS         Message Buffer 11 CS Register
//  0x130  32  MB2_64B_WORD6      Message Buffer 2 WORD_64B Register
//  0x130  32  MB4_32B_WORD2      Message Buffer 4 WORD_32B Register
//  0x130  32  MB7_16B_WORD0      Message Buffer 7 WORD_16B Register
//  0x134  32  ID11               Message Buffer 11 ID Register
//  0x134  32  MB11_8B_ID         Message Buffer 11 ID Register
//  0x134  32  MB2_64B_WORD7      Message Buffer 2 WORD_64B Register
//  0x134  32  MB4_32B_WORD3      Message Buffer 4 WORD_32B Register
//  0x134  32  MB7_16B_WORD1      Message Buffer 7 WORD_16B Register
//  0x138  32  MB11_8B_WORD0      Message Buffer 11 WORD_8B Register
//  0x138  32  MB2_64B_WORD8      Message Buffer 2 WORD_64B Register
//  0x138  32  MB4_32B_WORD4      Message Buffer 4 WORD_32B Register
//  0x138  32  MB7_16B_WORD2      Message Buffer 7 WORD_16B Register
//  0x138  32  WORD011            Message Buffer 11 WORD0 Register
//  0x13C  32  MB11_8B_WORD1      Message Buffer 11 WORD_8B Register
//  0x13C  32  MB2_64B_WORD9      Message Buffer 2 WORD_64B Register
//  0x13C  32  MB4_32B_WORD5      Message Buffer 4 WORD_32B Register
//  0x13C  32  MB7_16B_WORD3      Message Buffer 7 WORD_16B Register
//  0x13C  32  WORD111            Message Buffer 11 WORD1 Register
//  0x140  32  CS12               Message Buffer 12 CS Register
//  0x140  32  MB12_8B_CS         Message Buffer 12 CS Register
//  0x140  32  MB2_64B_WORD10     Message Buffer 2 WORD_64B Register
//  0x140  32  MB4_32B_WORD6      Message Buffer 4 WORD_32B Register
//  0x140  32  MB8_16B_CS         Message Buffer 8 CS Register
//  0x144  32  ID12               Message Buffer 12 ID Register
//  0x144  32  MB12_8B_ID         Message Buffer 12 ID Register
//  0x144  32  MB2_64B_WORD11     Message Buffer 2 WORD_64B Register
//  0x144  32  MB4_32B_WORD7      Message Buffer 4 WORD_32B Register
//  0x144  32  MB8_16B_ID         Message Buffer 8 ID Register
//  0x148  32  MB12_8B_WORD0      Message Buffer 12 WORD_8B Register
//  0x148  32  MB2_64B_WORD12     Message Buffer 2 WORD_64B Register
//  0x148  32  MB5_32B_CS         Message Buffer 5 CS Register
//  0x148  32  MB8_16B_WORD0      Message Buffer 8 WORD_16B Register
//  0x148  32  WORD012            Message Buffer 12 WORD0 Register
//  0x14C  32  MB12_8B_WORD1      Message Buffer 12 WORD_8B Register
//  0x14C  32  MB2_64B_WORD13     Message Buffer 2 WORD_64B Register
//  0x14C  32  MB5_32B_ID         Message Buffer 5 ID Register
//  0x14C  32  MB8_16B_WORD1      Message Buffer 8 WORD_16B Register
//  0x14C  32  WORD112            Message Buffer 12 WORD1 Register
//  0x150  32  CS13               Message Buffer 13 CS Register
//  0x150  32  MB13_8B_CS         Message Buffer 13 CS Register
//  0x150  32  MB2_64B_WORD14     Message Buffer 2 WORD_64B Register
//  0x150  32  MB5_32B_WORD0      Message Buffer 5 WORD_32B Register
//  0x150  32  MB8_16B_WORD2      Message Buffer 8 WORD_16B Register
//  0x154  32  ID13               Message Buffer 13 ID Register
//  0x154  32  MB13_8B_ID         Message Buffer 13 ID Register
//  0x154  32  MB2_64B_WORD15     Message Buffer 2 WORD_64B Register
//  0x154  32  MB5_32B_WORD1      Message Buffer 5 WORD_32B Register
//  0x154  32  MB8_16B_WORD3      Message Buffer 8 WORD_16B Register
//  0x158  32  MB13_8B_WORD0      Message Buffer 13 WORD_8B Register
//  0x158  32  MB3_64B_CS         Message Buffer 3 CS Register
//  0x158  32  MB5_32B_WORD2      Message Buffer 5 WORD_32B Register
//  0x158  32  MB9_16B_CS         Message Buffer 9 CS Register
//  0x158  32  WORD013            Message Buffer 13 WORD0 Register
//  0x15C  32  MB13_8B_WORD1      Message Buffer 13 WORD_8B Register
//  0x15C  32  MB3_64B_ID         Message Buffer 3 ID Register
//  0x15C  32  MB5_32B_WORD3      Message Buffer 5 WORD_32B Register
//  0x15C  32  MB9_16B_ID         Message Buffer 9 ID Register
//  0x15C  32  WORD113            Message Buffer 13 WORD1 Register
//  0x160  32  MB9_16B_WORD0      Message Buffer 9 WORD_16B Register
//  0x160  32  MB14_8B_CS         Message Buffer 14 CS Register
//  0x160  32  MB3_64B_WORD0      Message Buffer 3 WORD_64B Register
//  0x160  32  MB5_32B_WORD4      Message Buffer 5 WORD_32B Register
//  0x160  32  CS14               Message Buffer 14 CS Register
//  0x164  32  ID14               Message Buffer 14 ID Register
//  0x164  32  MB14_8B_ID         Message Buffer 14 ID Register
//  0x164  32  MB3_64B_WORD1      Message Buffer 3 WORD_64B Register
//  0x164  32  MB5_32B_WORD5      Message Buffer 5 WORD_32B Register
//  0x164  32  MB9_16B_WORD1      Message Buffer 9 WORD_16B Register
//  0x168  32  WORD014            Message Buffer 14 WORD0 Register
//  0x168  32  MB3_64B_WORD2      Message Buffer 3 WORD_64B Register
//  0x168  32  MB5_32B_WORD6      Message Buffer 5 WORD_32B Register
//  0x168  32  MB9_16B_WORD2      Message Buffer 9 WORD_16B Register
//  0x168  32  MB14_8B_WORD0      Message Buffer 14 WORD_8B Register
//  0x16C  32  MB14_8B_WORD1      Message Buffer 14 WORD_8B Register
//  0x16C  32  MB3_64B_WORD3      Message Buffer 3 WORD_64B Register
//  0x16C  32  MB5_32B_WORD7      Message Buffer 5 WORD_32B Register
//  0x16C  32  MB9_16B_WORD3      Message Buffer 9 WORD_16B Register
//  0x16C  32  WORD114            Message Buffer 14 WORD1 Register
//  0x170  32  MB15_8B_CS         Message Buffer 15 CS Register
//  0x170  32  MB10_16B_CS        Message Buffer 10 CS Register
//  0x170  32  CS15               Message Buffer 15 CS Register
//  0x170  32  MB3_64B_WORD4      Message Buffer 3 WORD_64B Register
//  0x170  32  MB6_32B_CS         Message Buffer 6 CS Register
//  0x174  32  MB6_32B_ID         Message Buffer 6 ID Register
//  0x174  32  MB10_16B_ID        Message Buffer 10 ID Register
//  0x174  32  MB15_8B_ID         Message Buffer 15 ID Register
//  0x174  32  MB3_64B_WORD5      Message Buffer 3 WORD_64B Register
//  0x174  32  ID15               Message Buffer 15 ID Register
//  0x178  32  MB15_8B_WORD0      Message Buffer 15 WORD_8B Register
//  0x178  32  MB3_64B_WORD6      Message Buffer 3 WORD_64B Register
//  0x178  32  MB6_32B_WORD0      Message Buffer 6 WORD_32B Register
//  0x178  32  WORD015            Message Buffer 15 WORD0 Register
//  0x178  32  MB10_16B_WORD0     Message Buffer 10 WORD_16B Register
//  0x17C  32  WORD115            Message Buffer 15 WORD1 Register
//  0x17C  32  MB10_16B_WORD1     Message Buffer 10 WORD_16B Register
//  0x17C  32  MB15_8B_WORD1      Message Buffer 15 WORD_8B Register
//  0x17C  32  MB6_32B_WORD1      Message Buffer 6 WORD_32B Register
//  0x17C  32  MB3_64B_WORD7      Message Buffer 3 WORD_64B Register
//  0x180  32  CS16               Message Buffer 16 CS Register
//  0x180  32  MB10_16B_WORD2     Message Buffer 10 WORD_16B Register
//  0x180  32  MB16_8B_CS         Message Buffer 16 CS Register
//  0x180  32  MB3_64B_WORD8      Message Buffer 3 WORD_64B Register
//  0x180  32  MB6_32B_WORD2      Message Buffer 6 WORD_32B Register
//  0x184  32  MB6_32B_WORD3      Message Buffer 6 WORD_32B Register
//  0x184  32  MB10_16B_WORD3     Message Buffer 10 WORD_16B Register
//  0x184  32  MB16_8B_ID         Message Buffer 16 ID Register
//  0x184  32  MB3_64B_WORD9      Message Buffer 3 WORD_64B Register
//  0x184  32  ID16               Message Buffer 16 ID Register
//  0x188  32  MB11_16B_CS        Message Buffer 11 CS Register
//  0x188  32  MB16_8B_WORD0      Message Buffer 16 WORD_8B Register
//  0x188  32  MB3_64B_WORD10     Message Buffer 3 WORD_64B Register
//  0x188  32  MB6_32B_WORD4      Message Buffer 6 WORD_32B Register
//  0x188  32  WORD016            Message Buffer 16 WORD0 Register
//  0x18C  32  MB11_16B_ID        Message Buffer 11 ID Register
//  0x18C  32  MB16_8B_WORD1      Message Buffer 16 WORD_8B Register
//  0x18C  32  MB3_64B_WORD11     Message Buffer 3 WORD_64B Register
//  0x18C  32  MB6_32B_WORD5      Message Buffer 6 WORD_32B Register
//  0x18C  32  WORD116            Message Buffer 16 WORD1 Register
//  0x190  32  MB6_32B_WORD6      Message Buffer 6 WORD_32B Register
//  0x190  32  MB11_16B_WORD0     Message Buffer 11 WORD_16B Register
//  0x190  32  MB17_8B_CS         Message Buffer 17 CS Register
//  0x190  32  MB3_64B_WORD12     Message Buffer 3 WORD_64B Register
//  0x190  32  CS17               Message Buffer 17 CS Register
//  0x194  32  MB11_16B_WORD1     Message Buffer 11 WORD_16B Register
//  0x194  32  MB17_8B_ID         Message Buffer 17 ID Register
//  0x194  32  MB3_64B_WORD13     Message Buffer 3 WORD_64B Register
//  0x194  32  MB6_32B_WORD7      Message Buffer 6 WORD_32B Register
//  0x194  32  ID17               Message Buffer 17 ID Register
//  0x198  32  MB11_16B_WORD2     Message Buffer 11 WORD_16B Register
//  0x198  32  MB17_8B_WORD0      Message Buffer 17 WORD_8B Register
//  0x198  32  MB3_64B_WORD14     Message Buffer 3 WORD_64B Register
//  0x198  32  MB7_32B_CS         Message Buffer 7 CS Register
//  0x198  32  WORD017            Message Buffer 17 WORD0 Register
//  0x19C  32  WORD117            Message Buffer 17 WORD1 Register
//  0x19C  32  MB17_8B_WORD1      Message Buffer 17 WORD_8B Register
//  0x19C  32  MB3_64B_WORD15     Message Buffer 3 WORD_64B Register
//  0x19C  32  MB7_32B_ID         Message Buffer 7 ID Register
//  0x19C  32  MB11_16B_WORD3     Message Buffer 11 WORD_16B Register
//  0x1A0  32  CS18               Message Buffer 18 CS Register
//  0x1A0  32  MB12_16B_CS        Message Buffer 12 CS Register
//  0x1A0  32  MB18_8B_CS         Message Buffer 18 CS Register
//  0x1A0  32  MB4_64B_CS         Message Buffer 4 CS Register
//  0x1A0  32  MB7_32B_WORD0      Message Buffer 7 WORD_32B Register
//  0x1A4  32  MB7_32B_WORD1      Message Buffer 7 WORD_32B Register
//  0x1A4  32  MB12_16B_ID        Message Buffer 12 ID Register
//  0x1A4  32  ID18               Message Buffer 18 ID Register
//  0x1A4  32  MB4_64B_ID         Message Buffer 4 ID Register
//  0x1A4  32  MB18_8B_ID         Message Buffer 18 ID Register
//  0x1A8  32  MB12_16B_WORD0     Message Buffer 12 WORD_16B Register
//  0x1A8  32  MB18_8B_WORD0      Message Buffer 18 WORD_8B Register
//  0x1A8  32  MB4_64B_WORD0      Message Buffer 4 WORD_64B Register
//  0x1A8  32  MB7_32B_WORD2      Message Buffer 7 WORD_32B Register
//  0x1A8  32  WORD018            Message Buffer 18 WORD0 Register
//  0x1AC  32  MB12_16B_WORD1     Message Buffer 12 WORD_16B Register
//  0x1AC  32  MB18_8B_WORD1      Message Buffer 18 WORD_8B Register
//  0x1AC  32  MB4_64B_WORD1      Message Buffer 4 WORD_64B Register
//  0x1AC  32  WORD118            Message Buffer 18 WORD1 Register
//  0x1AC  32  MB7_32B_WORD3      Message Buffer 7 WORD_32B Register
//  0x1B0  32  CS19               Message Buffer 19 CS Register
//  0x1B0  32  MB12_16B_WORD2     Message Buffer 12 WORD_16B Register
//  0x1B0  32  MB19_8B_CS         Message Buffer 19 CS Register
//  0x1B0  32  MB4_64B_WORD2      Message Buffer 4 WORD_64B Register
//  0x1B0  32  MB7_32B_WORD4      Message Buffer 7 WORD_32B Register
//  0x1B4  32  ID19               Message Buffer 19 ID Register
//  0x1B4  32  MB12_16B_WORD3     Message Buffer 12 WORD_16B Register
//  0x1B4  32  MB19_8B_ID         Message Buffer 19 ID Register
//  0x1B4  32  MB4_64B_WORD3      Message Buffer 4 WORD_64B Register
//  0x1B4  32  MB7_32B_WORD5      Message Buffer 7 WORD_32B Register
//  0x1B8  32  MB13_16B_CS        Message Buffer 13 CS Register
//  0x1B8  32  MB19_8B_WORD0      Message Buffer 19 WORD_8B Register
//  0x1B8  32  MB4_64B_WORD4      Message Buffer 4 WORD_64B Register
//  0x1B8  32  MB7_32B_WORD6      Message Buffer 7 WORD_32B Register
//  0x1B8  32  WORD019            Message Buffer 19 WORD0 Register
//  0x1BC  32  MB13_16B_ID        Message Buffer 13 ID Register
//  0x1BC  32  MB19_8B_WORD1      Message Buffer 19 WORD_8B Register
//  0x1BC  32  MB4_64B_WORD5      Message Buffer 4 WORD_64B Register
//  0x1BC  32  MB7_32B_WORD7      Message Buffer 7 WORD_32B Register
//  0x1BC  32  WORD119            Message Buffer 19 WORD1 Register
//  0x1C0  32  CS20               Message Buffer 20 CS Register
//  0x1C0  32  MB13_16B_WORD0     Message Buffer 13 WORD_16B Register
//  0x1C0  32  MB20_8B_CS         Message Buffer 20 CS Register
//  0x1C0  32  MB4_64B_WORD6      Message Buffer 4 WORD_64B Register
//  0x1C0  32  MB8_32B_CS         Message Buffer 8 CS Register
//  0x1C4  32  ID20               Message Buffer 20 ID Register
//  0x1C4  32  MB13_16B_WORD1     Message Buffer 13 WORD_16B Register
//  0x1C4  32  MB20_8B_ID         Message Buffer 20 ID Register
//  0x1C4  32  MB4_64B_WORD7      Message Buffer 4 WORD_64B Register
//  0x1C4  32  MB8_32B_ID         Message Buffer 8 ID Register
//  0x1C8  32  MB13_16B_WORD2     Message Buffer 13 WORD_16B Register
//  0x1C8  32  MB20_8B_WORD0      Message Buffer 20 WORD_8B Register
//  0x1C8  32  MB4_64B_WORD8      Message Buffer 4 WORD_64B Register
//  0x1C8  32  MB8_32B_WORD0      Message Buffer 8 WORD_32B Register
//  0x1C8  32  WORD020            Message Buffer 20 WORD0 Register
//  0x1CC  32  MB13_16B_WORD3     Message Buffer 13 WORD_16B Register
//  0x1CC  32  MB20_8B_WORD1      Message Buffer 20 WORD_8B Register
//  0x1CC  32  MB4_64B_WORD9      Message Buffer 4 WORD_64B Register
//  0x1CC  32  MB8_32B_WORD1      Message Buffer 8 WORD_32B Register
//  0x1CC  32  WORD120            Message Buffer 20 WORD1 Register
//  0x1D0  32  CS21               Message Buffer 21 CS Register
//  0x1D0  32  MB14_16B_CS        Message Buffer 14 CS Register
//  0x1D0  32  MB21_8B_CS         Message Buffer 21 CS Register
//  0x1D0  32  MB4_64B_WORD10     Message Buffer 4 WORD_64B Register
//  0x1D0  32  MB8_32B_WORD2      Message Buffer 8 WORD_32B Register
//  0x1D4  32  ID21               Message Buffer 21 ID Register
//  0x1D4  32  MB14_16B_ID        Message Buffer 14 ID Register
//  0x1D4  32  MB21_8B_ID         Message Buffer 21 ID Register
//  0x1D4  32  MB4_64B_WORD11     Message Buffer 4 WORD_64B Register
//  0x1D4  32  MB8_32B_WORD3      Message Buffer 8 WORD_32B Register
//  0x1D8  32  MB14_16B_WORD0     Message Buffer 14 WORD_16B Register
//  0x1D8  32  MB21_8B_WORD0      Message Buffer 21 WORD_8B Register
//  0x1D8  32  MB4_64B_WORD12     Message Buffer 4 WORD_64B Register
//  0x1D8  32  MB8_32B_WORD4      Message Buffer 8 WORD_32B Register
//  0x1D8  32  WORD021            Message Buffer 21 WORD0 Register
//  0x1DC  32  MB14_16B_WORD1     Message Buffer 14 WORD_16B Register
//  0x1DC  32  MB21_8B_WORD1      Message Buffer 21 WORD_8B Register
//  0x1DC  32  MB4_64B_WORD13     Message Buffer 4 WORD_64B Register
//  0x1DC  32  MB8_32B_WORD5      Message Buffer 8 WORD_32B Register
//  0x1DC  32  WORD121            Message Buffer 21 WORD1 Register
//  0x1E0  32  MB8_32B_WORD6      Message Buffer 8 WORD_32B Register
//  0x1E0  32  MB14_16B_WORD2     Message Buffer 14 WORD_16B Register
//  0x1E0  32  MB22_8B_CS         Message Buffer 22 CS Register
//  0x1E0  32  MB4_64B_WORD14     Message Buffer 4 WORD_64B Register
//  0x1E0  32  CS22               Message Buffer 22 CS Register
//  0x1E4  32  ID22               Message Buffer 22 ID Register
//  0x1E4  32  MB14_16B_WORD3     Message Buffer 14 WORD_16B Register
//  0x1E4  32  MB22_8B_ID         Message Buffer 22 ID Register
//  0x1E4  32  MB4_64B_WORD15     Message Buffer 4 WORD_64B Register
//  0x1E4  32  MB8_32B_WORD7      Message Buffer 8 WORD_32B Register
//  0x1E8  32  WORD022            Message Buffer 22 WORD0 Register
//  0x1E8  32  MB22_8B_WORD0      Message Buffer 22 WORD_8B Register
//  0x1E8  32  MB5_64B_CS         Message Buffer 5 CS Register
//  0x1E8  32  MB9_32B_CS         Message Buffer 9 CS Register
//  0x1E8  32  MB15_16B_CS        Message Buffer 15 CS Register
//  0x1EC  32  MB15_16B_ID        Message Buffer 15 ID Register
//  0x1EC  32  MB22_8B_WORD1      Message Buffer 22 WORD_8B Register
//  0x1EC  32  MB5_64B_ID         Message Buffer 5 ID Register
//  0x1EC  32  MB9_32B_ID         Message Buffer 9 ID Register
//  0x1EC  32  WORD122            Message Buffer 22 WORD1 Register
//  0x1F0  32  MB23_8B_CS         Message Buffer 23 CS Register
//  0x1F0  32  MB15_16B_WORD0     Message Buffer 15 WORD_16B Register
//  0x1F0  32  CS23               Message Buffer 23 CS Register
//  0x1F0  32  MB5_64B_WORD0      Message Buffer 5 WORD_64B Register
//  0x1F0  32  MB9_32B_WORD0      Message Buffer 9 WORD_32B Register
//  0x1F4  32  ID23               Message Buffer 23 ID Register
//  0x1F4  32  MB15_16B_WORD1     Message Buffer 15 WORD_16B Register
//  0x1F4  32  MB23_8B_ID         Message Buffer 23 ID Register
//  0x1F4  32  MB5_64B_WORD1      Message Buffer 5 WORD_64B Register
//  0x1F4  32  MB9_32B_WORD1      Message Buffer 9 WORD_32B Register
//  0x1F8  32  MB15_16B_WORD2     Message Buffer 15 WORD_16B Register
//  0x1F8  32  MB23_8B_WORD0      Message Buffer 23 WORD_8B Register
//  0x1F8  32  MB5_64B_WORD2      Message Buffer 5 WORD_64B Register
//  0x1F8  32  MB9_32B_WORD2      Message Buffer 9 WORD_32B Register
//  0x1F8  32  WORD023            Message Buffer 23 WORD0 Register
//  0x1FC  32  MB15_16B_WORD3     Message Buffer 15 WORD_16B Register
//  0x1FC  32  MB23_8B_WORD1      Message Buffer 23 WORD_8B Register
//  0x1FC  32  MB5_64B_WORD3      Message Buffer 5 WORD_64B Register
//  0x1FC  32  MB9_32B_WORD3      Message Buffer 9 WORD_32B Register
//  0x1FC  32  WORD123            Message Buffer 23 WORD1 Register
//  0x200  32  CS24               Message Buffer 24 CS Register
//  0x200  32  MB16_16B_CS        Message Buffer 16 CS Register
//  0x200  32  MB24_8B_CS         Message Buffer 24 CS Register
//  0x200  32  MB5_64B_WORD4      Message Buffer 5 WORD_64B Register
//  0x200  32  MB9_32B_WORD4      Message Buffer 9 WORD_32B Register
//  0x204  32  ID24               Message Buffer 24 ID Register
//  0x204  32  MB16_16B_ID        Message Buffer 16 ID Register
//  0x204  32  MB24_8B_ID         Message Buffer 24 ID Register
//  0x204  32  MB5_64B_WORD5      Message Buffer 5 WORD_64B Register
//  0x204  32  MB9_32B_WORD5      Message Buffer 9 WORD_32B Register
//  0x208  32  MB16_16B_WORD0     Message Buffer 16 WORD_16B Register
//  0x208  32  MB24_8B_WORD0      Message Buffer 24 WORD_8B Register
//  0x208  32  MB5_64B_WORD6      Message Buffer 5 WORD_64B Register
//  0x208  32  MB9_32B_WORD6      Message Buffer 9 WORD_32B Register
//  0x208  32  WORD024            Message Buffer 24 WORD0 Register
//  0x20C  32  MB16_16B_WORD1     Message Buffer 16 WORD_16B Register
//  0x20C  32  MB24_8B_WORD1      Message Buffer 24 WORD_8B Register
//  0x20C  32  MB5_64B_WORD7      Message Buffer 5 WORD_64B Register
//  0x20C  32  MB9_32B_WORD7      Message Buffer 9 WORD_32B Register
//  0x20C  32  WORD124            Message Buffer 24 WORD1 Register
//  0x210  32  CS25               Message Buffer 25 CS Register
//  0x210  32  MB10_32B_CS        Message Buffer 10 CS Register
//  0x210  32  MB16_16B_WORD2     Message Buffer 16 WORD_16B Register
//  0x210  32  MB25_8B_CS         Message Buffer 25 CS Register
//  0x210  32  MB5_64B_WORD8      Message Buffer 5 WORD_64B Register
//  0x214  32  ID25               Message Buffer 25 ID Register
//  0x214  32  MB10_32B_ID        Message Buffer 10 ID Register
//  0x214  32  MB16_16B_WORD3     Message Buffer 16 WORD_16B Register
//  0x214  32  MB25_8B_ID         Message Buffer 25 ID Register
//  0x214  32  MB5_64B_WORD9      Message Buffer 5 WORD_64B Register
//  0x218  32  MB10_32B_WORD0     Message Buffer 10 WORD_32B Register
//  0x218  32  MB17_16B_CS        Message Buffer 17 CS Register
//  0x218  32  MB25_8B_WORD0      Message Buffer 25 WORD_8B Register
//  0x218  32  MB5_64B_WORD10     Message Buffer 5 WORD_64B Register
//  0x218  32  WORD025            Message Buffer 25 WORD0 Register
//  0x21C  32  MB10_32B_WORD1     Message Buffer 10 WORD_32B Register
//  0x21C  32  MB17_16B_ID        Message Buffer 17 ID Register
//  0x21C  32  MB25_8B_WORD1      Message Buffer 25 WORD_8B Register
//  0x21C  32  MB5_64B_WORD11     Message Buffer 5 WORD_64B Register
//  0x21C  32  WORD125            Message Buffer 25 WORD1 Register
//  0x220  32  CS26               Message Buffer 26 CS Register
//  0x220  32  MB10_32B_WORD2     Message Buffer 10 WORD_32B Register
//  0x220  32  MB17_16B_WORD0     Message Buffer 17 WORD_16B Register
//  0x220  32  MB26_8B_CS         Message Buffer 26 CS Register
//  0x220  32  MB5_64B_WORD12     Message Buffer 5 WORD_64B Register
//  0x224  32  ID26               Message Buffer 26 ID Register
//  0x224  32  MB10_32B_WORD3     Message Buffer 10 WORD_32B Register
//  0x224  32  MB17_16B_WORD1     Message Buffer 17 WORD_16B Register
//  0x224  32  MB26_8B_ID         Message Buffer 26 ID Register
//  0x224  32  MB5_64B_WORD13     Message Buffer 5 WORD_64B Register
//  0x228  32  MB10_32B_WORD4     Message Buffer 10 WORD_32B Register
//  0x228  32  MB17_16B_WORD2     Message Buffer 17 WORD_16B Register
//  0x228  32  MB26_8B_WORD0      Message Buffer 26 WORD_8B Register
//  0x228  32  MB5_64B_WORD14     Message Buffer 5 WORD_64B Register
//  0x228  32  WORD026            Message Buffer 26 WORD0 Register
//  0x22C  32  MB10_32B_WORD5     Message Buffer 10 WORD_32B Register
//  0x22C  32  MB17_16B_WORD3     Message Buffer 17 WORD_16B Register
//  0x22C  32  MB26_8B_WORD1      Message Buffer 26 WORD_8B Register
//  0x22C  32  MB5_64B_WORD15     Message Buffer 5 WORD_64B Register
//  0x22C  32  WORD126            Message Buffer 26 WORD1 Register
//  0x230  32  CS27               Message Buffer 27 CS Register
//  0x230  32  MB10_32B_WORD6     Message Buffer 10 WORD_32B Register
//  0x230  32  MB18_16B_CS        Message Buffer 18 CS Register
//  0x230  32  MB27_8B_CS         Message Buffer 27 CS Register
//  0x230  32  MB6_64B_CS         Message Buffer 6 CS Register
//  0x234  32  ID27               Message Buffer 27 ID Register
//  0x234  32  MB10_32B_WORD7     Message Buffer 10 WORD_32B Register
//  0x234  32  MB18_16B_ID        Message Buffer 18 ID Register
//  0x234  32  MB27_8B_ID         Message Buffer 27 ID Register
//  0x234  32  MB6_64B_ID         Message Buffer 6 ID Register
//  0x238  32  MB11_32B_CS        Message Buffer 11 CS Register
//  0x238  32  MB18_16B_WORD0     Message Buffer 18 WORD_16B Register
//  0x238  32  MB27_8B_WORD0      Message Buffer 27 WORD_8B Register
//  0x238  32  MB6_64B_WORD0      Message Buffer 6 WORD_64B Register
//  0x238  32  WORD027            Message Buffer 27 WORD0 Register
//  0x23C  32  MB11_32B_ID        Message Buffer 11 ID Register
//  0x23C  32  MB18_16B_WORD1     Message Buffer 18 WORD_16B Register
//  0x23C  32  MB27_8B_WORD1      Message Buffer 27 WORD_8B Register
//  0x23C  32  MB6_64B_WORD1      Message Buffer 6 WORD_64B Register
//  0x23C  32  WORD127            Message Buffer 27 WORD1 Register
//  0x240  32  MB18_16B_WORD2     Message Buffer 18 WORD_16B Register
//  0x240  32  MB11_32B_WORD0     Message Buffer 11 WORD_32B Register
//  0x240  32  CS28               Message Buffer 28 CS Register
//  0x240  32  MB28_8B_CS         Message Buffer 28 CS Register
//  0x240  32  MB6_64B_WORD2      Message Buffer 6 WORD_64B Register
//  0x244  32  ID28               Message Buffer 28 ID Register
//  0x244  32  MB11_32B_WORD1     Message Buffer 11 WORD_32B Register
//  0x244  32  MB18_16B_WORD3     Message Buffer 18 WORD_16B Register
//  0x244  32  MB6_64B_WORD3      Message Buffer 6 WORD_64B Register
//  0x244  32  MB28_8B_ID         Message Buffer 28 ID Register
//  0x248  32  MB11_32B_WORD2     Message Buffer 11 WORD_32B Register
//  0x248  32  MB19_16B_CS        Message Buffer 19 CS Register
//  0x248  32  MB28_8B_WORD0      Message Buffer 28 WORD_8B Register
//  0x248  32  MB6_64B_WORD4      Message Buffer 6 WORD_64B Register
//  0x248  32  WORD028            Message Buffer 28 WORD0 Register
//  0x24C  32  MB11_32B_WORD3     Message Buffer 11 WORD_32B Register
//  0x24C  32  MB19_16B_ID        Message Buffer 19 ID Register
//  0x24C  32  MB28_8B_WORD1      Message Buffer 28 WORD_8B Register
//  0x24C  32  MB6_64B_WORD5      Message Buffer 6 WORD_64B Register
//  0x24C  32  WORD128            Message Buffer 28 WORD1 Register
//  0x250  32  MB6_64B_WORD6      Message Buffer 6 WORD_64B Register
//  0x250  32  MB11_32B_WORD4     Message Buffer 11 WORD_32B Register
//  0x250  32  MB19_16B_WORD0     Message Buffer 19 WORD_16B Register
//  0x250  32  MB29_8B_CS         Message Buffer 29 CS Register
//  0x250  32  CS29               Message Buffer 29 CS Register
//  0x254  32  MB6_64B_WORD7      Message Buffer 6 WORD_64B Register
//  0x254  32  ID29               Message Buffer 29 ID Register
//  0x254  32  MB19_16B_WORD1     Message Buffer 19 WORD_16B Register
//  0x254  32  MB29_8B_ID         Message Buffer 29 ID Register
//  0x254  32  MB11_32B_WORD5     Message Buffer 11 WORD_32B Register
//  0x258  32  MB11_32B_WORD6     Message Buffer 11 WORD_32B Register
//  0x258  32  MB19_16B_WORD2     Message Buffer 19 WORD_16B Register
//  0x258  32  MB29_8B_WORD0      Message Buffer 29 WORD_8B Register
//  0x258  32  MB6_64B_WORD8      Message Buffer 6 WORD_64B Register
//  0x258  32  WORD029            Message Buffer 29 WORD0 Register
//  0x25C  32  MB11_32B_WORD7     Message Buffer 11 WORD_32B Register
//  0x25C  32  MB19_16B_WORD3     Message Buffer 19 WORD_16B Register
//  0x25C  32  MB29_8B_WORD1      Message Buffer 29 WORD_8B Register
//  0x25C  32  WORD129            Message Buffer 29 WORD1 Register
//  0x25C  32  MB6_64B_WORD9      Message Buffer 6 WORD_64B Register
//  0x260  32  CS30               Message Buffer 30 CS Register
//  0x260  32  MB12_32B_CS        Message Buffer 12 CS Register
//  0x260  32  MB20_16B_CS        Message Buffer 20 CS Register
//  0x260  32  MB30_8B_CS         Message Buffer 30 CS Register
//  0x260  32  MB6_64B_WORD10     Message Buffer 6 WORD_64B Register
//  0x264  32  ID30               Message Buffer 30 ID Register
//  0x264  32  MB12_32B_ID        Message Buffer 12 ID Register
//  0x264  32  MB20_16B_ID        Message Buffer 20 ID Register
//  0x264  32  MB30_8B_ID         Message Buffer 30 ID Register
//  0x264  32  MB6_64B_WORD11     Message Buffer 6 WORD_64B Register
//  0x268  32  MB6_64B_WORD12     Message Buffer 6 WORD_64B Register
//  0x268  32  MB20_16B_WORD0     Message Buffer 20 WORD_16B Register
//  0x268  32  MB30_8B_WORD0      Message Buffer 30 WORD_8B Register
//  0x268  32  WORD030            Message Buffer 30 WORD0 Register
//  0x268  32  MB12_32B_WORD0     Message Buffer 12 WORD_32B Register
//  0x26C  32  MB12_32B_WORD1     Message Buffer 12 WORD_32B Register
//  0x26C  32  MB20_16B_WORD1     Message Buffer 20 WORD_16B Register
//  0x26C  32  MB30_8B_WORD1      Message Buffer 30 WORD_8B Register
//  0x26C  32  MB6_64B_WORD13     Message Buffer 6 WORD_64B Register
//  0x26C  32  WORD130            Message Buffer 30 WORD1 Register
//  0x270  32  CS31               Message Buffer 31 CS Register
//  0x270  32  MB20_16B_WORD2     Message Buffer 20 WORD_16B Register
//  0x270  32  MB31_8B_CS         Message Buffer 31 CS Register
//  0x270  32  MB6_64B_WORD14     Message Buffer 6 WORD_64B Register
//  0x270  32  MB12_32B_WORD2     Message Buffer 12 WORD_32B Register
//  0x274  32  MB31_8B_ID         Message Buffer 31 ID Register
//  0x274  32  MB6_64B_WORD15     Message Buffer 6 WORD_64B Register
//  0x274  32  MB12_32B_WORD3     Message Buffer 12 WORD_32B Register
//  0x274  32  MB20_16B_WORD3     Message Buffer 20 WORD_16B Register
//  0x274  32  ID31               Message Buffer 31 ID Register
//  0x278  32  MB21_16B_CS        Message Buffer 21 CS Register
//  0x278  32  MB31_8B_WORD0      Message Buffer 31 WORD_8B Register
//  0x278  32  MB7_64B_CS         Message Buffer 7 CS Register
//  0x278  32  WORD031            Message Buffer 31 WORD0 Register
//  0x278  32  MB12_32B_WORD4     Message Buffer 12 WORD_32B Register
//  0x27C  32  WORD131            Message Buffer 31 WORD1 Register
//  0x27C  32  MB12_32B_WORD5     Message Buffer 12 WORD_32B Register
//  0x27C  32  MB21_16B_ID        Message Buffer 21 ID Register
//  0x27C  32  MB7_64B_ID         Message Buffer 7 ID Register
//  0x27C  32  MB31_8B_WORD1      Message Buffer 31 WORD_8B Register
//  0x280  32  CS32               Message Buffer 32 CS Register
//  0x280  32  MB12_32B_WORD6     Message Buffer 12 WORD_32B Register
//  0x280  32  MB21_16B_WORD0     Message Buffer 21 WORD_16B Register
//  0x280  32  MB32_8B_CS         Message Buffer 32 CS Register
//  0x280  32  MB7_64B_WORD0      Message Buffer 7 WORD_64B Register
//  0x284  32  MB7_64B_WORD1      Message Buffer 7 WORD_64B Register
//  0x284  32  ID32               Message Buffer 32 ID Register
//  0x284  32  MB21_16B_WORD1     Message Buffer 21 WORD_16B Register
//  0x284  32  MB32_8B_ID         Message Buffer 32 ID Register
//  0x284  32  MB12_32B_WORD7     Message Buffer 12 WORD_32B Register
//  0x288  32  MB13_32B_CS        Message Buffer 13 CS Register
//  0x288  32  MB21_16B_WORD2     Message Buffer 21 WORD_16B Register
//  0x288  32  MB32_8B_WORD0      Message Buffer 32 WORD_8B Register
//  0x288  32  MB7_64B_WORD2      Message Buffer 7 WORD_64B Register
//  0x288  32  WORD032            Message Buffer 32 WORD0 Register
//  0x28C  32  MB13_32B_ID        Message Buffer 13 ID Register
//  0x28C  32  MB21_16B_WORD3     Message Buffer 21 WORD_16B Register
//  0x28C  32  MB32_8B_WORD1      Message Buffer 32 WORD_8B Register
//  0x28C  32  MB7_64B_WORD3      Message Buffer 7 WORD_64B Register
//  0x28C  32  WORD132            Message Buffer 32 WORD1 Register
//  0x290  32  MB7_64B_WORD4      Message Buffer 7 WORD_64B Register
//  0x290  32  MB13_32B_WORD0     Message Buffer 13 WORD_32B Register
//  0x290  32  CS33               Message Buffer 33 CS Register
//  0x290  32  MB33_8B_CS         Message Buffer 33 CS Register
//  0x290  32  MB22_16B_CS        Message Buffer 22 CS Register
//  0x294  32  ID33               Message Buffer 33 ID Register
//  0x294  32  MB13_32B_WORD1     Message Buffer 13 WORD_32B Register
//  0x294  32  MB22_16B_ID        Message Buffer 22 ID Register
//  0x294  32  MB33_8B_ID         Message Buffer 33 ID Register
//  0x294  32  MB7_64B_WORD5      Message Buffer 7 WORD_64B Register
//  0x298  32  MB33_8B_WORD0      Message Buffer 33 WORD_8B Register
//  0x298  32  MB22_16B_WORD0     Message Buffer 22 WORD_16B Register
//  0x298  32  MB13_32B_WORD2     Message Buffer 13 WORD_32B Register
//  0x298  32  MB7_64B_WORD6      Message Buffer 7 WORD_64B Register
//  0x298  32  WORD033            Message Buffer 33 WORD0 Register
//  0x29C  32  MB13_32B_WORD3     Message Buffer 13 WORD_32B Register
//  0x29C  32  MB22_16B_WORD1     Message Buffer 22 WORD_16B Register
//  0x29C  32  MB33_8B_WORD1      Message Buffer 33 WORD_8B Register
//  0x29C  32  MB7_64B_WORD7      Message Buffer 7 WORD_64B Register
//  0x29C  32  WORD133            Message Buffer 33 WORD1 Register
//  0x2A0  32  MB13_32B_WORD4     Message Buffer 13 WORD_32B Register
//  0x2A0  32  MB22_16B_WORD2     Message Buffer 22 WORD_16B Register
//  0x2A0  32  MB34_8B_CS         Message Buffer 34 CS Register
//  0x2A0  32  MB7_64B_WORD8      Message Buffer 7 WORD_64B Register
//  0x2A0  32  CS34               Message Buffer 34 CS Register
//  0x2A4  32  MB34_8B_ID         Message Buffer 34 ID Register
//  0x2A4  32  MB7_64B_WORD9      Message Buffer 7 WORD_64B Register
//  0x2A4  32  MB13_32B_WORD5     Message Buffer 13 WORD_32B Register
//  0x2A4  32  MB22_16B_WORD3     Message Buffer 22 WORD_16B Register
//  0x2A4  32  ID34               Message Buffer 34 ID Register
//  0x2A8  32  MB7_64B_WORD10     Message Buffer 7 WORD_64B Register
//  0x2A8  32  WORD034            Message Buffer 34 WORD0 Register
//  0x2A8  32  MB23_16B_CS        Message Buffer 23 CS Register
//  0x2A8  32  MB34_8B_WORD0      Message Buffer 34 WORD_8B Register
//  0x2A8  32  MB13_32B_WORD6     Message Buffer 13 WORD_32B Register
//  0x2AC  32  MB13_32B_WORD7     Message Buffer 13 WORD_32B Register
//  0x2AC  32  MB23_16B_ID        Message Buffer 23 ID Register
//  0x2AC  32  MB34_8B_WORD1      Message Buffer 34 WORD_8B Register
//  0x2AC  32  MB7_64B_WORD11     Message Buffer 7 WORD_64B Register
//  0x2AC  32  WORD134            Message Buffer 34 WORD1 Register
//  0x2B0  32  CS35               Message Buffer 35 CS Register
//  0x2B0  32  MB14_32B_CS        Message Buffer 14 CS Register
//  0x2B0  32  MB23_16B_WORD0     Message Buffer 23 WORD_16B Register
//  0x2B0  32  MB35_8B_CS         Message Buffer 35 CS Register
//  0x2B0  32  MB7_64B_WORD12     Message Buffer 7 WORD_64B Register
//  0x2B4  32  MB7_64B_WORD13     Message Buffer 7 WORD_64B Register
//  0x2B4  32  ID35               Message Buffer 35 ID Register
//  0x2B4  32  MB14_32B_ID        Message Buffer 14 ID Register
//  0x2B4  32  MB35_8B_ID         Message Buffer 35 ID Register
//  0x2B4  32  MB23_16B_WORD1     Message Buffer 23 WORD_16B Register
//  0x2B8  32  MB14_32B_WORD0     Message Buffer 14 WORD_32B Register
//  0x2B8  32  MB23_16B_WORD2     Message Buffer 23 WORD_16B Register
//  0x2B8  32  MB35_8B_WORD0      Message Buffer 35 WORD_8B Register
//  0x2B8  32  MB7_64B_WORD14     Message Buffer 7 WORD_64B Register
//  0x2B8  32  WORD035            Message Buffer 35 WORD0 Register
//  0x2BC  32  MB14_32B_WORD1     Message Buffer 14 WORD_32B Register
//  0x2BC  32  MB23_16B_WORD3     Message Buffer 23 WORD_16B Register
//  0x2BC  32  MB35_8B_WORD1      Message Buffer 35 WORD_8B Register
//  0x2BC  32  MB7_64B_WORD15     Message Buffer 7 WORD_64B Register
//  0x2BC  32  WORD135            Message Buffer 35 WORD1 Register
//  0x2C0  32  CS36               Message Buffer 36 CS Register
//  0x2C0  32  MB14_32B_WORD2     Message Buffer 14 WORD_32B Register
//  0x2C0  32  MB24_16B_CS        Message Buffer 24 CS Register
//  0x2C0  32  MB36_8B_CS         Message Buffer 36 CS Register
//  0x2C0  32  MB8_64B_CS         Message Buffer 8 CS Register
//  0x2C4  32  ID36               Message Buffer 36 ID Register
//  0x2C4  32  MB14_32B_WORD3     Message Buffer 14 WORD_32B Register
//  0x2C4  32  MB24_16B_ID        Message Buffer 24 ID Register
//  0x2C4  32  MB36_8B_ID         Message Buffer 36 ID Register
//  0x2C4  32  MB8_64B_ID         Message Buffer 8 ID Register
//  0x2C8  32  WORD036            Message Buffer 36 WORD0 Register
//  0x2C8  32  MB24_16B_WORD0     Message Buffer 24 WORD_16B Register
//  0x2C8  32  MB14_32B_WORD4     Message Buffer 14 WORD_32B Register
//  0x2C8  32  MB8_64B_WORD0      Message Buffer 8 WORD_64B Register
//  0x2C8  32  MB36_8B_WORD0      Message Buffer 36 WORD_8B Register
//  0x2CC  32  MB14_32B_WORD5     Message Buffer 14 WORD_32B Register
//  0x2CC  32  MB24_16B_WORD1     Message Buffer 24 WORD_16B Register
//  0x2CC  32  MB36_8B_WORD1      Message Buffer 36 WORD_8B Register
//  0x2CC  32  MB8_64B_WORD1      Message Buffer 8 WORD_64B Register
//  0x2CC  32  WORD136            Message Buffer 36 WORD1 Register
//  0x2D0  32  CS37               Message Buffer 37 CS Register
//  0x2D0  32  MB14_32B_WORD6     Message Buffer 14 WORD_32B Register
//  0x2D0  32  MB8_64B_WORD2      Message Buffer 8 WORD_64B Register
//  0x2D0  32  MB37_8B_CS         Message Buffer 37 CS Register
//  0x2D0  32  MB24_16B_WORD2     Message Buffer 24 WORD_16B Register
//  0x2D4  32  MB14_32B_WORD7     Message Buffer 14 WORD_32B Register
//  0x2D4  32  MB24_16B_WORD3     Message Buffer 24 WORD_16B Register
//  0x2D4  32  MB37_8B_ID         Message Buffer 37 ID Register
//  0x2D4  32  MB8_64B_WORD3      Message Buffer 8 WORD_64B Register
//  0x2D4  32  ID37               Message Buffer 37 ID Register
//  0x2D8  32  MB15_32B_CS        Message Buffer 15 CS Register
//  0x2D8  32  MB25_16B_CS        Message Buffer 25 CS Register
//  0x2D8  32  MB37_8B_WORD0      Message Buffer 37 WORD_8B Register
//  0x2D8  32  MB8_64B_WORD4      Message Buffer 8 WORD_64B Register
//  0x2D8  32  WORD037            Message Buffer 37 WORD0 Register
//  0x2DC  32  WORD137            Message Buffer 37 WORD1 Register
//  0x2DC  32  MB25_16B_ID        Message Buffer 25 ID Register
//  0x2DC  32  MB15_32B_ID        Message Buffer 15 ID Register
//  0x2DC  32  MB8_64B_WORD5      Message Buffer 8 WORD_64B Register
//  0x2DC  32  MB37_8B_WORD1      Message Buffer 37 WORD_8B Register
//  0x2E0  32  CS38               Message Buffer 38 CS Register
//  0x2E0  32  MB15_32B_WORD0     Message Buffer 15 WORD_32B Register
//  0x2E0  32  MB25_16B_WORD0     Message Buffer 25 WORD_16B Register
//  0x2E0  32  MB38_8B_CS         Message Buffer 38 CS Register
//  0x2E0  32  MB8_64B_WORD6      Message Buffer 8 WORD_64B Register
//  0x2E4  32  ID38               Message Buffer 38 ID Register
//  0x2E4  32  MB8_64B_WORD7      Message Buffer 8 WORD_64B Register
//  0x2E4  32  MB15_32B_WORD1     Message Buffer 15 WORD_32B Register
//  0x2E4  32  MB38_8B_ID         Message Buffer 38 ID Register
//  0x2E4  32  MB25_16B_WORD1     Message Buffer 25 WORD_16B Register
//  0x2E8  32  MB15_32B_WORD2     Message Buffer 15 WORD_32B Register
//  0x2E8  32  MB25_16B_WORD2     Message Buffer 25 WORD_16B Register
//  0x2E8  32  MB38_8B_WORD0      Message Buffer 38 WORD_8B Register
//  0x2E8  32  MB8_64B_WORD8      Message Buffer 8 WORD_64B Register
//  0x2E8  32  WORD038            Message Buffer 38 WORD0 Register
//  0x2EC  32  MB15_32B_WORD3     Message Buffer 15 WORD_32B Register
//  0x2EC  32  MB25_16B_WORD3     Message Buffer 25 WORD_16B Register
//  0x2EC  32  MB38_8B_WORD1      Message Buffer 38 WORD_8B Register
//  0x2EC  32  WORD138            Message Buffer 38 WORD1 Register
//  0x2EC  32  MB8_64B_WORD9      Message Buffer 8 WORD_64B Register
//  0x2F0  32  MB39_8B_CS         Message Buffer 39 CS Register
//  0x2F0  32  CS39               Message Buffer 39 CS Register
//  0x2F0  32  MB15_32B_WORD4     Message Buffer 15 WORD_32B Register
//  0x2F0  32  MB8_64B_WORD10     Message Buffer 8 WORD_64B Register
//  0x2F0  32  MB26_16B_CS        Message Buffer 26 CS Register
//  0x2F4  32  MB39_8B_ID         Message Buffer 39 ID Register
//  0x2F4  32  ID39               Message Buffer 39 ID Register
//  0x2F4  32  MB15_32B_WORD5     Message Buffer 15 WORD_32B Register
//  0x2F4  32  MB26_16B_ID        Message Buffer 26 ID Register
//  0x2F4  32  MB8_64B_WORD11     Message Buffer 8 WORD_64B Register
//  0x2F8  32  MB15_32B_WORD6     Message Buffer 15 WORD_32B Register
//  0x2F8  32  MB26_16B_WORD0     Message Buffer 26 WORD_16B Register
//  0x2F8  32  MB39_8B_WORD0      Message Buffer 39 WORD_8B Register
//  0x2F8  32  MB8_64B_WORD12     Message Buffer 8 WORD_64B Register
//  0x2F8  32  WORD039            Message Buffer 39 WORD0 Register
//  0x2FC  32  MB15_32B_WORD7     Message Buffer 15 WORD_32B Register
//  0x2FC  32  MB26_16B_WORD1     Message Buffer 26 WORD_16B Register
//  0x2FC  32  MB39_8B_WORD1      Message Buffer 39 WORD_8B Register
//  0x2FC  32  MB8_64B_WORD13     Message Buffer 8 WORD_64B Register
//  0x2FC  32  WORD139            Message Buffer 39 WORD1 Register
//  0x300  32  CS40               Message Buffer 40 CS Register
//  0x300  32  MB16_32B_CS        Message Buffer 16 CS Register
//  0x300  32  MB26_16B_WORD2     Message Buffer 26 WORD_16B Register
//  0x300  32  MB40_8B_CS         Message Buffer 40 CS Register
//  0x300  32  MB8_64B_WORD14     Message Buffer 8 WORD_64B Register
//  0x304  32  ID40               Message Buffer 40 ID Register
//  0x304  32  MB16_32B_ID        Message Buffer 16 ID Register
//  0x304  32  MB26_16B_WORD3     Message Buffer 26 WORD_16B Register
//  0x304  32  MB40_8B_ID         Message Buffer 40 ID Register
//  0x304  32  MB8_64B_WORD15     Message Buffer 8 WORD_64B Register
//  0x308  32  MB16_32B_WORD0     Message Buffer 16 WORD_32B Register
//  0x308  32  MB27_16B_CS        Message Buffer 27 CS Register
//  0x308  32  MB40_8B_WORD0      Message Buffer 40 WORD_8B Register
//  0x308  32  MB9_64B_CS         Message Buffer 9 CS Register
//  0x308  32  WORD040            Message Buffer 40 WORD0 Register
//  0x30C  32  MB16_32B_WORD1     Message Buffer 16 WORD_32B Register
//  0x30C  32  MB27_16B_ID        Message Buffer 27 ID Register
//  0x30C  32  MB40_8B_WORD1      Message Buffer 40 WORD_8B Register
//  0x30C  32  MB9_64B_ID         Message Buffer 9 ID Register
//  0x30C  32  WORD140            Message Buffer 40 WORD1 Register
//  0x310  32  CS41               Message Buffer 41 CS Register
//  0x310  32  MB16_32B_WORD2     Message Buffer 16 WORD_32B Register
//  0x310  32  MB27_16B_WORD0     Message Buffer 27 WORD_16B Register
//  0x310  32  MB41_8B_CS         Message Buffer 41 CS Register
//  0x310  32  MB9_64B_WORD0      Message Buffer 9 WORD_64B Register
//  0x314  32  ID41               Message Buffer 41 ID Register
//  0x314  32  MB16_32B_WORD3     Message Buffer 16 WORD_32B Register
//  0x314  32  MB27_16B_WORD1     Message Buffer 27 WORD_16B Register
//  0x314  32  MB41_8B_ID         Message Buffer 41 ID Register
//  0x314  32  MB9_64B_WORD1      Message Buffer 9 WORD_64B Register
//  0x318  32  MB16_32B_WORD4     Message Buffer 16 WORD_32B Register
//  0x318  32  MB27_16B_WORD2     Message Buffer 27 WORD_16B Register
//  0x318  32  MB41_8B_WORD0      Message Buffer 41 WORD_8B Register
//  0x318  32  MB9_64B_WORD2      Message Buffer 9 WORD_64B Register
//  0x318  32  WORD041            Message Buffer 41 WORD0 Register
//  0x31C  32  MB16_32B_WORD5     Message Buffer 16 WORD_32B Register
//  0x31C  32  MB27_16B_WORD3     Message Buffer 27 WORD_16B Register
//  0x31C  32  MB41_8B_WORD1      Message Buffer 41 WORD_8B Register
//  0x31C  32  MB9_64B_WORD3      Message Buffer 9 WORD_64B Register
//  0x31C  32  WORD141            Message Buffer 41 WORD1 Register
//  0x320  32  CS42               Message Buffer 42 CS Register
//  0x320  32  MB16_32B_WORD6     Message Buffer 16 WORD_32B Register
//  0x320  32  MB28_16B_CS        Message Buffer 28 CS Register
//  0x320  32  MB42_8B_CS         Message Buffer 42 CS Register
//  0x320  32  MB9_64B_WORD4      Message Buffer 9 WORD_64B Register
//  0x324  32  ID42               Message Buffer 42 ID Register
//  0x324  32  MB16_32B_WORD7     Message Buffer 16 WORD_32B Register
//  0x324  32  MB28_16B_ID        Message Buffer 28 ID Register
//  0x324  32  MB42_8B_ID         Message Buffer 42 ID Register
//  0x324  32  MB9_64B_WORD5      Message Buffer 9 WORD_64B Register
//  0x328  32  MB17_32B_CS        Message Buffer 17 CS Register
//  0x328  32  MB28_16B_WORD0     Message Buffer 28 WORD_16B Register
//  0x328  32  MB42_8B_WORD0      Message Buffer 42 WORD_8B Register
//  0x328  32  MB9_64B_WORD6      Message Buffer 9 WORD_64B Register
//  0x328  32  WORD042            Message Buffer 42 WORD0 Register
//  0x32C  32  MB17_32B_ID        Message Buffer 17 ID Register
//  0x32C  32  MB28_16B_WORD1     Message Buffer 28 WORD_16B Register
//  0x32C  32  MB42_8B_WORD1      Message Buffer 42 WORD_8B Register
//  0x32C  32  MB9_64B_WORD7      Message Buffer 9 WORD_64B Register
//  0x32C  32  WORD142            Message Buffer 42 WORD1 Register
//  0x330  32  CS43               Message Buffer 43 CS Register
//  0x330  32  MB17_32B_WORD0     Message Buffer 17 WORD_32B Register
//  0x330  32  MB28_16B_WORD2     Message Buffer 28 WORD_16B Register
//  0x330  32  MB43_8B_CS         Message Buffer 43 CS Register
//  0x330  32  MB9_64B_WORD8      Message Buffer 9 WORD_64B Register
//  0x334  32  ID43               Message Buffer 43 ID Register
//  0x334  32  MB17_32B_WORD1     Message Buffer 17 WORD_32B Register
//  0x334  32  MB28_16B_WORD3     Message Buffer 28 WORD_16B Register
//  0x334  32  MB43_8B_ID         Message Buffer 43 ID Register
//  0x334  32  MB9_64B_WORD9      Message Buffer 9 WORD_64B Register
//  0x338  32  MB29_16B_CS        Message Buffer 29 CS Register
//  0x338  32  MB43_8B_WORD0      Message Buffer 43 WORD_8B Register
//  0x338  32  MB9_64B_WORD10     Message Buffer 9 WORD_64B Register
//  0x338  32  WORD043            Message Buffer 43 WORD0 Register
//  0x338  32  MB17_32B_WORD2     Message Buffer 17 WORD_32B Register
//  0x33C  32  WORD143            Message Buffer 43 WORD1 Register
//  0x33C  32  MB17_32B_WORD3     Message Buffer 17 WORD_32B Register
//  0x33C  32  MB29_16B_ID        Message Buffer 29 ID Register
//  0x33C  32  MB9_64B_WORD11     Message Buffer 9 WORD_64B Register
//  0x33C  32  MB43_8B_WORD1      Message Buffer 43 WORD_8B Register
//  0x340  32  CS44               Message Buffer 44 CS Register
//  0x340  32  MB17_32B_WORD4     Message Buffer 17 WORD_32B Register
//  0x340  32  MB29_16B_WORD0     Message Buffer 29 WORD_16B Register
//  0x340  32  MB44_8B_CS         Message Buffer 44 CS Register
//  0x340  32  MB9_64B_WORD12     Message Buffer 9 WORD_64B Register
//  0x344  32  MB9_64B_WORD13     Message Buffer 9 WORD_64B Register
//  0x344  32  MB17_32B_WORD5     Message Buffer 17 WORD_32B Register
//  0x344  32  MB29_16B_WORD1     Message Buffer 29 WORD_16B Register
//  0x344  32  MB44_8B_ID         Message Buffer 44 ID Register
//  0x344  32  ID44               Message Buffer 44 ID Register
//  0x348  32  MB17_32B_WORD6     Message Buffer 17 WORD_32B Register
//  0x348  32  MB29_16B_WORD2     Message Buffer 29 WORD_16B Register
//  0x348  32  MB44_8B_WORD0      Message Buffer 44 WORD_8B Register
//  0x348  32  MB9_64B_WORD14     Message Buffer 9 WORD_64B Register
//  0x348  32  WORD044            Message Buffer 44 WORD0 Register
//  0x34C  32  MB17_32B_WORD7     Message Buffer 17 WORD_32B Register
//  0x34C  32  MB29_16B_WORD3     Message Buffer 29 WORD_16B Register
//  0x34C  32  MB44_8B_WORD1      Message Buffer 44 WORD_8B Register
//  0x34C  32  MB9_64B_WORD15     Message Buffer 9 WORD_64B Register
//  0x34C  32  WORD144            Message Buffer 44 WORD1 Register
//  0x350  32  MB45_8B_CS         Message Buffer 45 CS Register
//  0x350  32  MB10_64B_CS        Message Buffer 10 CS Register
//  0x350  32  MB18_32B_CS        Message Buffer 18 CS Register
//  0x350  32  MB30_16B_CS        Message Buffer 30 CS Register
//  0x350  32  CS45               Message Buffer 45 CS Register
//  0x354  32  MB45_8B_ID         Message Buffer 45 ID Register
//  0x354  32  MB10_64B_ID        Message Buffer 10 ID Register
//  0x354  32  MB18_32B_ID        Message Buffer 18 ID Register
//  0x354  32  MB30_16B_ID        Message Buffer 30 ID Register
//  0x354  32  ID45               Message Buffer 45 ID Register
//  0x358  32  MB10_64B_WORD0     Message Buffer 10 WORD_64B Register
//  0x358  32  MB18_32B_WORD0     Message Buffer 18 WORD_32B Register
//  0x358  32  MB30_16B_WORD0     Message Buffer 30 WORD_16B Register
//  0x358  32  MB45_8B_WORD0      Message Buffer 45 WORD_8B Register
//  0x358  32  WORD045            Message Buffer 45 WORD0 Register
//  0x35C  32  WORD145            Message Buffer 45 WORD1 Register
//  0x35C  32  MB18_32B_WORD1     Message Buffer 18 WORD_32B Register
//  0x35C  32  MB10_64B_WORD1     Message Buffer 10 WORD_64B Register
//  0x35C  32  MB45_8B_WORD1      Message Buffer 45 WORD_8B Register
//  0x35C  32  MB30_16B_WORD1     Message Buffer 30 WORD_16B Register
//  0x360  32  CS46               Message Buffer 46 CS Register
//  0x360  32  MB10_64B_WORD2     Message Buffer 10 WORD_64B Register
//  0x360  32  MB18_32B_WORD2     Message Buffer 18 WORD_32B Register
//  0x360  32  MB30_16B_WORD2     Message Buffer 30 WORD_16B Register
//  0x360  32  MB46_8B_CS         Message Buffer 46 CS Register
//  0x364  32  ID46               Message Buffer 46 ID Register
//  0x364  32  MB10_64B_WORD3     Message Buffer 10 WORD_64B Register
//  0x364  32  MB46_8B_ID         Message Buffer 46 ID Register
//  0x364  32  MB30_16B_WORD3     Message Buffer 30 WORD_16B Register
//  0x364  32  MB18_32B_WORD3     Message Buffer 18 WORD_32B Register
//  0x368  32  MB18_32B_WORD4     Message Buffer 18 WORD_32B Register
//  0x368  32  MB31_16B_CS        Message Buffer 31 CS Register
//  0x368  32  MB46_8B_WORD0      Message Buffer 46 WORD_8B Register
//  0x368  32  WORD046            Message Buffer 46 WORD0 Register
//  0x368  32  MB10_64B_WORD4     Message Buffer 10 WORD_64B Register
//  0x36C  32  WORD146            Message Buffer 46 WORD1 Register
//  0x36C  32  MB10_64B_WORD5     Message Buffer 10 WORD_64B Register
//  0x36C  32  MB18_32B_WORD5     Message Buffer 18 WORD_32B Register
//  0x36C  32  MB31_16B_ID        Message Buffer 31 ID Register
//  0x36C  32  MB46_8B_WORD1      Message Buffer 46 WORD_8B Register
//  0x370  32  CS47               Message Buffer 47 CS Register
//  0x370  32  MB10_64B_WORD6     Message Buffer 10 WORD_64B Register
//  0x370  32  MB18_32B_WORD6     Message Buffer 18 WORD_32B Register
//  0x370  32  MB31_16B_WORD0     Message Buffer 31 WORD_16B Register
//  0x370  32  MB47_8B_CS         Message Buffer 47 CS Register
//  0x374  32  ID47               Message Buffer 47 ID Register
//  0x374  32  MB10_64B_WORD7     Message Buffer 10 WORD_64B Register
//  0x374  32  MB18_32B_WORD7     Message Buffer 18 WORD_32B Register
//  0x374  32  MB31_16B_WORD1     Message Buffer 31 WORD_16B Register
//  0x374  32  MB47_8B_ID         Message Buffer 47 ID Register
//  0x378  32  MB19_32B_CS        Message Buffer 19 CS Register
//  0x378  32  MB31_16B_WORD2     Message Buffer 31 WORD_16B Register
//  0x378  32  MB47_8B_WORD0      Message Buffer 47 WORD_8B Register
//  0x378  32  WORD047            Message Buffer 47 WORD0 Register
//  0x378  32  MB10_64B_WORD8     Message Buffer 10 WORD_64B Register
//  0x37C  32  WORD147            Message Buffer 47 WORD1 Register
//  0x37C  32  MB10_64B_WORD9     Message Buffer 10 WORD_64B Register
//  0x37C  32  MB19_32B_ID        Message Buffer 19 ID Register
//  0x37C  32  MB47_8B_WORD1      Message Buffer 47 WORD_8B Register
//  0x37C  32  MB31_16B_WORD3     Message Buffer 31 WORD_16B Register
//  0x380  32  CS48               Message Buffer 48 CS Register
//  0x380  32  MB10_64B_WORD10    Message Buffer 10 WORD_64B Register
//  0x380  32  MB19_32B_WORD0     Message Buffer 19 WORD_32B Register
//  0x380  32  MB32_16B_CS        Message Buffer 32 CS Register
//  0x380  32  MB48_8B_CS         Message Buffer 48 CS Register
//  0x384  32  MB48_8B_ID         Message Buffer 48 ID Register
//  0x384  32  MB10_64B_WORD11    Message Buffer 10 WORD_64B Register
//  0x384  32  MB19_32B_WORD1     Message Buffer 19 WORD_32B Register
//  0x384  32  MB32_16B_ID        Message Buffer 32 ID Register
//  0x384  32  ID48               Message Buffer 48 ID Register
//  0x388  32  MB10_64B_WORD12    Message Buffer 10 WORD_64B Register
//  0x388  32  MB19_32B_WORD2     Message Buffer 19 WORD_32B Register
//  0x388  32  MB32_16B_WORD0     Message Buffer 32 WORD_16B Register
//  0x388  32  MB48_8B_WORD0      Message Buffer 48 WORD_8B Register
//  0x388  32  WORD048            Message Buffer 48 WORD0 Register
//  0x38C  32  MB10_64B_WORD13    Message Buffer 10 WORD_64B Register
//  0x38C  32  MB19_32B_WORD3     Message Buffer 19 WORD_32B Register
//  0x38C  32  MB32_16B_WORD1     Message Buffer 32 WORD_16B Register
//  0x38C  32  MB48_8B_WORD1      Message Buffer 48 WORD_8B Register
//  0x38C  32  WORD148            Message Buffer 48 WORD1 Register
//  0x390  32  MB49_8B_CS         Message Buffer 49 CS Register
//  0x390  32  MB10_64B_WORD14    Message Buffer 10 WORD_64B Register
//  0x390  32  MB19_32B_WORD4     Message Buffer 19 WORD_32B Register
//  0x390  32  MB32_16B_WORD2     Message Buffer 32 WORD_16B Register
//  0x390  32  CS49               Message Buffer 49 CS Register
//  0x394  32  MB10_64B_WORD15    Message Buffer 10 WORD_64B Register
//  0x394  32  MB19_32B_WORD5     Message Buffer 19 WORD_32B Register
//  0x394  32  MB32_16B_WORD3     Message Buffer 32 WORD_16B Register
//  0x394  32  MB49_8B_ID         Message Buffer 49 ID Register
//  0x394  32  ID49               Message Buffer 49 ID Register
//  0x398  32  MB11_64B_CS        Message Buffer 11 CS Register
//  0x398  32  MB19_32B_WORD6     Message Buffer 19 WORD_32B Register
//  0x398  32  MB33_16B_CS        Message Buffer 33 CS Register
//  0x398  32  MB49_8B_WORD0      Message Buffer 49 WORD_8B Register
//  0x398  32  WORD049            Message Buffer 49 WORD0 Register
//  0x39C  32  WORD149            Message Buffer 49 WORD1 Register
//  0x39C  32  MB19_32B_WORD7     Message Buffer 19 WORD_32B Register
//  0x39C  32  MB33_16B_ID        Message Buffer 33 ID Register
//  0x39C  32  MB49_8B_WORD1      Message Buffer 49 WORD_8B Register
//  0x39C  32  MB11_64B_ID        Message Buffer 11 ID Register
//  0x3A0  32  CS50               Message Buffer 50 CS Register
//  0x3A0  32  MB11_64B_WORD0     Message Buffer 11 WORD_64B Register
//  0x3A0  32  MB20_32B_CS        Message Buffer 20 CS Register
//  0x3A0  32  MB33_16B_WORD0     Message Buffer 33 WORD_16B Register
//  0x3A0  32  MB50_8B_CS         Message Buffer 50 CS Register
//  0x3A4  32  MB50_8B_ID         Message Buffer 50 ID Register
//  0x3A4  32  MB11_64B_WORD1     Message Buffer 11 WORD_64B Register
//  0x3A4  32  ID50               Message Buffer 50 ID Register
//  0x3A4  32  MB33_16B_WORD1     Message Buffer 33 WORD_16B Register
//  0x3A4  32  MB20_32B_ID        Message Buffer 20 ID Register
//  0x3A8  32  MB11_64B_WORD2     Message Buffer 11 WORD_64B Register
//  0x3A8  32  MB20_32B_WORD0     Message Buffer 20 WORD_32B Register
//  0x3A8  32  MB33_16B_WORD2     Message Buffer 33 WORD_16B Register
//  0x3A8  32  MB50_8B_WORD0      Message Buffer 50 WORD_8B Register
//  0x3A8  32  WORD050            Message Buffer 50 WORD0 Register
//  0x3AC  32  MB11_64B_WORD3     Message Buffer 11 WORD_64B Register
//  0x3AC  32  MB20_32B_WORD1     Message Buffer 20 WORD_32B Register
//  0x3AC  32  MB33_16B_WORD3     Message Buffer 33 WORD_16B Register
//  0x3AC  32  WORD150            Message Buffer 50 WORD1 Register
//  0x3AC  32  MB50_8B_WORD1      Message Buffer 50 WORD_8B Register
//  0x3B0  32  CS51               Message Buffer 51 CS Register
//  0x3B0  32  MB11_64B_WORD4     Message Buffer 11 WORD_64B Register
//  0x3B0  32  MB20_32B_WORD2     Message Buffer 20 WORD_32B Register
//  0x3B0  32  MB34_16B_CS        Message Buffer 34 CS Register
//  0x3B0  32  MB51_8B_CS         Message Buffer 51 CS Register
//  0x3B4  32  ID51               Message Buffer 51 ID Register
//  0x3B4  32  MB11_64B_WORD5     Message Buffer 11 WORD_64B Register
//  0x3B4  32  MB20_32B_WORD3     Message Buffer 20 WORD_32B Register
//  0x3B4  32  MB34_16B_ID        Message Buffer 34 ID Register
//  0x3B4  32  MB51_8B_ID         Message Buffer 51 ID Register
//  0x3B8  32  MB11_64B_WORD6     Message Buffer 11 WORD_64B Register
//  0x3B8  32  MB20_32B_WORD4     Message Buffer 20 WORD_32B Register
//  0x3B8  32  MB34_16B_WORD0     Message Buffer 34 WORD_16B Register
//  0x3B8  32  MB51_8B_WORD0      Message Buffer 51 WORD_8B Register
//  0x3B8  32  WORD051            Message Buffer 51 WORD0 Register
//  0x3BC  32  MB11_64B_WORD7     Message Buffer 11 WORD_64B Register
//  0x3BC  32  MB20_32B_WORD5     Message Buffer 20 WORD_32B Register
//  0x3BC  32  MB34_16B_WORD1     Message Buffer 34 WORD_16B Register
//  0x3BC  32  MB51_8B_WORD1      Message Buffer 51 WORD_8B Register
//  0x3BC  32  WORD151            Message Buffer 51 WORD1 Register
//  0x3C0  32  CS52               Message Buffer 52 CS Register
//  0x3C0  32  MB11_64B_WORD8     Message Buffer 11 WORD_64B Register
//  0x3C0  32  MB20_32B_WORD6     Message Buffer 20 WORD_32B Register
//  0x3C0  32  MB34_16B_WORD2     Message Buffer 34 WORD_16B Register
//  0x3C0  32  MB52_8B_CS         Message Buffer 52 CS Register
//  0x3C4  32  ID52               Message Buffer 52 ID Register
//  0x3C4  32  MB11_64B_WORD9     Message Buffer 11 WORD_64B Register
//  0x3C4  32  MB20_32B_WORD7     Message Buffer 20 WORD_32B Register
//  0x3C4  32  MB34_16B_WORD3     Message Buffer 34 WORD_16B Register
//  0x3C4  32  MB52_8B_ID         Message Buffer 52 ID Register
//  0x3C8  32  MB11_64B_WORD10    Message Buffer 11 WORD_64B Register
//  0x3C8  32  MB21_32B_CS        Message Buffer 21 CS Register
//  0x3C8  32  MB35_16B_CS        Message Buffer 35 CS Register
//  0x3C8  32  MB52_8B_WORD0      Message Buffer 52 WORD_8B Register
//  0x3C8  32  WORD052            Message Buffer 52 WORD0 Register
//  0x3CC  32  MB11_64B_WORD11    Message Buffer 11 WORD_64B Register
//  0x3CC  32  MB21_32B_ID        Message Buffer 21 ID Register
//  0x3CC  32  MB35_16B_ID        Message Buffer 35 ID Register
//  0x3CC  32  MB52_8B_WORD1      Message Buffer 52 WORD_8B Register
//  0x3CC  32  WORD152            Message Buffer 52 WORD1 Register
//  0x3D0  32  CS53               Message Buffer 53 CS Register
//  0x3D0  32  MB11_64B_WORD12    Message Buffer 11 WORD_64B Register
//  0x3D0  32  MB21_32B_WORD0     Message Buffer 21 WORD_32B Register
//  0x3D0  32  MB35_16B_WORD0     Message Buffer 35 WORD_16B Register
//  0x3D0  32  MB53_8B_CS         Message Buffer 53 CS Register
//  0x3D4  32  ID53               Message Buffer 53 ID Register
//  0x3D4  32  MB11_64B_WORD13    Message Buffer 11 WORD_64B Register
//  0x3D4  32  MB21_32B_WORD1     Message Buffer 21 WORD_32B Register
//  0x3D4  32  MB35_16B_WORD1     Message Buffer 35 WORD_16B Register
//  0x3D4  32  MB53_8B_ID         Message Buffer 53 ID Register
//  0x3D8  32  MB11_64B_WORD14    Message Buffer 11 WORD_64B Register
//  0x3D8  32  MB21_32B_WORD2     Message Buffer 21 WORD_32B Register
//  0x3D8  32  MB35_16B_WORD2     Message Buffer 35 WORD_16B Register
//  0x3D8  32  MB53_8B_WORD0      Message Buffer 53 WORD_8B Register
//  0x3D8  32  WORD053            Message Buffer 53 WORD0 Register
//  0x3DC  32  MB11_64B_WORD15    Message Buffer 11 WORD_64B Register
//  0x3DC  32  MB21_32B_WORD3     Message Buffer 21 WORD_32B Register
//  0x3DC  32  MB35_16B_WORD3     Message Buffer 35 WORD_16B Register
//  0x3DC  32  MB53_8B_WORD1      Message Buffer 53 WORD_8B Register
//  0x3DC  32  WORD153            Message Buffer 53 WORD1 Register
//  0x3E0  32  MB54_8B_CS         Message Buffer 54 CS Register
//  0x3E0  32  MB12_64B_CS        Message Buffer 12 CS Register
//  0x3E0  32  MB21_32B_WORD4     Message Buffer 21 WORD_32B Register
//  0x3E0  32  MB36_16B_CS        Message Buffer 36 CS Register
//  0x3E0  32  CS54               Message Buffer 54 CS Register
//  0x3E4  32  ID54               Message Buffer 54 ID Register
//  0x3E4  32  MB12_64B_ID        Message Buffer 12 ID Register
//  0x3E4  32  MB21_32B_WORD5     Message Buffer 21 WORD_32B Register
//  0x3E4  32  MB36_16B_ID        Message Buffer 36 ID Register
//  0x3E4  32  MB54_8B_ID         Message Buffer 54 ID Register
//  0x3E8  32  WORD054            Message Buffer 54 WORD0 Register
//  0x3E8  32  MB21_32B_WORD6     Message Buffer 21 WORD_32B Register
//  0x3E8  32  MB36_16B_WORD0     Message Buffer 36 WORD_16B Register
//  0x3E8  32  MB54_8B_WORD0      Message Buffer 54 WORD_8B Register
//  0x3E8  32  MB12_64B_WORD0     Message Buffer 12 WORD_64B Register
//  0x3EC  32  MB12_64B_WORD1     Message Buffer 12 WORD_64B Register
//  0x3EC  32  MB21_32B_WORD7     Message Buffer 21 WORD_32B Register
//  0x3EC  32  MB36_16B_WORD1     Message Buffer 36 WORD_16B Register
//  0x3EC  32  MB54_8B_WORD1      Message Buffer 54 WORD_8B Register
//  0x3EC  32  WORD154            Message Buffer 54 WORD1 Register
//  0x3F0  32  MB22_32B_CS        Message Buffer 22 CS Register
//  0x3F0  32  MB12_64B_WORD2     Message Buffer 12 WORD_64B Register
//  0x3F0  32  CS55               Message Buffer 55 CS Register
//  0x3F0  32  MB36_16B_WORD2     Message Buffer 36 WORD_16B Register
//  0x3F0  32  MB55_8B_CS         Message Buffer 55 CS Register
//  0x3F4  32  ID55               Message Buffer 55 ID Register
//  0x3F4  32  MB12_64B_WORD3     Message Buffer 12 WORD_64B Register
//  0x3F4  32  MB22_32B_ID        Message Buffer 22 ID Register
//  0x3F4  32  MB36_16B_WORD3     Message Buffer 36 WORD_16B Register
//  0x3F4  32  MB55_8B_ID         Message Buffer 55 ID Register
//  0x3F8  32  MB22_32B_WORD0     Message Buffer 22 WORD_32B Register
//  0x3F8  32  MB37_16B_CS        Message Buffer 37 CS Register
//  0x3F8  32  MB55_8B_WORD0      Message Buffer 55 WORD_8B Register
//  0x3F8  32  WORD055            Message Buffer 55 WORD0 Register
//  0x3F8  32  MB12_64B_WORD4     Message Buffer 12 WORD_64B Register
//  0x3FC  32  WORD155            Message Buffer 55 WORD1 Register
//  0x3FC  32  MB12_64B_WORD5     Message Buffer 12 WORD_64B Register
//  0x3FC  32  MB22_32B_WORD1     Message Buffer 22 WORD_32B Register
//  0x3FC  32  MB55_8B_WORD1      Message Buffer 55 WORD_8B Register
//  0x3FC  32  MB37_16B_ID        Message Buffer 37 ID Register
//  0x400  32  CS56               Message Buffer 56 CS Register
//  0x400  32  MB12_64B_WORD6     Message Buffer 12 WORD_64B Register
//  0x400  32  MB22_32B_WORD2     Message Buffer 22 WORD_32B Register
//  0x400  32  MB37_16B_WORD0     Message Buffer 37 WORD_16B Register
//  0x400  32  MB56_8B_CS         Message Buffer 56 CS Register
//  0x404  32  MB56_8B_ID         Message Buffer 56 ID Register
//  0x404  32  ID56               Message Buffer 56 ID Register
//  0x404  32  MB22_32B_WORD3     Message Buffer 22 WORD_32B Register
//  0x404  32  MB37_16B_WORD1     Message Buffer 37 WORD_16B Register
//  0x404  32  MB12_64B_WORD7     Message Buffer 12 WORD_64B Register
//  0x408  32  MB12_64B_WORD8     Message Buffer 12 WORD_64B Register
//  0x408  32  MB22_32B_WORD4     Message Buffer 22 WORD_32B Register
//  0x408  32  MB37_16B_WORD2     Message Buffer 37 WORD_16B Register
//  0x408  32  MB56_8B_WORD0      Message Buffer 56 WORD_8B Register
//  0x408  32  WORD056            Message Buffer 56 WORD0 Register
//  0x40C  32  MB12_64B_WORD9     Message Buffer 12 WORD_64B Register
//  0x40C  32  MB22_32B_WORD5     Message Buffer 22 WORD_32B Register
//  0x40C  32  MB37_16B_WORD3     Message Buffer 37 WORD_16B Register
//  0x40C  32  MB56_8B_WORD1      Message Buffer 56 WORD_8B Register
//  0x40C  32  WORD156            Message Buffer 56 WORD1 Register
//  0x410  32  MB57_8B_CS         Message Buffer 57 CS Register
//  0x410  32  MB12_64B_WORD10    Message Buffer 12 WORD_64B Register
//  0x410  32  CS57               Message Buffer 57 CS Register
//  0x410  32  MB38_16B_CS        Message Buffer 38 CS Register
//  0x410  32  MB22_32B_WORD6     Message Buffer 22 WORD_32B Register
//  0x414  32  ID57               Message Buffer 57 ID Register
//  0x414  32  MB12_64B_WORD11    Message Buffer 12 WORD_64B Register
//  0x414  32  MB22_32B_WORD7     Message Buffer 22 WORD_32B Register
//  0x414  32  MB38_16B_ID        Message Buffer 38 ID Register
//  0x414  32  MB57_8B_ID         Message Buffer 57 ID Register
//  0x418  32  MB38_16B_WORD0     Message Buffer 38 WORD_16B Register
//  0x418  32  MB23_32B_CS        Message Buffer 23 CS Register
//  0x418  32  MB12_64B_WORD12    Message Buffer 12 WORD_64B Register
//  0x418  32  MB57_8B_WORD0      Message Buffer 57 WORD_8B Register
//  0x418  32  WORD057            Message Buffer 57 WORD0 Register
//  0x41C  32  MB12_64B_WORD13    Message Buffer 12 WORD_64B Register
//  0x41C  32  MB23_32B_ID        Message Buffer 23 ID Register
//  0x41C  32  MB38_16B_WORD1     Message Buffer 38 WORD_16B Register
//  0x41C  32  MB57_8B_WORD1      Message Buffer 57 WORD_8B Register
//  0x41C  32  WORD157            Message Buffer 57 WORD1 Register
//  0x420  32  CS58               Message Buffer 58 CS Register
//  0x420  32  MB12_64B_WORD14    Message Buffer 12 WORD_64B Register
//  0x420  32  MB23_32B_WORD0     Message Buffer 23 WORD_32B Register
//  0x420  32  MB38_16B_WORD2     Message Buffer 38 WORD_16B Register
//  0x420  32  MB58_8B_CS         Message Buffer 58 CS Register
//  0x424  32  ID58               Message Buffer 58 ID Register
//  0x424  32  MB12_64B_WORD15    Message Buffer 12 WORD_64B Register
//  0x424  32  MB23_32B_WORD1     Message Buffer 23 WORD_32B Register
//  0x424  32  MB38_16B_WORD3     Message Buffer 38 WORD_16B Register
//  0x424  32  MB58_8B_ID         Message Buffer 58 ID Register
//  0x428  32  MB13_64B_CS        Message Buffer 13 CS Register
//  0x428  32  MB23_32B_WORD2     Message Buffer 23 WORD_32B Register
//  0x428  32  MB58_8B_WORD0      Message Buffer 58 WORD_8B Register
//  0x428  32  WORD058            Message Buffer 58 WORD0 Register
//  0x428  32  MB39_16B_CS        Message Buffer 39 CS Register
//  0x42C  32  MB13_64B_ID        Message Buffer 13 ID Register
//  0x42C  32  MB23_32B_WORD3     Message Buffer 23 WORD_32B Register
//  0x42C  32  MB39_16B_ID        Message Buffer 39 ID Register
//  0x42C  32  MB58_8B_WORD1      Message Buffer 58 WORD_8B Register
//  0x42C  32  WORD158            Message Buffer 58 WORD1 Register
//  0x430  32  CS59               Message Buffer 59 CS Register
//  0x430  32  MB13_64B_WORD0     Message Buffer 13 WORD_64B Register
//  0x430  32  MB23_32B_WORD4     Message Buffer 23 WORD_32B Register
//  0x430  32  MB39_16B_WORD0     Message Buffer 39 WORD_16B Register
//  0x430  32  MB59_8B_CS         Message Buffer 59 CS Register
//  0x434  32  ID59               Message Buffer 59 ID Register
//  0x434  32  MB13_64B_WORD1     Message Buffer 13 WORD_64B Register
//  0x434  32  MB23_32B_WORD5     Message Buffer 23 WORD_32B Register
//  0x434  32  MB39_16B_WORD1     Message Buffer 39 WORD_16B Register
//  0x434  32  MB59_8B_ID         Message Buffer 59 ID Register
//  0x438  32  MB13_64B_WORD2     Message Buffer 13 WORD_64B Register
//  0x438  32  MB23_32B_WORD6     Message Buffer 23 WORD_32B Register
//  0x438  32  MB39_16B_WORD2     Message Buffer 39 WORD_16B Register
//  0x438  32  WORD059            Message Buffer 59 WORD0 Register
//  0x438  32  MB59_8B_WORD0      Message Buffer 59 WORD_8B Register
//  0x43C  32  WORD159            Message Buffer 59 WORD1 Register
//  0x43C  32  MB23_32B_WORD7     Message Buffer 23 WORD_32B Register
//  0x43C  32  MB39_16B_WORD3     Message Buffer 39 WORD_16B Register
//  0x43C  32  MB13_64B_WORD3     Message Buffer 13 WORD_64B Register
//  0x43C  32  MB59_8B_WORD1      Message Buffer 59 WORD_8B Register
//  0x440  32  CS60               Message Buffer 60 CS Register
//  0x440  32  MB13_64B_WORD4     Message Buffer 13 WORD_64B Register
//  0x440  32  MB40_16B_CS        Message Buffer 40 CS Register
//  0x440  32  MB60_8B_CS         Message Buffer 60 CS Register
//  0x444  32  MB13_64B_WORD5     Message Buffer 13 WORD_64B Register
//  0x444  32  MB40_16B_ID        Message Buffer 40 ID Register
//  0x444  32  MB60_8B_ID         Message Buffer 60 ID Register
//  0x444  32  ID60               Message Buffer 60 ID Register
//  0x448  32  MB60_8B_WORD0      Message Buffer 60 WORD_8B Register
//  0x448  32  WORD060            Message Buffer 60 WORD0 Register
//  0x448  32  MB40_16B_WORD0     Message Buffer 40 WORD_16B Register
//  0x448  32  MB13_64B_WORD6     Message Buffer 13 WORD_64B Register
//  0x44C  32  MB13_64B_WORD7     Message Buffer 13 WORD_64B Register
//  0x44C  32  MB40_16B_WORD1     Message Buffer 40 WORD_16B Register
//  0x44C  32  MB60_8B_WORD1      Message Buffer 60 WORD_8B Register
//  0x44C  32  WORD160            Message Buffer 60 WORD1 Register
//  0x450  32  CS61               Message Buffer 61 CS Register
//  0x450  32  MB13_64B_WORD8     Message Buffer 13 WORD_64B Register
//  0x450  32  MB40_16B_WORD2     Message Buffer 40 WORD_16B Register
//  0x450  32  MB61_8B_CS         Message Buffer 61 CS Register
//  0x454  32  ID61               Message Buffer 61 ID Register
//  0x454  32  MB13_64B_WORD9     Message Buffer 13 WORD_64B Register
//  0x454  32  MB40_16B_WORD3     Message Buffer 40 WORD_16B Register
//  0x454  32  MB61_8B_ID         Message Buffer 61 ID Register
//  0x458  32  MB13_64B_WORD10    Message Buffer 13 WORD_64B Register
//  0x458  32  MB41_16B_CS        Message Buffer 41 CS Register
//  0x458  32  WORD061            Message Buffer 61 WORD0 Register
//  0x458  32  MB61_8B_WORD0      Message Buffer 61 WORD_8B Register
//  0x45C  32  MB13_64B_WORD11    Message Buffer 13 WORD_64B Register
//  0x45C  32  MB61_8B_WORD1      Message Buffer 61 WORD_8B Register
//  0x45C  32  MB41_16B_ID        Message Buffer 41 ID Register
//  0x45C  32  WORD161            Message Buffer 61 WORD1 Register
//  0x460  32  CS62               Message Buffer 62 CS Register
//  0x460  32  MB13_64B_WORD12    Message Buffer 13 WORD_64B Register
//  0x460  32  MB41_16B_WORD0     Message Buffer 41 WORD_16B Register
//  0x460  32  MB62_8B_CS         Message Buffer 62 CS Register
//  0x464  32  ID62               Message Buffer 62 ID Register
//  0x464  32  MB13_64B_WORD13    Message Buffer 13 WORD_64B Register
//  0x464  32  MB41_16B_WORD1     Message Buffer 41 WORD_16B Register
//  0x464  32  MB62_8B_ID         Message Buffer 62 ID Register
//  0x468  32  WORD062            Message Buffer 62 WORD0 Register
//  0x468  32  MB41_16B_WORD2     Message Buffer 41 WORD_16B Register
//  0x468  32  MB62_8B_WORD0      Message Buffer 62 WORD_8B Register
//  0x468  32  MB13_64B_WORD14    Message Buffer 13 WORD_64B Register
//  0x46C  32  MB41_16B_WORD3     Message Buffer 41 WORD_16B Register
//  0x46C  32  MB62_8B_WORD1      Message Buffer 62 WORD_8B Register
//  0x46C  32  WORD162            Message Buffer 62 WORD1 Register
//  0x46C  32  MB13_64B_WORD15    Message Buffer 13 WORD_64B Register
//  0x470  32  MB63_8B_CS         Message Buffer 63 CS Register
//  0x470  32  CS63               Message Buffer 63 CS Register
//  0x474  32  ID63               Message Buffer 63 ID Register
//  0x474  32  MB63_8B_ID         Message Buffer 63 ID Register
//  0x478  32  MB63_8B_WORD0      Message Buffer 63 WORD_8B Register
//  0x478  32  WORD063            Message Buffer 63 WORD0 Register
//  0x47C  32  WORD163            Message Buffer 63 WORD1 Register
//  0x47C  32  MB63_8B_WORD1      Message Buffer 63 WORD_8B Register
//  0x880  32  RXIMR[64]          Rx Individual Mask Registers
//  0xBF0  32  EPRS               Enhanced CAN Bit Timing Prescalers
//  0xBF4  32  ENCBT              Enhanced Nominal CAN Bit Timing
//  0xBF8  32  EDCBT              Enhanced Data Phase CAN bit Timing
//  0xBFC  32  ETDC               Enhanced Transceiver Delay Compensation
//  0xC00  32  FDCTRL             CAN FD Control Register
//  0xC04  32  FDCBT              CAN FD Bit Timing Register
//  0xC08  32  FDCRC              CAN FD CRC Register
//  0xC0C  32  ERFCR              Enhanced Rx FIFO Control Register
//  0xC10  32  ERFIER             Enhanced Rx FIFO Interrupt Enable register
//  0xC14  32  ERFSR              Enhanced Rx FIFO Status Register
//  0xC30  32  HR_TIME_STAMP[64]  High Resolution Time Stamp
//  0x3000 32  ERFFEL[128]        Enhanced Rx FIFO Filter Element
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package can3

const (
	MAXMB   MCR = 0x7F << 0  //+ Number Of The Last Message Buffer
	IDAM    MCR = 0x03 << 8  //+ ID Acceptance Mode
	IDAM_0  MCR = 0x00 << 8  //  Format A: One full ID (standard and extended) per ID Filter Table element.
	IDAM_1  MCR = 0x01 << 8  //  Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
	IDAM_2  MCR = 0x02 << 8  //  Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
	IDAM_3  MCR = 0x03 << 8  //  Format D: All frames rejected.
	FDEN    MCR = 0x01 << 11 //+ CAN FD operation enable
	AEN     MCR = 0x01 << 12 //+ Abort Enable
	LPRIOEN MCR = 0x01 << 13 //+ Local Priority Enable
	DMA     MCR = 0x01 << 15 //+ DMA Enable
	IRMQ    MCR = 0x01 << 16 //+ Individual Rx Masking And Queue Enable
	SRXDIS  MCR = 0x01 << 17 //+ Self Reception Disable
	DOZE    MCR = 0x01 << 18 //+ Doze Mode Enable
	WAKSRC  MCR = 0x01 << 19 //+ Wake Up Source
	LPMACK  MCR = 0x01 << 20 //+ Low-Power Mode Acknowledge
	WRNEN   MCR = 0x01 << 21 //+ Warning Interrupt Enable
	SLFWAK  MCR = 0x01 << 22 //+ Self Wake Up
	SUPV    MCR = 0x01 << 23 //+ Supervisor Mode
	FRZACK  MCR = 0x01 << 24 //+ Freeze Mode Acknowledge
	SOFTRST MCR = 0x01 << 25 //+ Soft Reset
	WAKMSK  MCR = 0x01 << 26 //+ Wake Up Interrupt Mask
	NOTRDY  MCR = 0x01 << 27 //+ FlexCAN Not Ready
	HALT    MCR = 0x01 << 28 //+ Halt FlexCAN
	RFEN    MCR = 0x01 << 29 //+ Legacy Rx FIFO Enable
	FRZ     MCR = 0x01 << 30 //+ Freeze Enable
	MDIS    MCR = 0x01 << 31 //+ Module Disable
)

const (
	MAXMBn   = 0
	IDAMn    = 8
	FDENn    = 11
	AENn     = 12
	LPRIOENn = 13
	DMAn     = 15
	IRMQn    = 16
	SRXDISn  = 17
	DOZEn    = 18
	WAKSRCn  = 19
	LPMACKn  = 20
	WRNENn   = 21
	SLFWAKn  = 22
	SUPVn    = 23
	FRZACKn  = 24
	SOFTRSTn = 25
	WAKMSKn  = 26
	NOTRDYn  = 27
	HALTn    = 28
	RFENn    = 29
	FRZn     = 30
	MDISn    = 31
)

const (
	PROPSEG CTRL1 = 0x07 << 0  //+ Propagation Segment
	LOM     CTRL1 = 0x01 << 3  //+ Listen-Only Mode
	LBUF    CTRL1 = 0x01 << 4  //+ Lowest Buffer Transmitted First
	TSYN    CTRL1 = 0x01 << 5  //+ Timer Sync
	BOFFREC CTRL1 = 0x01 << 6  //+ Bus Off Recovery
	SMP     CTRL1 = 0x01 << 7  //+ CAN Bit Sampling
	RWRNMSK CTRL1 = 0x01 << 10 //+ Rx Warning Interrupt Mask
	TWRNMSK CTRL1 = 0x01 << 11 //+ Tx Warning Interrupt Mask
	LPB     CTRL1 = 0x01 << 12 //+ Loop Back Mode
	CLKSRC  CTRL1 = 0x01 << 13 //+ CAN Engine Clock Source
	ERRMSK  CTRL1 = 0x01 << 14 //+ Error Interrupt Mask
	BOFFMSK CTRL1 = 0x01 << 15 //+ Bus Off Interrupt Mask
	PSEG2   CTRL1 = 0x07 << 16 //+ Phase Segment 2
	PSEG1   CTRL1 = 0x07 << 19 //+ Phase Segment 1
	RJW     CTRL1 = 0x03 << 22 //+ Resync Jump Width
	PRESDIV CTRL1 = 0xFF << 24 //+ Prescaler Division Factor
)

const (
	PROPSEGn = 0
	LOMn     = 3
	LBUFn    = 4
	TSYNn    = 5
	BOFFRECn = 6
	SMPn     = 7
	RWRNMSKn = 10
	TWRNMSKn = 11
	LPBn     = 12
	CLKSRCn  = 13
	ERRMSKn  = 14
	BOFFMSKn = 15
	PSEG2n   = 16
	PSEG1n   = 19
	RJWn     = 22
	PRESDIVn = 24
)

const (
	TIMER TIMER = 0xFFFF << 0 //+ Timer Value
)

const (
	TIMERn = 0
)

const (
	MG RXMGMASK = 0xFFFFFFFF << 0 //+ Rx Mailboxes Global Mask Bits
)

const (
	MGn = 0
)

const (
	RX14M RX14MASK = 0xFFFFFFFF << 0 //+ Rx Buffer 14 Mask Bits
)

const (
	RX14Mn = 0
)

const (
	RX15M RX15MASK = 0xFFFFFFFF << 0 //+ Rx Buffer 15 Mask Bits
)

const (
	RX15Mn = 0
)

const (
	TXERRCNT      ECR = 0xFF << 0  //+ Transmit Error Counter
	RXERRCNT      ECR = 0xFF << 8  //+ Receive Error Counter
	TXERRCNT_FAST ECR = 0xFF << 16 //+ Transmit Error Counter for fast bits
	RXERRCNT_FAST ECR = 0xFF << 24 //+ Receive Error Counter for fast bits
)

const (
	TXERRCNTn      = 0
	RXERRCNTn      = 8
	TXERRCNT_FASTn = 16
	RXERRCNT_FASTn = 24
)

const (
	WAKINT       ESR1 = 0x01 << 0  //+ Wake-Up Interrupt
	ERRINT       ESR1 = 0x01 << 1  //+ Error Interrupt
	BOFFINT      ESR1 = 0x01 << 2  //+ Bus Off Interrupt
	RX           ESR1 = 0x01 << 3  //+ FlexCAN In Reception
	FLTCONF      ESR1 = 0x03 << 4  //+ Fault Confinement State
	FLTCONF_0    ESR1 = 0x00 << 4  //  Error Active
	FLTCONF_1    ESR1 = 0x01 << 4  //  Error Passive
	FLTCONF_2    ESR1 = 0x02 << 4  //  Bus Off
	TX           ESR1 = 0x01 << 6  //+ FlexCAN In Transmission
	IDLE         ESR1 = 0x01 << 7  //+ IDLE
	RXWRN        ESR1 = 0x01 << 8  //+ Rx Error Warning
	TXWRN        ESR1 = 0x01 << 9  //+ TX Error Warning
	STFERR       ESR1 = 0x01 << 10 //+ Stuffing Error
	FRMERR       ESR1 = 0x01 << 11 //+ Form Error
	CRCERR       ESR1 = 0x01 << 12 //+ Cyclic Redundancy Check Error
	ACKERR       ESR1 = 0x01 << 13 //+ Acknowledge Error
	BIT0ERR      ESR1 = 0x01 << 14 //+ Bit0 Error
	BIT1ERR      ESR1 = 0x01 << 15 //+ Bit1 Error
	RWRNINT      ESR1 = 0x01 << 16 //+ Rx Warning Interrupt Flag
	TWRNINT      ESR1 = 0x01 << 17 //+ Tx Warning Interrupt Flag
	SYNCH        ESR1 = 0x01 << 18 //+ CAN Synchronization Status
	BOFFDONEINT  ESR1 = 0x01 << 19 //+ Bus Off Done Interrupt
	ERRINT_FAST  ESR1 = 0x01 << 20 //+ Error Interrupt for errors detected in the Data Phase of CAN FD frames with the BRS bit set
	ERROVR       ESR1 = 0x01 << 21 //+ Error Overrun bit
	STFERR_FAST  ESR1 = 0x01 << 26 //+ Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
	FRMERR_FAST  ESR1 = 0x01 << 27 //+ Form Error in the Data Phase of CAN FD frames with the BRS bit set
	CRCERR_FAST  ESR1 = 0x01 << 28 //+ Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the BRS bit set
	BIT0ERR_FAST ESR1 = 0x01 << 30 //+ Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
	BIT1ERR_FAST ESR1 = 0x01 << 31 //+ Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
)

const (
	WAKINTn       = 0
	ERRINTn       = 1
	BOFFINTn      = 2
	RXn           = 3
	FLTCONFn      = 4
	TXn           = 6
	IDLEn         = 7
	RXWRNn        = 8
	TXWRNn        = 9
	STFERRn       = 10
	FRMERRn       = 11
	CRCERRn       = 12
	ACKERRn       = 13
	BIT0ERRn      = 14
	BIT1ERRn      = 15
	RWRNINTn      = 16
	TWRNINTn      = 17
	SYNCHn        = 18
	BOFFDONEINTn  = 19
	ERRINT_FASTn  = 20
	ERROVRn       = 21
	STFERR_FASTn  = 26
	FRMERR_FASTn  = 27
	CRCERR_FASTn  = 28
	BIT0ERR_FASTn = 30
	BIT1ERR_FASTn = 31
)

const (
	BUF63TO32M IMASK2 = 0xFFFFFFFF << 0 //+ Buffer MB i Mask
)

const (
	BUF63TO32Mn = 0
)

const (
	BUF31TO0M IMASK1 = 0xFFFFFFFF << 0 //+ Buffer MB i Mask
)

const (
	BUF31TO0Mn = 0
)

const (
	BUF63TO32I IFLAG2 = 0xFFFFFFFF << 0 //+ Buffer MB i Interrupt
)

const (
	BUF63TO32In = 0
)

const (
	BUF0I     IFLAG1 = 0x01 << 0     //+ Buffer MB0 Interrupt Or Clear Legacy FIFO bit
	BUF4TO1I  IFLAG1 = 0x0F << 1     //+ Buffer MB i Interrupt Or "reserved"
	BUF5I     IFLAG1 = 0x01 << 5     //+ Buffer MB5 Interrupt Or "Frames available in Legacy Rx FIFO"
	BUF6I     IFLAG1 = 0x01 << 6     //+ Buffer MB6 Interrupt Or "Legacy Rx FIFO Warning"
	BUF7I     IFLAG1 = 0x01 << 7     //+ Buffer MB7 Interrupt Or "Legacy Rx FIFO Overflow"
	BUF31TO8I IFLAG1 = 0xFFFFFF << 8 //+ Buffer MBi Interrupt
)

const (
	BUF0In     = 0
	BUF4TO1In  = 1
	BUF5In     = 5
	BUF6In     = 6
	BUF7In     = 7
	BUF31TO8In = 8
)

const (
	TSTAMPCAP   CTRL2 = 0x03 << 6  //+ Time Stamp Capture Point
	TSTAMPCAP_0 CTRL2 = 0x00 << 6  //  The high resolution time stamp capture is disabled
	TSTAMPCAP_1 CTRL2 = 0x01 << 6  //  The high resolution time stamp is captured in the end of the CAN frame
	TSTAMPCAP_2 CTRL2 = 0x02 << 6  //  The high resolution time stamp is captured in the start of the CAN frame
	TSTAMPCAP_3 CTRL2 = 0x03 << 6  //  The high resolution time stamp is captured in the start of frame for classical CAN frames and in res bit for CAN FD frames
	MBTSBASE    CTRL2 = 0x03 << 8  //+ Message Buffer Time Stamp Base
	MBTSBASE_0  CTRL2 = 0x00 << 8  //  Message Buffer Time Stamp base is CAN_TIMER
	MBTSBASE_1  CTRL2 = 0x01 << 8  //  Message Buffer Time Stamp base is lower 16-bits of high resolution timer
	MBTSBASE_2  CTRL2 = 0x02 << 8  //  Message Buffer Time Stamp base is upper 16-bits of high resolution timerT
	EDFLTDIS    CTRL2 = 0x01 << 11 //+ Edge Filter Disable
	ISOCANFDEN  CTRL2 = 0x01 << 12 //+ ISO CAN FD Enable
	BTE         CTRL2 = 0x01 << 13 //+ Bit Timing Expansion enable
	PREXCEN     CTRL2 = 0x01 << 14 //+ Protocol Exception Enable
	TIMER_SRC   CTRL2 = 0x01 << 15 //+ Timer Source
	EACEN       CTRL2 = 0x01 << 16 //+ Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
	RRS         CTRL2 = 0x01 << 17 //+ Remote Request Storing
	MRP         CTRL2 = 0x01 << 18 //+ Mailboxes Reception Priority
	TASD        CTRL2 = 0x1F << 19 //+ Tx Arbitration Start Delay
	RFFN        CTRL2 = 0x0F << 24 //+ Number Of Legacy Rx FIFO Filters
	BOFFDONEMSK CTRL2 = 0x01 << 30 //+ Bus Off Done Interrupt Mask
	ERRMSK_FAST CTRL2 = 0x01 << 31 //+ Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
)

const (
	TSTAMPCAPn   = 6
	MBTSBASEn    = 8
	EDFLTDISn    = 11
	ISOCANFDENn  = 12
	BTEn         = 13
	PREXCENn     = 14
	TIMER_SRCn   = 15
	EACENn       = 16
	RRSn         = 17
	MRPn         = 18
	TASDn        = 19
	RFFNn        = 24
	BOFFDONEMSKn = 30
	ERRMSK_FASTn = 31
)

const (
	IMB  ESR2 = 0x01 << 13 //+ Inactive Mailbox
	VPS  ESR2 = 0x01 << 14 //+ Valid Priority Status
	LPTM ESR2 = 0x7F << 16 //+ Lowest Priority Tx Mailbox
)

const (
	IMBn  = 13
	VPSn  = 14
	LPTMn = 16
)

const (
	TXCRC CRCR = 0x7FFF << 0 //+ Transmitted CRC value
	MBCRC CRCR = 0x7F << 16  //+ CRC Mailbox
)

const (
	TXCRCn = 0
	MBCRCn = 16
)

const (
	FGM RXFGMASK = 0xFFFFFFFF << 0 //+ Legacy Rx FIFO Global Mask Bits
)

const (
	FGMn = 0
)

const (
	IDHIT RXFIR = 0x1FF << 0 //+ Identifier Acceptance Filter Hit Indicator
)

const (
	IDHITn = 0
)

const (
	EPSEG2   CBT = 0x1F << 0   //+ Extended Phase Segment 2
	EPSEG1   CBT = 0x1F << 5   //+ Extended Phase Segment 1
	EPROPSEG CBT = 0x3F << 10  //+ Extended Propagation Segment
	ERJW     CBT = 0x1F << 16  //+ Extended Resync Jump Width
	EPRESDIV CBT = 0x3FF << 21 //+ Extended Prescaler Division Factor
	BTF      CBT = 0x01 << 31  //+ Bit Timing Format Enable
)

const (
	EPSEG2n   = 0
	EPSEG1n   = 5
	EPROPSEGn = 10
	ERJWn     = 16
	EPRESDIVn = 21
	BTFn      = 31
)

const (
	TIME_STAMP CS0 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS0 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS0 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS0 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS0 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS0 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS0 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS0 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS0 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB0_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB0_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB0_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB0_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB0_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB0_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB0_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB0_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB0_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB0_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB0_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB0_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB0_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB0_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB0_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB0_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB0_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB0_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB0_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB0_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB0_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB0_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB0_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB0_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB0_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB0_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB0_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB0_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB0_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB0_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB0_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB0_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB0_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB0_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB0_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB0_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB0_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB0_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB0_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB0_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB0_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB0_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB0_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB0_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB0_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB0_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB0_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB0_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID0 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID0 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID0 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB0_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB0_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB0_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB0_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB0_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB0_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB0_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB0_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB0_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB0_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB0_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB0_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB0_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB0_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB0_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB0_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD00 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD00 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD00 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD00 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB0_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB0_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB0_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB0_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB0_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB0_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB0_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB0_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB0_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB0_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB0_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB0_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB0_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB0_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB0_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB0_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS1 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS1 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS1 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS1 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS1 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS1 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS1 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS1 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS1 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB0_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB0_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB0_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB0_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB0_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB0_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB0_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB0_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB1_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB1_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB1_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB1_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB1_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB1_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB1_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB1_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB1_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB0_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB0_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB0_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB0_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_15 MB0_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB0_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB0_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB0_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB1_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB1_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB1_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB0_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB0_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB0_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB0_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB0_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB0_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB0_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB0_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  ID1 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID1 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID1 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_19 MB0_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB0_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB0_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB0_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_19 MB0_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB0_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB0_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB0_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB1_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB1_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB1_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB1_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB1_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB1_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB1_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB1_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB1_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB1_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB1_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB1_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB1_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD01 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD01 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD01 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD01 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_23 MB0_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB0_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB0_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB0_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_23 MB0_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB0_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB0_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB0_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB1_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB1_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB1_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB1_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB1_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB1_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB1_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS2 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS2 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS2 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS2 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS2 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS2 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS2 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS2 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS2 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB0_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB0_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB0_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB0_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_27 MB0_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB0_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB0_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB0_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB1_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB1_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB1_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB1_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB2_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB2_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB2_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB2_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB2_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB2_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB2_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB2_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB2_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID2 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID2 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID2 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB0_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB0_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB0_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB0_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_31 MB0_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB0_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB0_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB0_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB1_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB1_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB1_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB1_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB2_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB2_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB2_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_35 MB0_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB0_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB0_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB0_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_11 MB1_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB1_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB1_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB1_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB1_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB1_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB1_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB1_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB1_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB1_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB1_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB1_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB1_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB2_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB2_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB2_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB2_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD02 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD02 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD02 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD02 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_39 MB0_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB0_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB0_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB0_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_15 MB1_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB1_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB1_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB1_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB1_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB1_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB1_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB2_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB2_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB2_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB2_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS3 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS3 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS3 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS3 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS3 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS3 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS3 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS3 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS3 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB0_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB0_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB0_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB0_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP MB2_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB2_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB2_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB2_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB2_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB2_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB2_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB2_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB2_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB3_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB3_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB3_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB3_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB3_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB3_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB3_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB3_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB3_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB1_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB1_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB1_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB1_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB2_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB2_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB2_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB3_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB3_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB3_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB0_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB0_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB0_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB0_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 MB1_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB1_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB1_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB1_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  ID3 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID3 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID3 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_51 MB0_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB0_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB0_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB0_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_11 MB1_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB1_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB1_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB1_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB2_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB2_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB2_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB2_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB3_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB3_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB3_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB3_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD03 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD03 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD03 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD03 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_55 MB0_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB0_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB0_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB0_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_15 MB1_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB1_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB1_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB1_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB2_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB2_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB2_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB2_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB3_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB3_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB3_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB3_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS4 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS4 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS4 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS4 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS4 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS4 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS4 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS4 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS4 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB0_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB0_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB0_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB0_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_19 MB1_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB1_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB1_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB1_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB2_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB2_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB2_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB2_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB4_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB4_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB4_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB4_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB4_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB4_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB4_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB4_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB4_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID4 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID4 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID4 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB0_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB0_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB0_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB0_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_23 MB1_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB1_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB1_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB1_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB2_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB2_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB2_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB2_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB4_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB4_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB4_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_27 MB1_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB1_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB1_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB1_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB1_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB1_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB1_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB1_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB1_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB1_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB1_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB1_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB1_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB3_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB3_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB3_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB3_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB3_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB3_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB3_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB3_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB3_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB4_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB4_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB4_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB4_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD04 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD04 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD04 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD04 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB1_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB1_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB1_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB1_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB1_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB1_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB1_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB3_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB3_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB3_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB4_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB4_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB4_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB4_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS5 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS5 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS5 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS5 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS5 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS5 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS5 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS5 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS5 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB1_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB1_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB1_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB1_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB2_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB2_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB2_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB2_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB2_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB2_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB2_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB2_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB2_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB3_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB3_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB3_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB3_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB5_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB5_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB5_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB5_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB5_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB5_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB5_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB5_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB5_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID5 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID5 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID5 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB1_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB1_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB1_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB1_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB2_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB2_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB2_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB3_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB3_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB3_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB3_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB5_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB5_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB5_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB1_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB1_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB1_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB1_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB2_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB2_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB2_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB2_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB3_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB3_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB3_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB3_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB5_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB5_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB5_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB5_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD05 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD05 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD05 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD05 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB1_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB1_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB1_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB1_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB2_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB2_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB2_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB2_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB3_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB3_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB3_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB3_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB5_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB5_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB5_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB5_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS6 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS6 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS6 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS6 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS6 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS6 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS6 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS6 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS6 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB1_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB1_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB1_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB1_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB2_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB2_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB2_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB2_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB4_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB4_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB4_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB4_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB4_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB4_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB4_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB4_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB4_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB6_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB6_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB6_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB6_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB6_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB6_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB6_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB6_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB6_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID6 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID6 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID6 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB1_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB1_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB1_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB1_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB2_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB2_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB2_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB2_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB4_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB4_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB4_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB6_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB6_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB6_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_27 MB1_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB1_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB1_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB1_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_19 MB2_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB2_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB2_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB2_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB4_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB4_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB4_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB4_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB6_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB6_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB6_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB6_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD06 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD06 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD06 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD06 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB1_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB1_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB1_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB1_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_23 MB2_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB2_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB2_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB2_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB4_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB4_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB4_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB4_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB6_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB6_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB6_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB6_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD16 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD16 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD16 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD16 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS7 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS7 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS7 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS7 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS7 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS7 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS7 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS7 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS7 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB1_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB1_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB1_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB1_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_27 MB2_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB2_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB2_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB2_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB4_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB4_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB4_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB4_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB7_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB7_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB7_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB7_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB7_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB7_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB7_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB7_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB7_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB7_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB7_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB7_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB1_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB1_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB1_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB1_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_31 MB2_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB2_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB2_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB2_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB4_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB4_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB4_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB4_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  ID7 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID7 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID7 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_43 MB1_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB1_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB1_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB1_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP MB3_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB3_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB3_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB3_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB3_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB3_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB3_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB3_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB3_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB5_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB5_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB5_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB5_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB5_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB5_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB5_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB5_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB5_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB7_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB7_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB7_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB7_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD07 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD07 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD07 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD07 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_47 MB1_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB1_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB1_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB1_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	EXT  MB3_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB3_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB3_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB5_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB5_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB5_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB7_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB7_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB7_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB7_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD17 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD17 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD17 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD17 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS8 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS8 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS8 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS8 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS8 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS8 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS8 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS8 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS8 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB1_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB1_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB1_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB1_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 MB3_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB3_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB3_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB3_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB5_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB5_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB5_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB5_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB8_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB8_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB8_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB8_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB8_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB8_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB8_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB8_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB8_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID8 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID8 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID8 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_55 MB1_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB1_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB1_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB1_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_7 MB3_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB3_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB3_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB3_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB5_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB5_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB5_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB5_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB8_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB8_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB8_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_59 MB1_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB1_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB1_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB1_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_11 MB3_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB3_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB3_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB3_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB5_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB5_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB5_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB5_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB8_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB8_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB8_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB8_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD08 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD08 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD08 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD08 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_63 MB1_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB1_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB1_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB1_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_15 MB3_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB3_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB3_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB3_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB5_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB5_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB5_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB5_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB8_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB8_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB8_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB8_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD18 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD18 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD18 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD18 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS9 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS9 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS9 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS9 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS9 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS9 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS9 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS9 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS9 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB2_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB2_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB2_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB2_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB2_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB2_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB2_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB2_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB2_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB3_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB3_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB3_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB3_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB6_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB6_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB6_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB6_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB6_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB6_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB6_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB6_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB6_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB9_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB9_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB9_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB9_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB9_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB9_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB9_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB9_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB9_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID9 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID9 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID9 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB2_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB2_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB2_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB3_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB3_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB3_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB3_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB6_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB6_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB6_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB9_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB9_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB9_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB2_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB2_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB2_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB2_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB3_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB3_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB3_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB3_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB6_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB6_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB6_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB6_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB9_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB9_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB9_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB9_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD09 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD09 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD09 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD09 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB2_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB2_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB2_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB2_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB3_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB3_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB3_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB3_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB6_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB6_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB6_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB6_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB9_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB9_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB9_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB9_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD19 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD19 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD19 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD19 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS10 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS10 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS10 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS10 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS10 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS10 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS10 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS10 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS10 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB10_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB10_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB10_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB10_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB10_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB10_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB10_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB10_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB10_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB2_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB2_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB2_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB2_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB4_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB4_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB4_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB4_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB4_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB4_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB4_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB4_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB4_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB6_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB6_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB6_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB6_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	EXT  ID10 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID10 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID10 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB10_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB10_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB10_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB2_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB2_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB2_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB2_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB4_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB4_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB4_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB6_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB6_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB6_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB6_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_3 MB10_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB10_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB10_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB10_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB2_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB2_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB2_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB2_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB4_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB4_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB4_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB4_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB7_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB7_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB7_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB7_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB7_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB7_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB7_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB7_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB7_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD010 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD010 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD010 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD010 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB10_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB10_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB10_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB10_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB2_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB2_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB2_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB2_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB4_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB4_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB4_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB4_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB7_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB7_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB7_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD110 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD110 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD110 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD110 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS11 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS11 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS11 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS11 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS11 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS11 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS11 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS11 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS11 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB11_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB11_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB11_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB11_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB11_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB11_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB11_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB11_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB11_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB2_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB2_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB2_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB2_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB4_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB4_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB4_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB4_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB7_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB7_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB7_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB7_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  ID11 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID11 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID11 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB11_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB11_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB11_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB2_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB2_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB2_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB2_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB4_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB4_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB4_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB4_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB7_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB7_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB7_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB7_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_3 MB11_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB11_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB11_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB11_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_35 MB2_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB2_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB2_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB2_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_19 MB4_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB4_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB4_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB4_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB7_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB7_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB7_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB7_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD011 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD011 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD011 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD011 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB11_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB11_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB11_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB11_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_39 MB2_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB2_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB2_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB2_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_23 MB4_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB4_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB4_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB4_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB7_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB7_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB7_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB7_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD111 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD111 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD111 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD111 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS12 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS12 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS12 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS12 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS12 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS12 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS12 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS12 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS12 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB12_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB12_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB12_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB12_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB12_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB12_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB12_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB12_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB12_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB2_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB2_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB2_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB2_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_27 MB4_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB4_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB4_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB4_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB8_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB8_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB8_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB8_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB8_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB8_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB8_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB8_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB8_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID12 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID12 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID12 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB12_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB12_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB12_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB2_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB2_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB2_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB2_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_31 MB4_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB4_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB4_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB4_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB8_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB8_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB8_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB12_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB12_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB12_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB12_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_51 MB2_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB2_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB2_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB2_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	TIME_STAMP MB5_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB5_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB5_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB5_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB5_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB5_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB5_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB5_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB5_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB8_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB8_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB8_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB8_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD012 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD012 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD012 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD012 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB12_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB12_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB12_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB12_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_55 MB2_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB2_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB2_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB2_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	EXT  MB5_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB5_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB5_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB8_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB8_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB8_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB8_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD112 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD112 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD112 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD112 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS13 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS13 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS13 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS13 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS13 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS13 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS13 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS13 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS13 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB13_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB13_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB13_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB13_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB13_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB13_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB13_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB13_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB13_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB2_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB2_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB2_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB2_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_3 MB5_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB5_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB5_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB5_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB8_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB8_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB8_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB8_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	EXT  ID13 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID13 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID13 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB13_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB13_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB13_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB2_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB2_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB2_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB2_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_7 MB5_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB5_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB5_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB5_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB8_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB8_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB8_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB8_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_3 MB13_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB13_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB13_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB13_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB3_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB3_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB3_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB3_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB3_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB3_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB3_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB3_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB3_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB5_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB5_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB5_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB5_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB9_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB9_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB9_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB9_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB9_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB9_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB9_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB9_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB9_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD013 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD013 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD013 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD013 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB13_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB13_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB13_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB13_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB3_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB3_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB3_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB5_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB5_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB5_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB5_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB9_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB9_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB9_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD113 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD113 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD113 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD113 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_3 MB9_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB9_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB9_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB9_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB14_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB14_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB14_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB14_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB14_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB14_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB14_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB14_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB14_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB3_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB3_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB3_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB3_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB5_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB5_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB5_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB5_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP CS14 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS14 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS14 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS14 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS14 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS14 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS14 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS14 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS14 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID14 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID14 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID14 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB14_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB14_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB14_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB3_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB3_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB3_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB3_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB5_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB5_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB5_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB5_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB9_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB9_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB9_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB9_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_3 WORD014 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD014 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD014 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD014 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB3_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB3_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB3_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB3_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_27 MB5_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB5_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB5_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB5_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB9_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB9_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB9_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB9_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB14_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB14_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB14_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB14_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB14_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB14_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB14_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB14_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB3_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB3_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB3_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB3_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_31 MB5_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB5_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB5_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB5_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB9_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB9_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB9_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB9_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD114 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD114 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD114 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD114 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB15_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB15_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB15_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB15_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB15_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB15_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB15_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB15_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB15_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB10_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB10_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB10_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB10_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB10_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB10_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB10_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB10_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB10_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS15 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS15 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS15 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS15 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS15 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS15 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS15 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS15 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS15 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB3_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB3_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB3_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB3_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB6_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB6_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB6_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB6_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB6_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB6_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB6_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB6_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB6_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB6_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB6_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB6_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB10_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB10_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB10_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB15_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB15_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB15_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB3_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB3_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB3_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB3_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  ID15 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID15 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID15 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB15_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB15_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB15_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB15_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB3_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB3_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB3_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB3_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB6_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB6_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB6_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB6_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD015 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD015 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD015 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD015 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB10_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB10_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB10_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB10_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD115 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD115 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD115 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD115 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB10_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB10_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB10_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB10_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB15_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB15_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB15_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB15_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB6_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB6_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB6_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB6_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB3_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB3_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB3_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB3_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	TIME_STAMP CS16 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS16 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS16 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS16 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS16 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS16 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS16 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS16 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS16 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB10_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB10_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB10_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB10_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB16_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB16_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB16_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB16_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB16_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB16_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB16_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB16_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB16_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB3_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB3_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB3_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB3_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_11 MB6_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB6_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB6_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB6_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_15 MB6_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB6_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB6_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB6_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB10_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB10_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB10_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB10_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB16_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB16_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB16_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB3_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB3_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB3_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB3_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	EXT  ID16 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID16 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID16 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB11_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB11_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB11_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB11_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB11_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB11_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB11_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB11_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB11_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB16_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB16_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB16_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB16_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_43 MB3_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB3_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB3_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB3_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_19 MB6_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB6_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB6_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB6_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 WORD016 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD016 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD016 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD016 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB11_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB11_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB11_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB16_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB16_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB16_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB16_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_47 MB3_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB3_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB3_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB3_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_23 MB6_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB6_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB6_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB6_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 WORD116 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD116 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD116 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD116 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_27 MB6_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB6_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB6_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB6_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB11_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB11_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB11_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB11_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB17_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB17_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB17_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB17_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB17_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB17_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB17_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB17_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB17_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB3_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB3_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB3_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB3_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	TIME_STAMP CS17 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS17 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS17 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS17 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS17 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS17 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS17 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS17 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS17 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_7 MB11_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB11_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB11_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB11_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB17_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB17_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB17_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_55 MB3_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB3_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB3_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB3_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_31 MB6_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB6_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB6_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB6_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  ID17 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID17 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID17 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB11_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB11_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB11_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB11_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB17_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB17_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB17_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB17_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_59 MB3_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB3_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB3_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB3_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	TIME_STAMP MB7_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB7_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB7_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB7_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB7_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB7_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB7_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB7_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB7_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD017 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD017 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD017 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD017 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD117 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD117 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD117 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD117 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB17_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB17_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB17_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB17_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_63 MB3_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB3_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB3_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB3_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	EXT  MB7_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB7_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB7_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB11_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB11_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB11_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB11_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	TIME_STAMP CS18 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS18 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS18 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS18 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS18 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS18 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS18 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS18 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS18 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB12_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB12_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB12_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB12_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB12_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB12_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB12_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB12_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB12_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB18_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB18_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB18_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB18_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB18_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB18_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB18_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB18_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB18_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB4_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB4_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB4_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB4_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB4_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB4_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB4_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB4_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB4_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB7_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB7_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB7_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB7_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB7_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB7_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB7_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB7_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB12_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB12_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB12_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID18 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID18 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID18 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB4_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB4_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB4_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB18_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB18_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB18_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB12_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB12_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB12_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB12_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB18_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB18_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB18_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB18_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB4_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB4_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB4_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB4_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB7_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB7_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB7_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB7_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD018 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD018 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD018 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD018 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB12_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB12_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB12_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB12_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB18_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB18_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB18_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB18_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB4_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB4_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB4_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB4_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD118 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD118 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD118 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD118 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB7_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB7_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB7_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB7_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	TIME_STAMP CS19 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS19 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS19 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS19 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS19 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS19 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS19 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS19 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS19 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB12_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB12_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB12_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB12_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB19_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB19_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB19_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB19_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB19_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB19_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB19_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB19_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB19_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB4_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB4_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB4_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB4_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_19 MB7_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB7_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB7_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB7_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	EXT  ID19 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID19 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID19 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB12_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB12_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB12_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB12_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB19_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB19_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB19_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB4_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB4_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB4_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB4_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_23 MB7_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB7_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB7_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB7_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	TIME_STAMP MB13_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB13_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB13_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB13_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB13_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB13_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB13_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB13_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB13_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB19_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB19_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB19_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB19_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB4_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB4_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB4_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB4_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_27 MB7_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB7_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB7_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB7_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 WORD019 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD019 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD019 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD019 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB13_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB13_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB13_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB19_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB19_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB19_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB19_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB4_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB4_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB4_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB4_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_31 MB7_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB7_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB7_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB7_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 WORD119 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD119 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD119 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD119 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS20 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS20 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS20 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS20 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS20 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS20 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS20 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS20 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS20 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB13_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB13_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB13_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB13_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB20_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB20_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB20_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB20_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB20_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB20_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB20_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB20_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB20_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB4_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB4_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB4_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB4_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB8_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB8_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB8_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB8_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB8_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB8_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB8_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB8_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB8_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID20 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID20 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID20 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB13_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB13_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB13_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB13_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB20_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB20_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB20_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB4_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB4_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB4_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB4_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB8_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB8_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB8_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB13_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB13_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB13_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB13_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB20_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB20_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB20_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB20_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_35 MB4_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB4_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB4_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB4_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_3 MB8_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB8_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB8_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB8_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD020 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD020 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD020 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD020 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB13_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB13_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB13_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB13_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB20_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB20_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB20_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB20_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_39 MB4_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB4_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB4_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB4_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_7 MB8_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB8_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB8_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB8_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD120 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD120 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD120 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD120 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS21 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS21 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS21 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS21 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS21 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS21 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS21 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS21 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS21 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB14_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB14_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB14_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB14_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB14_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB14_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB14_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB14_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB14_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB21_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB21_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB21_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB21_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB21_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB21_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB21_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB21_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB21_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB4_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB4_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB4_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB4_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_11 MB8_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB8_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB8_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB8_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	EXT  ID21 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID21 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID21 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB14_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB14_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB14_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB21_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB21_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB21_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB4_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB4_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB4_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB4_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_15 MB8_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB8_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB8_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB8_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_3 MB14_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB14_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB14_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB14_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB21_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB21_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB21_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB21_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_51 MB4_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB4_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB4_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB4_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_19 MB8_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB8_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB8_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB8_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 WORD021 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD021 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD021 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD021 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB14_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB14_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB14_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB14_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB21_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB21_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB21_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB21_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_55 MB4_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB4_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB4_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB4_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_23 MB8_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB8_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB8_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB8_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 WORD121 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD121 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD121 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD121 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_27 MB8_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB8_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB8_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB8_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB14_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB14_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB14_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB14_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB22_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB22_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB22_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB22_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB22_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB22_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB22_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB22_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB22_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB4_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB4_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB4_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB4_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	TIME_STAMP CS22 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS22 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS22 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS22 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS22 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS22 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS22 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS22 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS22 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID22 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID22 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID22 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB14_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB14_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB14_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB14_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB22_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB22_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB22_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB4_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB4_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB4_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB4_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_31 MB8_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB8_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB8_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB8_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_3 WORD022 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD022 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD022 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD022 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB22_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB22_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB22_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB22_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB5_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB5_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB5_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB5_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB5_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB5_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB5_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB5_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB5_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB9_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB9_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB9_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB9_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB9_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB9_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB9_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB9_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB9_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB15_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB15_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB15_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB15_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB15_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB15_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB15_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB15_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB15_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB15_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB15_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB15_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB22_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB22_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB22_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB22_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB5_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB5_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB5_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB9_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB9_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB9_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD122 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD122 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD122 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD122 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB23_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB23_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB23_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB23_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB23_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB23_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB23_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB23_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB23_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB15_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB15_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB15_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB15_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP CS23 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS23 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS23 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS23 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS23 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS23 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS23 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS23 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS23 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB5_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB5_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB5_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB5_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB9_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB9_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB9_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB9_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  ID23 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID23 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID23 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB15_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB15_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB15_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB15_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB23_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB23_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB23_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB5_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB5_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB5_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB5_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB9_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB9_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB9_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB9_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_11 MB15_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB15_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB15_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB15_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB23_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB23_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB23_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB23_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB5_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB5_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB5_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB5_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB9_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB9_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB9_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB9_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD023 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD023 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD023 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD023 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB15_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB15_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB15_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB15_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB23_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB23_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB23_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB23_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB5_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB5_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB5_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB5_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB9_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB9_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB9_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB9_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD123 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD123 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD123 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD123 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS24 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS24 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS24 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS24 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS24 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS24 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS24 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS24 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS24 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB16_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB16_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB16_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB16_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB16_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB16_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB16_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB16_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB16_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB24_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB24_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB24_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB24_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB24_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB24_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB24_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB24_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB24_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB5_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB5_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB5_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB5_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_19 MB9_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB9_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB9_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB9_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	EXT  ID24 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID24 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID24 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB16_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB16_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB16_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB24_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB24_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB24_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB5_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB5_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB5_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB5_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_23 MB9_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB9_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB9_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB9_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_3 MB16_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB16_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB16_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB16_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB24_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB24_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB24_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB24_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB5_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB5_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB5_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB5_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_27 MB9_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB9_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB9_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB9_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 WORD024 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD024 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD024 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD024 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB16_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB16_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB16_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB16_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB24_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB24_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB24_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB24_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB5_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB5_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB5_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB5_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_31 MB9_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB9_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB9_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB9_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 WORD124 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD124 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD124 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD124 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS25 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS25 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS25 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS25 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS25 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS25 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS25 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS25 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS25 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB10_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB10_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB10_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB10_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB10_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB10_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB10_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB10_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB10_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB16_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB16_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB16_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB16_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB25_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB25_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB25_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB25_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB25_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB25_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB25_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB25_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB25_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB5_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB5_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB5_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB5_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	EXT  ID25 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID25 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID25 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB10_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB10_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB10_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB16_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB16_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB16_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB16_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB25_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB25_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB25_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB5_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB5_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB5_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB5_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_3 MB10_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB10_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB10_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB10_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB17_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB17_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB17_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB17_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB17_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB17_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB17_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB17_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB17_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB25_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB25_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB25_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB25_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_43 MB5_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB5_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB5_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB5_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_3 WORD025 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD025 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD025 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD025 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB10_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB10_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB10_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB10_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB17_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB17_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB17_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB25_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB25_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB25_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB25_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_47 MB5_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB5_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB5_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB5_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 WORD125 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD125 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD125 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD125 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS26 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS26 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS26 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS26 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS26 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS26 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS26 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS26 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS26 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB10_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB10_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB10_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB10_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB17_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB17_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB17_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB17_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB26_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB26_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB26_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB26_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB26_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB26_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB26_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB26_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB26_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB5_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB5_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB5_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB5_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	EXT  ID26 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID26 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID26 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB10_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB10_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB10_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB10_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB17_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB17_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB17_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB17_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB26_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB26_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB26_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_55 MB5_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB5_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB5_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB5_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_19 MB10_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB10_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB10_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB10_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB17_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB17_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB17_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB17_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB26_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB26_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB26_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB26_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_59 MB5_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB5_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB5_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB5_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_3 WORD026 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD026 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD026 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD026 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_23 MB10_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB10_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB10_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB10_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB17_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB17_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB17_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB17_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB26_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB26_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB26_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB26_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_63 MB5_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB5_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB5_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB5_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_7 WORD126 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD126 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD126 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD126 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS27 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS27 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS27 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS27 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS27 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS27 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS27 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS27 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS27 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB10_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB10_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB10_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB10_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB18_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB18_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB18_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB18_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB18_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB18_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB18_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB18_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB18_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB27_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB27_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB27_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB27_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB27_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB27_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB27_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB27_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB27_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB6_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB6_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB6_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB6_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB6_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB6_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB6_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB6_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB6_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID27 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID27 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID27 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB10_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB10_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB10_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB10_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB18_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB18_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB18_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB27_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB27_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB27_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB6_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB6_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB6_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB11_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB11_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB11_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB11_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB11_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB11_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB11_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB11_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB11_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB18_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB18_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB18_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB18_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB27_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB27_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB27_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB27_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB6_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB6_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB6_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB6_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD027 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD027 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD027 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD027 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB11_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB11_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB11_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB18_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB18_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB18_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB18_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB27_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB27_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB27_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB27_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB6_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB6_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB6_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB6_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD127 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD127 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD127 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD127 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_11 MB18_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB18_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB18_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB18_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB11_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB11_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB11_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB11_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP CS28 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS28 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS28 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS28 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS28 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS28 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS28 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS28 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS28 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB28_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB28_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB28_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB28_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB28_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB28_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB28_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB28_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB28_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB6_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB6_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB6_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB6_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	EXT  ID28 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID28 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID28 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB11_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB11_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB11_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB11_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB18_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB18_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB18_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB18_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB6_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB6_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB6_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB6_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB28_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB28_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB28_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB11_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB11_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB11_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB11_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB19_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB19_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB19_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB19_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB19_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB19_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB19_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB19_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB19_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB28_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB28_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB28_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB28_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB6_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB6_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB6_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB6_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 WORD028 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD028 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD028 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD028 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB11_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB11_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB11_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB11_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB19_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB19_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB19_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB28_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB28_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB28_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB28_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB6_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB6_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB6_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB6_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 WORD128 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD128 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD128 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD128 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_27 MB6_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB6_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB6_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB6_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_19 MB11_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB11_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB11_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB11_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB19_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB19_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB19_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB19_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB29_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB29_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB29_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB29_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB29_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB29_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB29_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB29_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB29_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS29 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS29 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS29 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS29 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS29 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS29 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS29 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS29 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS29 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_31 MB6_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB6_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB6_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB6_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  ID29 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID29 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID29 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB19_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB19_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB19_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB19_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB29_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB29_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB29_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB11_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB11_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB11_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB11_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_27 MB11_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB11_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB11_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB11_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB19_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB19_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB19_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB19_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB29_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB29_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB29_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB29_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_35 MB6_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB6_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB6_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB6_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_3 WORD029 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD029 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD029 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD029 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB11_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB11_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB11_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB11_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB19_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB19_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB19_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB19_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB29_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB29_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB29_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB29_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD129 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD129 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD129 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD129 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_39 MB6_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB6_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB6_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB6_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	TIME_STAMP CS30 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS30 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS30 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS30 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS30 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS30 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS30 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS30 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS30 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB12_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB12_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB12_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB12_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB12_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB12_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB12_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB12_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB12_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB20_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB20_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB20_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB20_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB20_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB20_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB20_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB20_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB20_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB30_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB30_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB30_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB30_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB30_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB30_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB30_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB30_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB30_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB6_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB6_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB6_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB6_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	EXT  ID30 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID30 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID30 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB12_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB12_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB12_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB20_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB20_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB20_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB30_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB30_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB30_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB6_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB6_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB6_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB6_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_51 MB6_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB6_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB6_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB6_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 MB20_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB20_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB20_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB20_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB30_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB30_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB30_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB30_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD030 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD030 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD030 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD030 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB12_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB12_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB12_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB12_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB12_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB12_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB12_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB12_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB20_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB20_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB20_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB20_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB30_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB30_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB30_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB30_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_55 MB6_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB6_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB6_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB6_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_7 WORD130 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD130 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD130 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD130 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS31 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS31 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS31 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS31 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS31 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS31 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS31 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS31 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS31 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB20_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB20_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB20_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB20_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB31_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB31_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB31_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB31_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB31_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB31_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB31_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB31_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB31_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB6_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB6_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB6_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB6_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_11 MB12_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB12_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB12_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB12_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	EXT  MB31_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB31_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB31_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB6_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB6_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB6_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB6_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_15 MB12_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB12_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB12_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB12_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB20_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB20_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB20_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB20_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  ID31 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID31 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID31 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB21_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB21_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB21_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB21_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB21_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB21_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB21_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB21_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB21_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB31_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB31_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB31_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB31_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB7_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB7_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB7_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB7_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB7_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB7_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB7_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB7_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB7_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD031 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD031 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD031 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD031 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB12_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB12_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB12_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB12_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_7 WORD131 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD131 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD131 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD131 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB12_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB12_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB12_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB12_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB21_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB21_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB21_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB7_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB7_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB7_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB31_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB31_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB31_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB31_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS32 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS32 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS32 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS32 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS32 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS32 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS32 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS32 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS32 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB12_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB12_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB12_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB12_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB21_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB21_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB21_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB21_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB32_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB32_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB32_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB32_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB32_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB32_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB32_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB32_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB32_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB7_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB7_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB7_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB7_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB7_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB7_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB7_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB7_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  ID32 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID32 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID32 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB21_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB21_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB21_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB21_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB32_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB32_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB32_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB12_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB12_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB12_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB12_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	TIME_STAMP MB13_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB13_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB13_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB13_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB13_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB13_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB13_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB13_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB13_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB21_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB21_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB21_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB21_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB32_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB32_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB32_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB32_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB7_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB7_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB7_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB7_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD032 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD032 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD032 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD032 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB13_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB13_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB13_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB21_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB21_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB21_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB21_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB32_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB32_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB32_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB32_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB7_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB7_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB7_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB7_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD132 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD132 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD132 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD132 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_19 MB7_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB7_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB7_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB7_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB13_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB13_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB13_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB13_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP CS33 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS33 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS33 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS33 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS33 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS33 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS33 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS33 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS33 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB33_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB33_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB33_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB33_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB33_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB33_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB33_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB33_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB33_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB22_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB22_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB22_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB22_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB22_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB22_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB22_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB22_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB22_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID33 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID33 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID33 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB13_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB13_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB13_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB13_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB22_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB22_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB22_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB33_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB33_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB33_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB7_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB7_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB7_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB7_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_3 MB33_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB33_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB33_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB33_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB22_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB22_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB22_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB22_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB13_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB13_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB13_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB13_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_27 MB7_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB7_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB7_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB7_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 WORD033 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD033 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD033 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD033 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB13_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB13_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB13_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB13_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB22_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB22_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB22_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB22_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB33_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB33_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB33_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB33_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB7_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB7_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB7_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB7_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 WORD133 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD133 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD133 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD133 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_19 MB13_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB13_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB13_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB13_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB22_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB22_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB22_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB22_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB34_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB34_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB34_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB34_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB34_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB34_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB34_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB34_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB34_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB7_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB7_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB7_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB7_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	TIME_STAMP CS34 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS34 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS34 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS34 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS34 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS34 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS34 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS34 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS34 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB34_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB34_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB34_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB7_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB7_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB7_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB7_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_23 MB13_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB13_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB13_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB13_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB22_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB22_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB22_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB22_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  ID34 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID34 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID34 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_43 MB7_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB7_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB7_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB7_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_3 WORD034 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD034 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD034 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD034 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB23_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB23_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB23_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB23_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB23_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB23_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB23_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB23_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB23_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB34_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB34_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB34_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB34_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB13_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB13_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB13_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB13_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_31 MB13_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB13_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB13_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB13_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB23_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB23_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB23_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB34_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB34_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB34_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB34_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_47 MB7_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB7_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB7_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB7_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 WORD134 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD134 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD134 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD134 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS35 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS35 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS35 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS35 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS35 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS35 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS35 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS35 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS35 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB14_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB14_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB14_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB14_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB14_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB14_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB14_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB14_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB14_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB23_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB23_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB23_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB23_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB35_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB35_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB35_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB35_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB35_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB35_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB35_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB35_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB35_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB7_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB7_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB7_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB7_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_55 MB7_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB7_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB7_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB7_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	EXT  ID35 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID35 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID35 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB14_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB14_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB14_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB35_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB35_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB35_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB23_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB23_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB23_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB23_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_3 MB14_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB14_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB14_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB14_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB23_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB23_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB23_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB23_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB35_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB35_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB35_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB35_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_59 MB7_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB7_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB7_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB7_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_3 WORD035 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD035 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD035 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD035 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB14_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB14_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB14_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB14_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB23_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB23_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB23_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB23_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB35_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB35_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB35_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB35_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_63 MB7_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB7_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB7_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB7_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_7 WORD135 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD135 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD135 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD135 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS36 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS36 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS36 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS36 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS36 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS36 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS36 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS36 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS36 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB14_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB14_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB14_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB14_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB24_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB24_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB24_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB24_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB24_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB24_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB24_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB24_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB24_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB36_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB36_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB36_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB36_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB36_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB36_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB36_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB36_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB36_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB8_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB8_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB8_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB8_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB8_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB8_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB8_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB8_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB8_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID36 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID36 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID36 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB14_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB14_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB14_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB14_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB24_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB24_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB24_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB36_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB36_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB36_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB8_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB8_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB8_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 WORD036 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD036 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD036 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD036 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB24_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB24_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB24_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB24_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB14_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB14_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB14_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB14_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB8_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB8_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB8_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB8_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB36_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB36_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB36_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB36_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_23 MB14_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB14_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB14_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB14_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB24_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB24_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB24_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB24_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB36_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB36_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB36_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB36_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB8_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB8_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB8_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB8_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD136 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD136 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD136 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD136 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS37 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS37 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS37 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS37 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS37 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS37 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS37 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS37 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS37 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB14_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB14_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB14_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB14_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB8_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB8_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB8_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB8_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB37_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB37_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB37_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB37_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB37_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB37_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB37_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB37_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB37_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB24_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB24_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB24_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB24_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_31 MB14_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB14_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB14_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB14_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB24_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB24_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB24_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB24_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB37_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB37_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB37_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB8_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB8_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB8_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB8_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  ID37 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID37 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID37 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB15_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB15_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB15_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB15_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB15_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB15_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB15_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB15_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB15_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB25_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB25_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB25_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB25_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB25_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB25_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB25_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB25_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB25_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB37_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB37_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB37_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB37_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB8_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB8_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB8_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB8_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 WORD037 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD037 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD037 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD037 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD137 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD137 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD137 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD137 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB25_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB25_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB25_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB15_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB15_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB15_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB8_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB8_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB8_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB8_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB37_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB37_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB37_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB37_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS38 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS38 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS38 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS38 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS38 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS38 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS38 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS38 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS38 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB15_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB15_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB15_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB15_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB25_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB25_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB25_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB25_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB38_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB38_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB38_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB38_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB38_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB38_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB38_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB38_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB38_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB8_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB8_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB8_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB8_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	EXT  ID38 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID38 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID38 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB8_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB8_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB8_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB8_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB15_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB15_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB15_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB15_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB38_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB38_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB38_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB25_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB25_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB25_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB25_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_11 MB15_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB15_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB15_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB15_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB25_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB25_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB25_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB25_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB38_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB38_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB38_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB38_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_35 MB8_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB8_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB8_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB8_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_3 WORD038 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD038 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD038 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD038 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB15_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB15_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB15_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB15_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB25_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB25_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB25_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB25_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB38_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB38_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB38_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB38_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD138 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD138 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD138 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD138 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_39 MB8_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB8_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB8_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB8_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	TIME_STAMP MB39_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB39_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB39_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB39_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB39_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB39_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB39_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB39_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB39_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS39 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS39 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS39 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS39 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS39 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS39 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS39 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS39 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS39 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB15_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB15_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB15_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB15_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_43 MB8_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB8_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB8_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB8_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP MB26_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB26_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB26_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB26_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB26_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB26_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB26_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB26_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB26_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB39_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB39_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB39_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID39 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID39 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID39 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB15_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB15_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB15_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB15_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB26_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB26_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB26_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB8_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB8_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB8_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB8_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_27 MB15_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB15_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB15_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB15_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB26_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB26_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB26_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB26_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB39_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB39_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB39_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB39_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_51 MB8_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB8_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB8_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB8_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 WORD039 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD039 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD039 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD039 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB15_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB15_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB15_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB15_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB26_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB26_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB26_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB26_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB39_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB39_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB39_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB39_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_55 MB8_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB8_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB8_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB8_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_7 WORD139 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD139 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD139 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD139 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS40 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS40 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS40 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS40 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS40 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS40 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS40 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS40 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS40 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB16_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB16_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB16_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB16_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB16_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB16_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB16_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB16_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB16_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB26_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB26_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB26_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB26_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB40_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB40_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB40_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB40_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB40_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB40_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB40_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB40_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB40_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB8_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB8_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB8_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB8_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	EXT  ID40 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID40 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID40 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB16_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB16_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB16_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB26_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB26_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB26_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB26_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB40_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB40_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB40_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB8_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB8_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB8_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB8_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_3 MB16_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB16_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB16_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB16_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB27_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB27_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB27_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB27_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB27_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB27_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB27_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB27_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB27_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB40_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB40_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB40_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB40_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB9_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB9_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB9_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB9_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB9_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB9_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB9_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB9_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB9_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD040 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD040 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD040 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD040 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB16_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB16_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB16_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB16_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB27_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB27_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB27_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB40_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB40_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB40_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB40_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB9_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB9_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB9_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD140 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD140 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD140 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD140 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS41 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS41 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS41 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS41 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS41 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS41 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS41 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS41 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS41 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB16_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB16_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB16_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB16_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB27_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB27_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB27_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB27_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB41_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB41_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB41_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB41_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB41_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB41_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB41_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB41_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB41_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB9_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB9_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB9_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB9_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  ID41 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID41 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID41 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB16_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB16_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB16_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB16_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB27_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB27_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB27_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB27_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB41_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB41_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB41_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB9_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB9_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB9_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB9_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_19 MB16_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB16_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB16_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB16_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB27_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB27_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB27_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB27_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB41_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB41_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB41_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB41_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB9_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB9_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB9_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB9_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD041 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD041 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD041 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD041 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_23 MB16_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB16_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB16_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB16_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB27_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB27_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB27_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB27_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB41_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB41_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB41_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB41_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB9_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB9_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB9_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB9_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD141 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD141 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD141 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD141 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS42 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS42 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS42 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS42 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS42 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS42 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS42 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS42 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS42 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB16_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB16_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB16_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB16_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB28_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB28_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB28_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB28_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB28_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB28_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB28_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB28_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB28_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB42_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB42_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB42_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB42_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB42_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB42_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB42_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB42_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB42_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB9_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB9_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB9_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB9_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	EXT  ID42 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID42 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID42 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB16_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB16_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB16_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB16_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB28_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB28_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB28_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB42_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB42_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB42_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB9_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB9_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB9_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB9_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	TIME_STAMP MB17_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB17_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB17_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB17_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB17_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB17_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB17_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB17_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB17_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB28_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB28_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB28_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB28_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB42_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB42_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB42_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB42_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB9_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB9_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB9_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB9_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 WORD042 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD042 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD042 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD042 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	EXT  MB17_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB17_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB17_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB28_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB28_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB28_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB28_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB42_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB42_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB42_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB42_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB9_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB9_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB9_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB9_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 WORD142 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD142 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD142 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD142 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS43 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS43 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS43 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS43 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS43 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS43 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS43 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS43 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS43 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB17_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB17_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB17_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB17_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB28_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB28_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB28_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB28_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB43_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB43_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB43_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB43_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB43_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB43_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB43_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB43_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB43_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB9_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB9_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB9_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB9_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	EXT  ID43 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID43 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID43 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB17_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB17_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB17_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB17_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB28_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB28_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB28_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB28_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB43_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB43_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB43_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB9_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB9_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB9_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB9_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	TIME_STAMP MB29_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB29_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB29_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB29_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB29_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB29_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB29_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB29_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB29_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB43_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB43_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB43_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB43_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_43 MB9_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB9_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB9_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB9_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_3 WORD043 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD043 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD043 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD043 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB17_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB17_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB17_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB17_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_7 WORD143 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD143 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD143 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD143 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB17_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB17_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB17_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB17_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB29_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB29_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB29_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB9_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB9_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB9_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB9_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 MB43_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB43_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB43_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB43_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS44 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS44 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS44 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS44 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS44 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS44 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS44 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS44 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS44 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB17_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB17_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB17_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB17_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB29_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB29_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB29_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB29_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB44_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB44_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB44_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB44_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB44_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB44_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB44_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB44_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB44_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB9_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB9_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB9_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB9_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_55 MB9_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB9_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB9_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB9_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_23 MB17_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB17_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB17_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB17_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB29_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB29_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB29_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB29_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB44_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB44_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB44_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID44 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID44 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID44 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_27 MB17_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB17_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB17_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB17_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB29_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB29_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB29_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB29_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB44_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB44_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB44_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB44_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_59 MB9_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB9_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB9_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB9_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_3 WORD044 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD044 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD044 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD044 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB17_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB17_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB17_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB17_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB29_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB29_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB29_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB29_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB44_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB44_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB44_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB44_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_63 MB9_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB9_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB9_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB9_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_7 WORD144 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD144 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD144 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD144 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB45_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB45_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB45_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB45_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB45_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB45_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB45_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB45_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB45_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB10_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB10_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB10_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB10_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB10_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB10_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB10_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB10_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB10_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB18_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB18_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB18_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB18_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB18_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB18_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB18_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB18_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB18_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB30_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB30_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB30_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB30_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB30_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB30_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB30_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB30_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB30_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS45 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS45 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS45 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS45 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS45 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS45 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS45 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS45 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS45 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB45_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB45_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB45_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB10_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB10_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB10_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB18_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB18_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB18_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB30_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB30_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB30_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID45 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID45 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID45 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB10_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB10_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB10_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB10_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB18_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB18_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB18_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB18_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB30_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB30_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB30_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB30_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB45_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB45_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB45_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB45_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD045 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD045 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD045 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD045 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD145 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD145 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD145 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD145 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB18_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB18_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB18_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB18_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB10_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB10_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB10_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB10_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB45_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB45_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB45_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB45_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB30_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB30_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB30_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB30_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS46 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS46 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS46 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS46 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS46 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS46 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS46 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS46 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS46 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB10_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB10_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB10_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB10_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB18_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB18_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB18_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB18_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB30_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB30_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB30_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB30_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB46_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB46_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB46_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB46_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB46_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB46_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB46_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB46_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB46_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID46 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID46 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID46 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB10_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB10_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB10_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB10_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB46_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB46_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB46_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB30_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB30_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB30_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB30_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB18_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB18_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB18_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB18_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_19 MB18_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB18_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB18_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB18_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB31_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB31_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB31_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB31_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB31_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB31_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB31_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB31_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB31_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB46_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB46_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB46_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB46_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD046 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD046 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD046 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD046 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB10_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB10_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB10_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB10_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_7 WORD146 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD146 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD146 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD146 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB10_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB10_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB10_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB10_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_23 MB18_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB18_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB18_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB18_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB31_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB31_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB31_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB46_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB46_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB46_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB46_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS47 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS47 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS47 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS47 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS47 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS47 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS47 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS47 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS47 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB10_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB10_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB10_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB10_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_27 MB18_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB18_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB18_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB18_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB31_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB31_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB31_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB31_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB47_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB47_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB47_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB47_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB47_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB47_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB47_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB47_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB47_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID47 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID47 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID47 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_31 MB10_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB10_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB10_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB10_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_31 MB18_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB18_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB18_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB18_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB31_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB31_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB31_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB31_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB47_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB47_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB47_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB19_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB19_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB19_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB19_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB19_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB19_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB19_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB19_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB19_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB31_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB31_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB31_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB31_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB47_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB47_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB47_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB47_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD047 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD047 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD047 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD047 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_35 MB10_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB10_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB10_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB10_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_7 WORD147 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD147 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD147 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD147 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_39 MB10_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB10_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB10_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB10_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	EXT  MB19_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB19_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB19_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB47_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB47_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB47_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB47_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB31_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB31_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB31_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB31_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	TIME_STAMP CS48 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS48 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS48 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS48 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS48 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS48 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS48 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS48 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS48 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB10_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB10_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB10_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB10_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	DATA_BYTE_3 MB19_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB19_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB19_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB19_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB32_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB32_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB32_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB32_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB32_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB32_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB32_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB32_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB32_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB48_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB48_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB48_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB48_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB48_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB48_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB48_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB48_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB48_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB48_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB48_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB48_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB10_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB10_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB10_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB10_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 MB19_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB19_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB19_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB19_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB32_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB32_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB32_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID48 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID48 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID48 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_51 MB10_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB10_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB10_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB10_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_11 MB19_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB19_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB19_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB19_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB32_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB32_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB32_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB32_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB48_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB48_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB48_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB48_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD048 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD048 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD048 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD048 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_55 MB10_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB10_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB10_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB10_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_15 MB19_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB19_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB19_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB19_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB32_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB32_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB32_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB32_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB48_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB48_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB48_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB48_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD148 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD148 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD148 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD148 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB49_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB49_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB49_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB49_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB49_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB49_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB49_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB49_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB49_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB10_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB10_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB10_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB10_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_19 MB19_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB19_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB19_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB19_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB32_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB32_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB32_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB32_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP CS49 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS49 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS49 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS49 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS49 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS49 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS49 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS49 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS49 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_63 MB10_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB10_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB10_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB10_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_23 MB19_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB19_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB19_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB19_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB32_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB32_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB32_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB32_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB49_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB49_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB49_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID49 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID49 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID49 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB11_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB11_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB11_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB11_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB11_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB11_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB11_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB11_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB11_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB19_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB19_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB19_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB19_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	TIME_STAMP MB33_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB33_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB33_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB33_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB33_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB33_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB33_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB33_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB33_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB49_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB49_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB49_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB49_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD049 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD049 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD049 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD049 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD149 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD149 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD149 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD149 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB19_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB19_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB19_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB19_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB33_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB33_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB33_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB49_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB49_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB49_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB49_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB11_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB11_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB11_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP CS50 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS50 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS50 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS50 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS50 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS50 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS50 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS50 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS50 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB11_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB11_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB11_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB11_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB20_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB20_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB20_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB20_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB20_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB20_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB20_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB20_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB20_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB33_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB33_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB33_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB33_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB50_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB50_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB50_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB50_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB50_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB50_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB50_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB50_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB50_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB50_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB50_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB50_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB11_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB11_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB11_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB11_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  ID50 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID50 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID50 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB33_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB33_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB33_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB33_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB20_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB20_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB20_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB11_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB11_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB11_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB11_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB20_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB20_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB20_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB20_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB33_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB33_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB33_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB33_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB50_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB50_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB50_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB50_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD050 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD050 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD050 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD050 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_15 MB11_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB11_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB11_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB11_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB20_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB20_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB20_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB20_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB33_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB33_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB33_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB33_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 WORD150 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD150 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD150 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD150 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB50_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB50_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB50_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB50_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS51 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS51 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS51 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS51 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS51 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS51 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS51 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS51 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS51 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB11_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB11_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB11_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB11_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB20_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB20_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB20_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB20_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB34_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB34_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB34_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB34_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB34_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB34_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB34_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB34_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB34_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB51_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB51_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB51_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB51_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB51_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB51_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB51_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB51_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB51_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID51 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID51 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID51 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB11_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB11_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB11_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB11_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB20_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB20_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB20_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB20_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB34_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB34_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB34_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB51_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB51_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB51_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_27 MB11_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB11_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB11_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB11_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_19 MB20_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB20_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB20_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB20_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB34_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB34_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB34_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB34_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB51_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB51_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB51_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB51_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD051 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD051 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD051 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD051 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_31 MB11_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB11_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB11_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB11_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_23 MB20_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB20_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB20_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB20_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB34_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB34_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB34_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB34_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB51_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB51_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB51_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB51_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD151 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD151 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD151 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD151 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS52 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS52 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS52 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS52 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS52 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS52 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS52 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS52 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS52 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB11_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB11_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB11_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB11_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_27 MB20_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB20_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB20_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB20_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB34_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB34_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB34_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB34_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB52_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB52_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB52_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB52_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB52_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB52_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB52_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB52_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB52_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID52 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID52 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID52 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB11_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB11_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB11_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB11_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_31 MB20_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB20_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB20_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB20_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB34_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB34_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB34_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB34_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB52_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB52_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB52_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_43 MB11_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB11_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB11_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB11_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP MB21_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB21_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB21_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB21_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB21_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB21_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB21_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB21_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB21_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB35_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB35_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB35_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB35_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB35_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB35_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB35_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB35_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB35_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB52_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB52_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB52_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB52_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD052 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD052 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD052 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD052 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_47 MB11_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB11_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB11_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB11_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	EXT  MB21_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB21_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB21_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB35_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB35_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB35_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB52_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB52_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB52_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB52_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD152 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD152 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD152 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD152 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS53 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS53 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS53 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS53 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS53 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS53 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS53 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS53 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS53 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB11_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB11_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB11_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB11_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 MB21_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB21_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB21_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB21_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB35_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB35_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB35_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB35_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB53_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB53_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB53_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB53_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB53_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB53_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB53_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB53_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB53_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID53 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID53 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID53 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_55 MB11_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB11_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB11_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB11_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_7 MB21_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB21_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB21_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB21_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB35_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB35_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB35_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB35_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB53_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB53_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB53_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_59 MB11_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB11_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB11_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB11_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_11 MB21_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB21_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB21_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB21_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_11 MB35_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB35_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB35_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB35_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB53_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB53_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB53_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB53_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD053 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD053 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD053 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD053 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_63 MB11_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB11_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB11_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB11_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_15 MB21_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB21_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB21_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB21_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB35_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB35_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB35_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB35_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB53_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB53_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB53_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB53_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD153 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD153 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD153 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD153 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB54_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB54_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB54_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB54_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB54_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB54_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB54_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB54_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB54_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB12_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB12_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB12_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB12_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB12_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB12_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB12_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB12_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB12_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB21_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB21_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB21_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB21_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB36_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB36_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB36_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB36_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB36_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB36_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB36_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB36_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB36_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS54 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS54 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS54 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS54 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS54 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS54 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS54 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS54 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS54 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID54 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID54 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID54 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB12_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB12_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB12_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_23 MB21_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB21_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB21_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB21_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB36_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB36_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB36_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB54_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB54_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB54_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 WORD054 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD054 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD054 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD054 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB21_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB21_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB21_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB21_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_3 MB36_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB36_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB36_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB36_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB54_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB54_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB54_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB54_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB12_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB12_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB12_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB12_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 MB12_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB12_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB12_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB12_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB21_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB21_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB21_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB21_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB36_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB36_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB36_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB36_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB54_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB54_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB54_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB54_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD154 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD154 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD154 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD154 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB22_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB22_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB22_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB22_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB22_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB22_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB22_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB22_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB22_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB12_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB12_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB12_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB12_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP CS55 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS55 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS55 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS55 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS55 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS55 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS55 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS55 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS55 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB36_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB36_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB36_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB36_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB55_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB55_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB55_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB55_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB55_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB55_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB55_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB55_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB55_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID55 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID55 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID55 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB12_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB12_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB12_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB12_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB22_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB22_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB22_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB36_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB36_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB36_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB36_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB55_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB55_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB55_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB22_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB22_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB22_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB22_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB37_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB37_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB37_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB37_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB37_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB37_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB37_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB37_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB37_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB55_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB55_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB55_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB55_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD055 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD055 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD055 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD055 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB12_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB12_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB12_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB12_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_7 WORD155 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD155 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD155 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD155 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB12_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB12_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB12_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB12_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB22_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB22_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB22_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB22_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB55_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB55_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB55_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB55_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB37_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB37_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB37_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP CS56 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS56 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS56 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS56 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS56 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS56 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS56 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS56 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS56 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB12_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB12_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB12_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB12_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB22_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB22_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB22_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB22_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB37_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB37_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB37_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB37_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB56_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB56_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB56_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB56_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB56_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB56_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB56_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB56_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB56_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB56_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB56_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB56_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID56 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID56 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID56 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB22_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB22_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB22_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB22_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB37_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB37_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB37_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB37_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB12_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB12_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB12_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB12_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_35 MB12_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB12_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB12_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB12_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_19 MB22_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB22_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB22_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB22_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_11 MB37_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB37_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB37_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB37_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB56_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB56_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB56_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB56_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD056 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD056 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD056 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD056 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_39 MB12_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB12_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB12_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB12_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_23 MB22_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB22_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB22_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB22_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_15 MB37_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB37_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB37_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB37_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB56_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB56_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB56_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB56_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD156 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD156 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD156 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD156 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP MB57_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB57_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB57_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB57_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB57_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB57_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB57_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB57_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB57_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_43 MB12_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB12_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB12_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB12_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP CS57 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS57 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS57 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS57 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS57 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS57 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS57 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS57 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS57 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB38_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB38_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB38_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB38_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB38_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB38_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB38_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB38_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB38_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_27 MB22_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB22_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB22_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB22_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	EXT  ID57 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID57 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID57 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_47 MB12_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB12_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB12_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB12_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_31 MB22_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB22_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB22_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB22_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	EXT  MB38_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB38_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB38_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB57_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB57_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB57_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB38_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB38_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB38_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB38_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB23_32B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB23_32B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB23_32B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB23_32B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB23_32B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB23_32B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB23_32B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB23_32B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB23_32B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB12_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB12_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB12_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB12_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 MB57_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB57_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB57_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB57_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD057 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD057 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD057 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD057 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_55 MB12_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB12_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB12_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB12_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	EXT  MB23_32B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB23_32B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB23_32B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB38_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB38_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB38_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB38_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB57_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB57_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB57_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB57_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD157 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD157 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD157 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD157 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS58 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS58 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS58 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS58 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS58 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS58 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS58 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS58 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS58 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_59 MB12_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB12_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB12_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB12_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_3 MB23_32B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB23_32B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB23_32B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB23_32B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB38_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB38_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB38_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB38_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB58_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB58_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB58_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB58_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB58_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB58_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB58_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB58_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB58_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID58 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID58 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID58 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_63 MB12_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB12_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB12_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB12_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	DATA_BYTE_7 MB23_32B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB23_32B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB23_32B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB23_32B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_15 MB38_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB38_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB38_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB38_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB58_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB58_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB58_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	TIME_STAMP MB13_64B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB13_64B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB13_64B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB13_64B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB13_64B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB13_64B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB13_64B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB13_64B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB13_64B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_11 MB23_32B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB23_32B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB23_32B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB23_32B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB58_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB58_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB58_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB58_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD058 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD058 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD058 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD058 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB39_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB39_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB39_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB39_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB39_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB39_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB39_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB39_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB39_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  MB13_64B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB13_64B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB13_64B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_15 MB23_32B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB23_32B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB23_32B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB23_32B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB39_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB39_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB39_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB58_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB58_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB58_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB58_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD158 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD158 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD158 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD158 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS59 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS59 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS59 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS59 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS59 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS59 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS59 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS59 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS59 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 MB13_64B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB13_64B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB13_64B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB13_64B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_19 MB23_32B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB23_32B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB23_32B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB23_32B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	DATA_BYTE_3 MB39_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB39_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB39_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB39_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB59_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB59_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB59_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB59_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB59_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB59_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB59_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB59_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB59_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID59 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID59 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID59 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 MB13_64B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB13_64B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB13_64B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB13_64B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_23 MB23_32B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB23_32B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB23_32B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB23_32B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	DATA_BYTE_7 MB39_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB39_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB39_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB39_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB59_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB59_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB59_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_11 MB13_64B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB13_64B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB13_64B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB13_64B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_27 MB23_32B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB23_32B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB23_32B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB23_32B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_11 MB39_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB39_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB39_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB39_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 WORD059 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD059 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD059 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD059 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB59_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB59_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB59_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB59_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD159 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD159 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD159 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD159 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_31 MB23_32B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB23_32B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB23_32B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB23_32B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_15 MB39_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB39_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB39_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB39_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_15 MB13_64B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB13_64B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB13_64B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB13_64B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB59_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB59_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB59_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB59_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS60 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS60 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS60 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS60 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS60 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS60 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS60 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS60 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS60 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_19 MB13_64B_WORD4 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_18 MB13_64B_WORD4 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_17 MB13_64B_WORD4 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_16 MB13_64B_WORD4 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_19n = 0
	DATA_BYTE_18n = 8
	DATA_BYTE_17n = 16
	DATA_BYTE_16n = 24
)

const (
	TIME_STAMP MB40_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB40_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB40_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB40_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB40_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB40_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB40_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB40_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB40_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP MB60_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB60_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB60_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB60_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB60_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB60_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB60_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB60_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB60_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_23 MB13_64B_WORD5 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_22 MB13_64B_WORD5 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_21 MB13_64B_WORD5 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_20 MB13_64B_WORD5 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_23n = 0
	DATA_BYTE_22n = 8
	DATA_BYTE_21n = 16
	DATA_BYTE_20n = 24
)

const (
	EXT  MB40_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB40_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB40_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB60_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB60_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB60_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  ID60 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID60 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID60 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB60_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB60_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB60_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB60_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD060 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD060 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD060 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD060 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB40_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB40_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB40_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB40_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_27 MB13_64B_WORD6 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_26 MB13_64B_WORD6 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_25 MB13_64B_WORD6 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_24 MB13_64B_WORD6 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_27n = 0
	DATA_BYTE_26n = 8
	DATA_BYTE_25n = 16
	DATA_BYTE_24n = 24
)

const (
	DATA_BYTE_31 MB13_64B_WORD7 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_30 MB13_64B_WORD7 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_29 MB13_64B_WORD7 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_28 MB13_64B_WORD7 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_31n = 0
	DATA_BYTE_30n = 8
	DATA_BYTE_29n = 16
	DATA_BYTE_28n = 24
)

const (
	DATA_BYTE_7 MB40_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB40_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB40_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB40_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB60_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB60_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB60_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB60_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD160 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD160 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD160 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD160 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS61 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS61 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS61 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS61 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS61 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS61 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS61 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS61 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS61 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_35 MB13_64B_WORD8 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_34 MB13_64B_WORD8 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_33 MB13_64B_WORD8 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_32 MB13_64B_WORD8 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_35n = 0
	DATA_BYTE_34n = 8
	DATA_BYTE_33n = 16
	DATA_BYTE_32n = 24
)

const (
	DATA_BYTE_11 MB40_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB40_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB40_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB40_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	TIME_STAMP MB61_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB61_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB61_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB61_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB61_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB61_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB61_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB61_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB61_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID61 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID61 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID61 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_39 MB13_64B_WORD9 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_38 MB13_64B_WORD9 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_37 MB13_64B_WORD9 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_36 MB13_64B_WORD9 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_39n = 0
	DATA_BYTE_38n = 8
	DATA_BYTE_37n = 16
	DATA_BYTE_36n = 24
)

const (
	DATA_BYTE_15 MB40_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB40_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB40_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB40_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	EXT  MB61_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB61_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB61_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_43 MB13_64B_WORD10 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_42 MB13_64B_WORD10 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_41 MB13_64B_WORD10 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_40 MB13_64B_WORD10 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_43n = 0
	DATA_BYTE_42n = 8
	DATA_BYTE_41n = 16
	DATA_BYTE_40n = 24
)

const (
	TIME_STAMP MB41_16B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB41_16B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB41_16B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB41_16B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB41_16B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB41_16B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB41_16B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB41_16B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB41_16B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_3 WORD061 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD061 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD061 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD061 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 MB61_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB61_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB61_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB61_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_47 MB13_64B_WORD11 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_46 MB13_64B_WORD11 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_45 MB13_64B_WORD11 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_44 MB13_64B_WORD11 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_47n = 0
	DATA_BYTE_46n = 8
	DATA_BYTE_45n = 16
	DATA_BYTE_44n = 24
)

const (
	DATA_BYTE_7 MB61_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB61_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB61_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB61_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB41_16B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB41_16B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB41_16B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_7 WORD161 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD161 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD161 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD161 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	TIME_STAMP CS62 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS62 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS62 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS62 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS62 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS62 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS62 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS62 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS62 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	DATA_BYTE_51 MB13_64B_WORD12 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_50 MB13_64B_WORD12 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_49 MB13_64B_WORD12 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_48 MB13_64B_WORD12 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_51n = 0
	DATA_BYTE_50n = 8
	DATA_BYTE_49n = 16
	DATA_BYTE_48n = 24
)

const (
	DATA_BYTE_3 MB41_16B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB41_16B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB41_16B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB41_16B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	TIME_STAMP MB62_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB62_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB62_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB62_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB62_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB62_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB62_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB62_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB62_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID62 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID62 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID62 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_55 MB13_64B_WORD13 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_54 MB13_64B_WORD13 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_53 MB13_64B_WORD13 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_52 MB13_64B_WORD13 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_55n = 0
	DATA_BYTE_54n = 8
	DATA_BYTE_53n = 16
	DATA_BYTE_52n = 24
)

const (
	DATA_BYTE_7 MB41_16B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB41_16B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB41_16B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB41_16B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	EXT  MB62_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB62_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB62_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 WORD062 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD062 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD062 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD062 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_11 MB41_16B_WORD2 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_10 MB41_16B_WORD2 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_9  MB41_16B_WORD2 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_8  MB41_16B_WORD2 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_11n = 0
	DATA_BYTE_10n = 8
	DATA_BYTE_9n  = 16
	DATA_BYTE_8n  = 24
)

const (
	DATA_BYTE_3 MB62_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB62_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB62_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB62_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_59 MB13_64B_WORD14 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_58 MB13_64B_WORD14 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_57 MB13_64B_WORD14 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_56 MB13_64B_WORD14 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_59n = 0
	DATA_BYTE_58n = 8
	DATA_BYTE_57n = 16
	DATA_BYTE_56n = 24
)

const (
	DATA_BYTE_15 MB41_16B_WORD3 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_14 MB41_16B_WORD3 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_13 MB41_16B_WORD3 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_12 MB41_16B_WORD3 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_15n = 0
	DATA_BYTE_14n = 8
	DATA_BYTE_13n = 16
	DATA_BYTE_12n = 24
)

const (
	DATA_BYTE_7 MB62_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB62_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB62_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB62_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 WORD162 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD162 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD162 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD162 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_63 MB13_64B_WORD15 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_62 MB13_64B_WORD15 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_61 MB13_64B_WORD15 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_60 MB13_64B_WORD15 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_63n = 0
	DATA_BYTE_62n = 8
	DATA_BYTE_61n = 16
	DATA_BYTE_60n = 24
)

const (
	TIME_STAMP MB63_8B_CS = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        MB63_8B_CS = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        MB63_8B_CS = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        MB63_8B_CS = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        MB63_8B_CS = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       MB63_8B_CS = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        MB63_8B_CS = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        MB63_8B_CS = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        MB63_8B_CS = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	TIME_STAMP CS63 = 0xFFFF << 0 //+ Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
	DLC        CS63 = 0x0F << 16  //+ Length of the data to be stored/transmitted.
	RTR        CS63 = 0x01 << 20  //+ Remote Transmission Request. One/zero for remote/data frame.
	IDE        CS63 = 0x01 << 21  //+ ID Extended. One/zero for extended/standard format frame.
	SRR        CS63 = 0x01 << 22  //+ Substitute Remote Request. Contains a fixed recessive bit.
	CODE       CS63 = 0x0F << 24  //+ Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
	ESI        CS63 = 0x01 << 29  //+ Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
	BRS        CS63 = 0x01 << 30  //+ Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
	EDL        CS63 = 0x01 << 31  //+ Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
)

const (
	TIME_STAMPn = 0
	DLCn        = 16
	RTRn        = 20
	IDEn        = 21
	SRRn        = 22
	CODEn       = 24
	ESIn        = 29
	BRSn        = 30
	EDLn        = 31
)

const (
	EXT  ID63 = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  ID63 = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO ID63 = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	EXT  MB63_8B_ID = 0x3FFFF << 0 //+ Contains extended (LOW word) identifier of message buffer.
	STD  MB63_8B_ID = 0x7FF << 18  //+ Contains standard/extended (HIGH word) identifier of message buffer.
	PRIO MB63_8B_ID = 0x07 << 29   //+ Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
)

const (
	EXTn  = 0
	STDn  = 18
	PRIOn = 29
)

const (
	DATA_BYTE_3 MB63_8B_WORD0 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 MB63_8B_WORD0 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 MB63_8B_WORD0 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 MB63_8B_WORD0 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_3 WORD063 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_2 WORD063 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_1 WORD063 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_0 WORD063 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_3n = 0
	DATA_BYTE_2n = 8
	DATA_BYTE_1n = 16
	DATA_BYTE_0n = 24
)

const (
	DATA_BYTE_7 WORD163 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 WORD163 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 WORD163 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 WORD163 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	DATA_BYTE_7 MB63_8B_WORD1 = 0xFF << 0  //+ Data byte 0 of Rx/Tx frame.
	DATA_BYTE_6 MB63_8B_WORD1 = 0xFF << 8  //+ Data byte 1 of Rx/Tx frame.
	DATA_BYTE_5 MB63_8B_WORD1 = 0xFF << 16 //+ Data byte 2 of Rx/Tx frame.
	DATA_BYTE_4 MB63_8B_WORD1 = 0xFF << 24 //+ Data byte 3 of Rx/Tx frame.
)

const (
	DATA_BYTE_7n = 0
	DATA_BYTE_6n = 8
	DATA_BYTE_5n = 16
	DATA_BYTE_4n = 24
)

const (
	MI RXIMR = 0xFFFFFFFF << 0 //+ Individual Mask Bits
)

const (
	MIn = 0
)

const (
	ENPRESDIV EPRS = 0x3FF << 0  //+ Extended Nominal Prescaler Division Factor
	EDPRESDIV EPRS = 0x3FF << 16 //+ Extended Data Phase Prescaler Division Factor
)

const (
	ENPRESDIVn = 0
	EDPRESDIVn = 16
)

const (
	NTSEG1 ENCBT = 0xFF << 0  //+ Nominal Time Segment 1
	NTSEG2 ENCBT = 0x7F << 12 //+ Nominal Time Segment 2
	NRJW   ENCBT = 0x7F << 22 //+ Nominal Resynchronization Jump Width
)

const (
	NTSEG1n = 0
	NTSEG2n = 12
	NRJWn   = 22
)

const (
	DTSEG1 EDCBT = 0x1F << 0  //+ Data Phase Segment 1
	DTSEG2 EDCBT = 0x0F << 12 //+ Data Phase Time Segment 2
	DRJW   EDCBT = 0x0F << 22 //+ Data Phase Resynchronization Jump Width
)

const (
	DTSEG1n = 0
	DTSEG2n = 12
	DRJWn   = 22
)

const (
	ETDCVAL ETDC = 0xFF << 0  //+ Enhanced Transceiver Delay Compensation Value
	ETDCOFF ETDC = 0x7F << 16 //+ Enhanced Transceiver Delay Compensation Offset
	TDMDIS  ETDC = 0x01 << 31 //+ Transceiver Delay Measurement Disable
)

const (
	ETDCVALn = 0
	ETDCOFFn = 16
	TDMDISn  = 31
)

const (
	TDCVAL   FDCTRL = 0x3F << 0  //+ Transceiver Delay Compensation Value
	TDCOFF   FDCTRL = 0x1F << 8  //+ Transceiver Delay Compensation Offset
	TDCFAIL  FDCTRL = 0x01 << 14 //+ Transceiver Delay Compensation Fail
	TDCEN    FDCTRL = 0x01 << 15 //+ Transceiver Delay Compensation Enable
	MBDSR0   FDCTRL = 0x03 << 16 //+ Message Buffer Data Size for Region 0
	MBDSR0_0 FDCTRL = 0x00 << 16 //  Selects 8 bytes per Message Buffer.
	MBDSR0_1 FDCTRL = 0x01 << 16 //  Selects 16 bytes per Message Buffer.
	MBDSR0_2 FDCTRL = 0x02 << 16 //  Selects 32 bytes per Message Buffer.
	MBDSR0_3 FDCTRL = 0x03 << 16 //  Selects 64 bytes per Message Buffer.
	MBDSR1   FDCTRL = 0x03 << 19 //+ Message Buffer Data Size for Region 1
	MBDSR1_0 FDCTRL = 0x00 << 19 //  Selects 8 bytes per Message Buffer.
	MBDSR1_1 FDCTRL = 0x01 << 19 //  Selects 16 bytes per Message Buffer.
	MBDSR1_2 FDCTRL = 0x02 << 19 //  Selects 32 bytes per Message Buffer.
	MBDSR1_3 FDCTRL = 0x03 << 19 //  Selects 64 bytes per Message Buffer.
	FDRATE   FDCTRL = 0x01 << 31 //+ Bit Rate Switch Enable
)

const (
	TDCVALn  = 0
	TDCOFFn  = 8
	TDCFAILn = 14
	TDCENn   = 15
	MBDSR0n  = 16
	MBDSR1n  = 19
	FDRATEn  = 31
)

const (
	FPSEG2   FDCBT = 0x07 << 0   //+ Fast Phase Segment 2
	FPSEG1   FDCBT = 0x07 << 5   //+ Fast Phase Segment 1
	FPROPSEG FDCBT = 0x1F << 10  //+ Fast Propagation Segment
	FRJW     FDCBT = 0x07 << 16  //+ Fast Resync Jump Width
	FPRESDIV FDCBT = 0x3FF << 20 //+ Fast Prescaler Division Factor
)

const (
	FPSEG2n   = 0
	FPSEG1n   = 5
	FPROPSEGn = 10
	FRJWn     = 16
	FPRESDIVn = 20
)

const (
	FD_TXCRC FDCRC = 0x1FFFFF << 0 //+ Extended Transmitted CRC value
	FD_MBCRC FDCRC = 0x7F << 24    //+ CRC Mailbox Number for FD_TXCRC
)

const (
	FD_TXCRCn = 0
	FD_MBCRCn = 24
)

const (
	ERFWM ERFCR = 0x1F << 0  //+ Enhanced Rx FIFO Watermark
	NFE   ERFCR = 0x3F << 8  //+ Number of Enhanced Rx FIFO Filter Elements
	NEXIF ERFCR = 0x7F << 16 //+ Number of Extended ID Filter Elements
	DMALW ERFCR = 0x1F << 26 //+ DMA Last Word
	ERFEN ERFCR = 0x01 << 31 //+ Enhanced Rx FIFO enable
)

const (
	ERFWMn = 0
	NFEn   = 8
	NEXIFn = 16
	DMALWn = 26
	ERFENn = 31
)

const (
	ERFDAIE  ERFIER = 0x01 << 28 //+ Enhanced Rx FIFO Data Available Interrupt Enable
	ERFWMIIE ERFIER = 0x01 << 29 //+ Enhanced Rx FIFO Watermark Indication Interrupt Enable
	ERFOVFIE ERFIER = 0x01 << 30 //+ Enhanced Rx FIFO Overflow Interrupt Enable
	ERFUFWIE ERFIER = 0x01 << 31 //+ Enhanced Rx FIFO Underflow Interrupt Enable
)

const (
	ERFDAIEn  = 28
	ERFWMIIEn = 29
	ERFOVFIEn = 30
	ERFUFWIEn = 31
)

const (
	ERFEL  ERFSR = 0x3F << 0  //+ Enhanced Rx FIFO Elements
	ERFF   ERFSR = 0x01 << 16 //+ Enhanced Rx FIFO full
	ERFE   ERFSR = 0x01 << 17 //+ Enhanced Rx FIFO empty
	ERFCLR ERFSR = 0x01 << 27 //+ Enhanced Rx FIFO Clear
	ERFDA  ERFSR = 0x01 << 28 //+ Enhanced Rx FIFO Data Available
	ERFWMI ERFSR = 0x01 << 29 //+ Enhanced Rx FIFO Watermark Indication
	ERFOVF ERFSR = 0x01 << 30 //+ Enhanced Rx FIFO Overflow
	ERFUFW ERFSR = 0x01 << 31 //+ Enhanced Rx FIFO Underflow
)

const (
	ERFELn  = 0
	ERFFn   = 16
	ERFEn   = 17
	ERFCLRn = 27
	ERFDAn  = 28
	ERFWMIn = 29
	ERFOVFn = 30
	ERFUFWn = 31
)

const (
	TS HR_TIME_STAMP = 0xFFFFFFFF << 0 //+ High Resolution Time Stamp
)

const (
	TSn = 0
)

const (
	FEL ERFFEL = 0xFFFFFFFF << 0 //+ Filter Element Bits
)

const (
	FELn = 0
)
