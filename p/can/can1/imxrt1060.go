// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package can1 provides access to the registers of the CAN peripheral.
//
// Instances:
//
//	CAN1  CAN1_BASE  -  CAN1*  FLEXCAN
//	CAN2  CAN2_BASE  -  CAN2*  FLEXCAN
//
// Registers:
//
//	0x000 32  MCR        Module Configuration Register
//	0x004 32  CTRL1      Control 1 Register
//	0x008 32  TIMER      Free Running Timer Register
//	0x010 32  RXMGMASK   Rx Mailboxes Global Mask Register
//	0x014 32  RX14MASK   Rx Buffer 14 Mask Register
//	0x018 32  RX15MASK   Rx Buffer 15 Mask Register
//	0x01C 32  ECR        Error Counter Register
//	0x020 32  ESR1       Error and Status 1 Register
//	0x024 32  IMASK2     Interrupt Masks 2 Register
//	0x028 32  IMASK1     Interrupt Masks 1 Register
//	0x02C 32  IFLAG2     Interrupt Flags 2 Register
//	0x030 32  IFLAG1     Interrupt Flags 1 Register
//	0x034 32  CTRL2      Control 2 Register
//	0x038 32  ESR2       Error and Status 2 Register
//	0x044 32  CRCR       CRC Register
//	0x048 32  RXFGMASK   Rx FIFO Global Mask Register
//	0x04C 32  RXFIR      Rx FIFO Information Register
//	0x058 32  DBG1       Debug 1 register
//	0x05C 32  DBG2       Debug 2 register
//	0x880 32  RXIMR[64]  Rx Individual Mask Registers
//	0x9E0 32  GFWR       Glitch Filter Width Registers
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package can1

const (
	MAXMB   MCR = 0x7F << 0  //+ This 7-bit field defines the number of the last Message Buffers that will take part in the matching and arbitration processes
	IDAM    MCR = 0x03 << 8  //+ This 2-bit field identifies the format of the elements of the Rx FIFO filter table, as shown below
	IDAM_0  MCR = 0x00 << 8  //  Format A One full ID (standard or extended) per ID filter Table element.
	IDAM_1  MCR = 0x01 << 8  //  Format B Two full standard IDs or two partial 14-bit extended IDs per ID filter Table element.
	IDAM_2  MCR = 0x02 << 8  //  Format C Four partial 8-bit IDs (standard or extended) per ID filter Table element.
	IDAM_3  MCR = 0x03 << 8  //  Format D All frames rejected.
	AEN     MCR = 0x01 << 12 //+ This bit is supplied for backwards compatibility reasons
	LPRIOEN MCR = 0x01 << 13 //+ This bit is provided for backwards compatibility reasons
	IRMQ    MCR = 0x01 << 16 //+ This bit indicates whether Rx matching process will be based either on individual masking and queue or on masking scheme with RXMGMASK, RX14MASK and RX15MASK, RXFGMASK
	SRXDIS  MCR = 0x01 << 17 //+ This bit defines whether FlexCAN is allowed to receive frames transmitted by itself
	WAKSRC  MCR = 0x01 << 19 //+ This bit defines whether the integrated low-pass filter is applied to protect the FLEXCAN_RX input from spurious wake up
	LPMACK  MCR = 0x01 << 20 //+ This read-only bit indicates that FLEXCAN is either in Disable Mode or Stop Mode
	WRNEN   MCR = 0x01 << 21 //+ When asserted, this bit enables the generation of the TWRN_INT and RWRN_INT flags in the Error and Status Register
	SLFWAK  MCR = 0x01 << 22 //+ This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode
	SUPV    MCR = 0x01 << 23 //+ This bit configures some of the FLEXCAN registers to be either in Supervisor or User Mode
	FRZACK  MCR = 0x01 << 24 //+ This read-only bit indicates that FLEXCAN is in Freeze Mode and its prescaler is stopped
	SOFTRST MCR = 0x01 << 25 //+ When this bit is asserted, FlexCAN resets its internal state machines and some of the memory mapped registers
	WAKMSK  MCR = 0x01 << 26 //+ This bit enables the Wake Up Interrupt generation.
	NOTRDY  MCR = 0x01 << 27 //+ This read-only bit indicates that FLEXCAN is either in Disable Mode, Stop Mode or Freeze Mode
	HALT    MCR = 0x01 << 28 //+ Assertion of this bit puts the FLEXCAN module into Freeze Mode
	RFEN    MCR = 0x01 << 29 //+ This bit controls whether the Rx FIFO feature is enabled or not
	FRZ     MCR = 0x01 << 30 //+ The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MCR Register is set or when Debug Mode is requested at Arm level
	MDIS    MCR = 0x01 << 31 //+ This bit controls whether FLEXCAN is enabled or not
)

const (
	MAXMBn   = 0
	IDAMn    = 8
	AENn     = 12
	LPRIOENn = 13
	IRMQn    = 16
	SRXDISn  = 17
	WAKSRCn  = 19
	LPMACKn  = 20
	WRNENn   = 21
	SLFWAKn  = 22
	SUPVn    = 23
	FRZACKn  = 24
	SOFTRSTn = 25
	WAKMSKn  = 26
	NOTRDYn  = 27
	HALTn    = 28
	RFENn    = 29
	FRZn     = 30
	MDISn    = 31
)

const (
	PROPSEG CTRL1 = 0x07 << 0  //+ This 3-bit field defines the length of the Propagation Segment in the bit time
	LOM     CTRL1 = 0x01 << 3  //+ This bit configures FLEXCAN to operate in Listen Only Mode
	LBUF    CTRL1 = 0x01 << 4  //+ This bit defines the ordering mechanism for Message Buffer transmission
	TSYN    CTRL1 = 0x01 << 5  //+ This bit enables a mechanism that resets the free-running timer each time a message is received in Message Buffer 0
	BOFFREC CTRL1 = 0x01 << 6  //+ This bit defines how FLEXCAN recovers from Bus Off state
	SMP     CTRL1 = 0x01 << 7  //+ This bit defines the sampling mode of CAN bits at the FLEXCAN_RX
	RWRNMSK CTRL1 = 0x01 << 10 //+ This bit provides a mask for the Rx Warning Interrupt associated with the RWRN_INT flag in the Error and Status Register
	TWRNMSK CTRL1 = 0x01 << 11 //+ This bit provides a mask for the Tx Warning Interrupt associated with the TWRN_INT flag in the Error and Status Register
	LPB     CTRL1 = 0x01 << 12 //+ This bit configures FlexCAN to operate in Loop-Back Mode
	ERRMSK  CTRL1 = 0x01 << 14 //+ This bit provides a mask for the Error Interrupt.
	BOFFMSK CTRL1 = 0x01 << 15 //+ This bit provides a mask for the Bus Off Interrupt.
	PSEG2   CTRL1 = 0x07 << 16 //+ This 3-bit field defines the length of Phase Buffer Segment 2 in the bit time
	PSEG1   CTRL1 = 0x07 << 19 //+ This 3-bit field defines the length of Phase Buffer Segment 1 in the bit time
	RJW     CTRL1 = 0x03 << 22 //+ This 2-bit field defines the maximum number of time quanta One time quantum is equal to the Sclock period
	PRESDIV CTRL1 = 0xFF << 24 //+ This 8-bit field defines the ratio between the PE clock frequency and the Serial Clock (Sclock) frequency
)

const (
	PROPSEGn = 0
	LOMn     = 3
	LBUFn    = 4
	TSYNn    = 5
	BOFFRECn = 6
	SMPn     = 7
	RWRNMSKn = 10
	TWRNMSKn = 11
	LPBn     = 12
	ERRMSKn  = 14
	BOFFMSKn = 15
	PSEG2n   = 16
	PSEG1n   = 19
	RJWn     = 22
	PRESDIVn = 24
)

const (
	TIMER TIMER = 0xFFFF << 0 //+ TIMER
)

const (
	TIMERn = 0
)

const (
	MG   RXMGMASK = 0xFFFFFFFF << 0 //+ These bits mask the Mailbox filter bits as shown in the figure above
	MG_0 RXMGMASK = 0x00 << 0       //  the corresponding bit in the filter is "don't care"
	MG_1 RXMGMASK = 0x01 << 0       //  The corresponding bit in the filter is checked against the one received
)

const (
	MGn = 0
)

const (
	RX14M   RX14MASK = 0xFFFFFFFF << 0 //+ These bits mask Mailbox 14 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
	RX14M_0 RX14MASK = 0x00 << 0       //  the corresponding bit in the filter is "don't care"
	RX14M_1 RX14MASK = 0x01 << 0       //  The corresponding bit in the filter is checked
)

const (
	RX14Mn = 0
)

const (
	RX15M   RX15MASK = 0xFFFFFFFF << 0 //+ These bits mask Mailbox 15 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
	RX15M_0 RX15MASK = 0x00 << 0       //  the corresponding bit in the filter is "don't care"
	RX15M_1 RX15MASK = 0x01 << 0       //  The corresponding bit in the filter is checked
)

const (
	RX15Mn = 0
)

const (
	TX_ERR_COUNTER ECR = 0xFF << 0 //+ Tx_Err_Counter
	RX_ERR_COUNTER ECR = 0xFF << 8 //+ Rx_Err_Counter
)

const (
	TX_ERR_COUNTERn = 0
	RX_ERR_COUNTERn = 8
)

const (
	WAKINT    ESR1 = 0x01 << 0  //+ When FLEXCAN is Stop Mode and a recessive to dominant transition is detected on the CAN bus and if the WAK_MSK bit in the MCR Register is set, an interrupt is generated to the Arm
	ERRINT    ESR1 = 0x01 << 1  //+ This bit indicates that at least one of the Error Bits (bits 15-10) is set
	BOFFINT   ESR1 = 0x01 << 2  //+ This bit is set when FLEXCAN enters 'Bus Off' state
	RX        ESR1 = 0x01 << 3  //+ This bit indicates if FlexCAN is receiving a message. Refer to .
	FLTCONF   ESR1 = 0x03 << 4  //+ If the LOM bit in the Control Register is asserted, after some delay that depends on the CAN bit timing the FLT_CONF field will indicate "Error Passive"
	FLTCONF_0 ESR1 = 0x00 << 4  //  Error Active
	FLTCONF_1 ESR1 = 0x01 << 4  //  Error Passive
	FLTCONF_2 ESR1 = 0x02 << 4  //  Bus off
	TX        ESR1 = 0x01 << 6  //+ This bit indicates if FLEXCAN is transmitting a message.Refer to .
	IDLE      ESR1 = 0x01 << 7  //+ This bit indicates when CAN bus is in IDLE state.Refer to .
	RXWRN     ESR1 = 0x01 << 8  //+ This bit indicates when repetitive errors are occurring during message reception.
	TXWRN     ESR1 = 0x01 << 9  //+ This bit indicates when repetitive errors are occurring during message transmission.
	STFERR    ESR1 = 0x01 << 10 //+ This bit indicates that a Stuffing Error has been detected.
	FRMERR    ESR1 = 0x01 << 11 //+ This bit indicates that a Form Error has been detected by the receiver node, i
	CRCERR    ESR1 = 0x01 << 12 //+ This bit indicates that a CRC Error has been detected by the receiver node, i
	ACKERR    ESR1 = 0x01 << 13 //+ This bit indicates that an Acknowledge Error has been detected by the transmitter node, i
	BIT0ERR   ESR1 = 0x01 << 14 //+ This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
	BIT1ERR   ESR1 = 0x01 << 15 //+ This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
	RWRNINT   ESR1 = 0x01 << 16 //+ If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the RX_WRN flag transition from '0' to '1', meaning that the Rx error counters reached 96
	TWRNINT   ESR1 = 0x01 << 17 //+ If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the TX_WRN flag transition from '0' to '1', meaning that the Tx error counter reached 96
	SYNCH     ESR1 = 0x01 << 18 //+ This read-only flag indicates whether the FlexCAN is synchronized to the CAN bus and able to participate in the communication process
)

const (
	WAKINTn  = 0
	ERRINTn  = 1
	BOFFINTn = 2
	RXn      = 3
	FLTCONFn = 4
	TXn      = 6
	IDLEn    = 7
	RXWRNn   = 8
	TXWRNn   = 9
	STFERRn  = 10
	FRMERRn  = 11
	CRCERRn  = 12
	ACKERRn  = 13
	BIT0ERRn = 14
	BIT1ERRn = 15
	RWRNINTn = 16
	TWRNINTn = 17
	SYNCHn   = 18
)

const (
	BUFHM   IMASK2 = 0xFFFFFFFF << 0 //+ Each bit enables or disables the respective FLEXCAN Message Buffer (MB32 to MB63) Interrupt
	BUFHM_0 IMASK2 = 0x00 << 0       //  The corresponding buffer Interrupt is disabled
	BUFHM_1 IMASK2 = 0x01 << 0       //  The corresponding buffer Interrupt is enabled
)

const (
	BUFHMn = 0
)

const (
	BUFLM   IMASK1 = 0xFFFFFFFF << 0 //+ Each bit enables or disables the respective FLEXCAN Message Buffer (MB0 to MB31) Interrupt
	BUFLM_0 IMASK1 = 0x00 << 0       //  The corresponding buffer Interrupt is disabled
	BUFLM_1 IMASK1 = 0x01 << 0       //  The corresponding buffer Interrupt is enabled
)

const (
	BUFLMn = 0
)

const (
	BUFHI   IFLAG2 = 0xFFFFFFFF << 0 //+ Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) interrupt.
	BUFHI_0 IFLAG2 = 0x00 << 0       //  No such occurrence
	BUFHI_1 IFLAG2 = 0x01 << 0       //  The corresponding buffer has successfully completed transmission or reception
)

const (
	BUFHIn = 0
)

const (
	BUF4TO0I    IFLAG1 = 0x1F << 0     //+ If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 to MB4
	BUF4TO0I_0  IFLAG1 = 0x00 << 0     //  No such occurrence
	BUF4TO0I_1  IFLAG1 = 0x01 << 0     //  Corresponding MB completed transmission/reception
	BUF5I       IFLAG1 = 0x01 << 5     //+ If the Rx FIFO is not enabled, this bit flags the interrupt for MB5
	BUF6I       IFLAG1 = 0x01 << 6     //+ If the Rx FIFO is not enabled, this bit flags the interrupt for MB6
	BUF7I       IFLAG1 = 0x01 << 7     //+ If the Rx FIFO is not enabled, this bit flags the interrupt for MB7
	BUF31TO8I   IFLAG1 = 0xFFFFFF << 8 //+ Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt.
	BUF31TO8I_0 IFLAG1 = 0x00 << 8     //  No such occurrence
	BUF31TO8I_1 IFLAG1 = 0x01 << 8     //  The corresponding MB has successfully completed transmission or reception
)

const (
	BUF4TO0In  = 0
	BUF5In     = 5
	BUF6In     = 6
	BUF7In     = 7
	BUF31TO8In = 8
)

const (
	EACEN  CTRL2 = 0x01 << 16 //+ This bit controls the comparison of IDE and RTR bits within Rx Mailboxes filters with their corresponding bits in the incoming frame by the matching process
	RRS    CTRL2 = 0x01 << 17 //+ If this bit is asserted Remote Request Frame is submitted to a matching process and stored in the corresponding Message Buffer in the same fashion of a Data Frame
	MRP    CTRL2 = 0x01 << 18 //+ If this bit is set the matching process starts from the Mailboxes and if no match occurs the matching continues on the Rx FIFO
	TASD   CTRL2 = 0x1F << 19 //+ This 5-bit field indicates how many CAN bits the Tx arbitration process start point can be delayed from the first bit of CRC field on CAN bus
	RFFN   CTRL2 = 0x0F << 24 //+ This 4-bit field defines the number of Rx FIFO filters according to
	WRMFRZ CTRL2 = 0x01 << 28 //+ Enable unrestricted write access to FlexCAN memory in Freeze mode
)

const (
	EACENn  = 16
	RRSn    = 17
	MRPn    = 18
	TASDn   = 19
	RFFNn   = 24
	WRMFRZn = 28
)

const (
	IMB  ESR2 = 0x01 << 13 //+ If ESR2[VPS] is asserted, this bit indicates whether there is any inactive Mailbox (CODE field is either 0b1000 or 0b0000)
	VPS  ESR2 = 0x01 << 14 //+ This bit indicates whether IMB and LPTM contents are currently valid or not
	LPTM ESR2 = 0x7F << 16 //+ If ESR2[VPS] is asserted, his 7-bit field indicates the lowest number inactive Mailbox (refer to IMB bit description)
)

const (
	IMBn  = 13
	VPSn  = 14
	LPTMn = 16
)

const (
	TXCRC CRCR = 0x7FFF << 0 //+ This field indicates the CRC value of the last message transmitted
	MBCRC CRCR = 0x7F << 16  //+ This field indicates the number of the Mailbox corresponding to the value in TXCRC field.
)

const (
	TXCRCn = 0
	MBCRCn = 16
)

const (
	FGM   RXFGMASK = 0xFFFFFFFF << 0 //+ These bits mask the ID Filter Table elements bits in a perfect alignment
	FGM_0 RXFGMASK = 0x00 << 0       //  The corresponding bit in the filter is "don't care"
	FGM_1 RXFGMASK = 0x01 << 0       //  The corresponding bit in the filter is checked
)

const (
	FGMn = 0
)

const (
	IDHIT RXFIR = 0x1FF << 0 //+ This 9-bit field indicates which Identifier Acceptance Filter (see Rx FIFO Structure) was hit by the received message that is in the output of the Rx FIFO
)

const (
	IDHITn = 0
)

const (
	CFSM DBG1 = 0x3F << 0  //+ CAN Finite State Machine
	CBN  DBG1 = 0x1F << 24 //+ CAN Bit Number
)

const (
	CFSMn = 0
	CBNn  = 24
)

const (
	RMP DBG2 = 0x7F << 0  //+ Rx Matching Pointer
	MPP DBG2 = 0x01 << 7  //+ Matching Process in Progress
	TAP DBG2 = 0x7F << 8  //+ Tx Arbitration Pointer
	APP DBG2 = 0x01 << 15 //+ Arbitration Process in Progress
)

const (
	RMPn = 0
	MPPn = 7
	TAPn = 8
	APPn = 15
)

const (
	MI   RXIMR = 0xFFFFFFFF << 0 //+ These bits mask both Mailbox filter and Rx FIFO ID Filter Table element in distinct ways
	MI_0 RXIMR = 0x00 << 0       //  the corresponding bit in the filter is "don't care"
	MI_1 RXIMR = 0x01 << 0       //  The corresponding bit in the filter is checked
)

const (
	MIn = 0
)

const (
	GFWR GFWR = 0xFF << 0 //+ It determines the Glitch Filter Width
)

const (
	GFWRn = 0
)
