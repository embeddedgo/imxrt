// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package usdhc provides access to the registers of the USDHC peripheral.
//
// Instances:
//  USDHC1  USDHC1_BASE  -  USDHC1*
//  USDHC2  USDHC2_BASE  -  USDHC2*
// Registers:
//  0x000 32  DS_ADDR               DMA System Address
//  0x004 32  BLK_ATT               Block Attributes
//  0x008 32  CMD_ARG               Command Argument
//  0x00C 32  CMD_XFR_TYP           Command Transfer Type
//  0x010 32  CMD_RSP0              Command Response0
//  0x014 32  CMD_RSP1              Command Response1
//  0x018 32  CMD_RSP2              Command Response2
//  0x01C 32  CMD_RSP3              Command Response3
//  0x020 32  DATA_BUFF_ACC_PORT    Data Buffer Access Port
//  0x024 32  PRES_STATE            Present State
//  0x028 32  PROT_CTRL             Protocol Control
//  0x02C 32  SYS_CTRL              System Control
//  0x030 32  INT_STATUS            Interrupt Status
//  0x034 32  INT_STATUS_EN         Interrupt Status Enable
//  0x038 32  INT_SIGNAL_EN         Interrupt Signal Enable
//  0x03C 32  AUTOCMD12_ERR_STATUS  Auto CMD12 Error Status
//  0x040 32  HOST_CTRL_CAP         Host Controller Capabilities
//  0x044 32  WTMK_LVL              Watermark Level
//  0x048 32  MIX_CTRL              Mixer Control
//  0x050 32  FORCE_EVENT           Force Event
//  0x054 32  ADMA_ERR_STATUS       ADMA Error Status Register
//  0x058 32  ADMA_SYS_ADDR         ADMA System Address
//  0x060 32  DLL_CTRL              DLL (Delay Line) Control
//  0x064 32  DLL_STATUS            DLL Status
//  0x068 32  CLK_TUNE_CTRL_STATUS  CLK Tuning Control and Status
//  0x0C0 32  VEND_SPEC             Vendor Specific Register
//  0x0C4 32  MMC_BOOT              MMC Boot Register
//  0x0C8 32  VEND_SPEC2            Vendor Specific 2 Register
//  0x0CC 32  TUNING_CTRL           Tuning Control Register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package usdhc

const (
	DS_ADDR DS_ADDR = 0xFFFFFFFF << 0 //+ DS_ADDR
)

const (
	DS_ADDRn = 0
)

const (
	BLKSIZE      BLK_ATT = 0x1FFF << 0  //+ Block Size
	BLKSIZE_0    BLK_ATT = 0x00 << 0    //  No data transfer
	BLKSIZE_1    BLK_ATT = 0x01 << 0    //  1 Byte
	BLKSIZE_2    BLK_ATT = 0x02 << 0    //  2 Bytes
	BLKSIZE_3    BLK_ATT = 0x03 << 0    //  3 Bytes
	BLKSIZE_4    BLK_ATT = 0x04 << 0    //  4 Bytes
	BLKSIZE_511  BLK_ATT = 0x1FF << 0   //  511 Bytes
	BLKSIZE_512  BLK_ATT = 0x200 << 0   //  512 Bytes
	BLKSIZE_2048 BLK_ATT = 0x800 << 0   //  2048 Bytes
	BLKSIZE_4096 BLK_ATT = 0x1000 << 0  //  4096 Bytes
	BLKCNT       BLK_ATT = 0xFFFF << 16 //+ Block Count
	BLKCNT_0     BLK_ATT = 0x00 << 16   //  Stop Count
	BLKCNT_1     BLK_ATT = 0x01 << 16   //  1 block
	BLKCNT_2     BLK_ATT = 0x02 << 16   //  2 blocks
	BLKCNT_65535 BLK_ATT = 0xFFFF << 16 //  65535 blocks
)

const (
	BLKSIZEn = 0
	BLKCNTn  = 16
)

const (
	CMDARG CMD_ARG = 0xFFFFFFFF << 0 //+ Command Argument
)

const (
	CMDARGn = 0
)

const (
	RSPTYP   CMD_XFR_TYP = 0x03 << 16 //+ Response Type Select
	RSPTYP_0 CMD_XFR_TYP = 0x00 << 16 //  No Response
	RSPTYP_1 CMD_XFR_TYP = 0x01 << 16 //  Response Length 136
	RSPTYP_2 CMD_XFR_TYP = 0x02 << 16 //  Response Length 48
	RSPTYP_3 CMD_XFR_TYP = 0x03 << 16 //  Response Length 48, check Busy after response
	CCCEN    CMD_XFR_TYP = 0x01 << 19 //+ Command CRC Check Enable
	CICEN    CMD_XFR_TYP = 0x01 << 20 //+ Command Index Check Enable
	DPSEL    CMD_XFR_TYP = 0x01 << 21 //+ Data Present Select
	CMDTYP   CMD_XFR_TYP = 0x03 << 22 //+ Command Type
	CMDTYP_0 CMD_XFR_TYP = 0x00 << 22 //  Normal Other commands
	CMDTYP_1 CMD_XFR_TYP = 0x01 << 22 //  Suspend CMD52 for writing Bus Suspend in CCCR
	CMDTYP_2 CMD_XFR_TYP = 0x02 << 22 //  Resume CMD52 for writing Function Select in CCCR
	CMDTYP_3 CMD_XFR_TYP = 0x03 << 22 //  Abort CMD12, CMD52 for writing I/O Abort in CCCR
	CMDINX   CMD_XFR_TYP = 0x3F << 24 //+ Command Index
)

const (
	RSPTYPn = 16
	CCCENn  = 19
	CICENn  = 20
	DPSELn  = 21
	CMDTYPn = 22
	CMDINXn = 24
)

const (
	CMDRSP0 CMD_RSP0 = 0xFFFFFFFF << 0 //+ Command Response 0
)

const (
	CMDRSP0n = 0
)

const (
	CMDRSP1 CMD_RSP1 = 0xFFFFFFFF << 0 //+ Command Response 1
)

const (
	CMDRSP1n = 0
)

const (
	CMDRSP2 CMD_RSP2 = 0xFFFFFFFF << 0 //+ Command Response 2
)

const (
	CMDRSP2n = 0
)

const (
	CMDRSP3 CMD_RSP3 = 0xFFFFFFFF << 0 //+ Command Response 3
)

const (
	CMDRSP3n = 0
)

const (
	DATCONT DATA_BUFF_ACC_PORT = 0xFFFFFFFF << 0 //+ Data Content
)

const (
	DATCONTn = 0
)

const (
	CIHB   PRES_STATE = 0x01 << 0  //+ Command Inhibit (CMD)
	CDIHB  PRES_STATE = 0x01 << 1  //+ Command Inhibit (DATA)
	DLA    PRES_STATE = 0x01 << 2  //+ Data Line Active
	SDSTB  PRES_STATE = 0x01 << 3  //+ SD Clock Stable
	IPGOFF PRES_STATE = 0x01 << 4  //+ IPG_CLK Gated Off Internally
	HCKOFF PRES_STATE = 0x01 << 5  //+ HCLK Gated Off Internally
	PEROFF PRES_STATE = 0x01 << 6  //+ IPG_PERCLK Gated Off Internally
	SDOFF  PRES_STATE = 0x01 << 7  //+ SD Clock Gated Off Internally
	WTA    PRES_STATE = 0x01 << 8  //+ Write Transfer Active
	RTA    PRES_STATE = 0x01 << 9  //+ Read Transfer Active
	BWEN   PRES_STATE = 0x01 << 10 //+ Buffer Write Enable
	BREN   PRES_STATE = 0x01 << 11 //+ Buffer Read Enable
	RTR    PRES_STATE = 0x01 << 12 //+ Re-Tuning Request (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	TSCD   PRES_STATE = 0x01 << 15 //+ Tape Select Change Done
	CINST  PRES_STATE = 0x01 << 16 //+ Card Inserted
	CDPL   PRES_STATE = 0x01 << 18 //+ Card Detect Pin Level
	WPSPL  PRES_STATE = 0x01 << 19 //+ Write Protect Switch Pin Level
	CLSL   PRES_STATE = 0x01 << 23 //+ CMD Line Signal Level
	DLSL   PRES_STATE = 0xFF << 24 //+ DATA[7:0] Line Signal Level
	DATA0  PRES_STATE = 0x00 << 24 //  Data 0 line signal level
	DATA1  PRES_STATE = 0x01 << 24 //  Data 1 line signal level
	DATA2  PRES_STATE = 0x02 << 24 //  Data 2 line signal level
	DATA3  PRES_STATE = 0x03 << 24 //  Data 3 line signal level
	DATA4  PRES_STATE = 0x04 << 24 //  Data 4 line signal level
	DATA5  PRES_STATE = 0x05 << 24 //  Data 5 line signal level
	DATA6  PRES_STATE = 0x06 << 24 //  Data 6 line signal level
	DATA7  PRES_STATE = 0x07 << 24 //  Data 7 line signal level
)

const (
	CIHBn   = 0
	CDIHBn  = 1
	DLAn    = 2
	SDSTBn  = 3
	IPGOFFn = 4
	HCKOFFn = 5
	PEROFFn = 6
	SDOFFn  = 7
	WTAn    = 8
	RTAn    = 9
	BWENn   = 10
	BRENn   = 11
	RTRn    = 12
	TSCDn   = 15
	CINSTn  = 16
	CDPLn   = 18
	WPSPLn  = 19
	CLSLn   = 23
	DLSLn   = 24
)

const (
	LCTL             PROT_CTRL = 0x01 << 0  //+ LED Control
	DTW              PROT_CTRL = 0x03 << 1  //+ Data Transfer Width
	DTW_0            PROT_CTRL = 0x00 << 1  //  1-bit mode
	DTW_1            PROT_CTRL = 0x01 << 1  //  4-bit mode
	DTW_2            PROT_CTRL = 0x02 << 1  //  8-bit mode
	D3CD             PROT_CTRL = 0x01 << 3  //+ DATA3 as Card Detection Pin
	EMODE            PROT_CTRL = 0x03 << 4  //+ Endian Mode
	EMODE_0          PROT_CTRL = 0x00 << 4  //  Big Endian Mode
	EMODE_1          PROT_CTRL = 0x01 << 4  //  Half Word Big Endian Mode
	EMODE_2          PROT_CTRL = 0x02 << 4  //  Little Endian Mode
	CDTL             PROT_CTRL = 0x01 << 6  //+ Card Detect Test Level
	CDSS             PROT_CTRL = 0x01 << 7  //+ Card Detect Signal Selection
	DMASEL           PROT_CTRL = 0x03 << 8  //+ DMA Select
	DMASEL_0         PROT_CTRL = 0x00 << 8  //  No DMA or Simple DMA is selected
	DMASEL_1         PROT_CTRL = 0x01 << 8  //  ADMA1 is selected
	DMASEL_2         PROT_CTRL = 0x02 << 8  //  ADMA2 is selected
	SABGREQ          PROT_CTRL = 0x01 << 16 //+ Stop At Block Gap Request
	CREQ             PROT_CTRL = 0x01 << 17 //+ Continue Request
	RWCTL            PROT_CTRL = 0x01 << 18 //+ Read Wait Control
	IABG             PROT_CTRL = 0x01 << 19 //+ Interrupt At Block Gap
	RD_DONE_NO_8CLK  PROT_CTRL = 0x01 << 20 //+ RD_DONE_NO_8CLK
	WECINT           PROT_CTRL = 0x01 << 24 //+ Wakeup Event Enable On Card Interrupt
	WECINS           PROT_CTRL = 0x01 << 25 //+ Wakeup Event Enable On SD Card Insertion
	WECRM            PROT_CTRL = 0x01 << 26 //+ Wakeup Event Enable On SD Card Removal
	BURST_LEN_EN     PROT_CTRL = 0x07 << 27 //+ BURST length enable for INCR, INCR4 / INCR8 / INCR16, INCR4-WRAP / INCR8-WRAP / INCR16-WRAP
	BURST_LEN_EN_1   PROT_CTRL = 0x01 << 27 //  Burst length is enabled for INCR
	NON_EXACT_BLK_RD PROT_CTRL = 0x01 << 30 //+ NON_EXACT_BLK_RD
)

const (
	LCTLn             = 0
	DTWn              = 1
	D3CDn             = 3
	EMODEn            = 4
	CDTLn             = 6
	CDSSn             = 7
	DMASELn           = 8
	SABGREQn          = 16
	CREQn             = 17
	RWCTLn            = 18
	IABGn             = 19
	RD_DONE_NO_8CLKn  = 20
	WECINTn           = 24
	WECINSn           = 25
	WECRMn            = 26
	BURST_LEN_ENn     = 27
	NON_EXACT_BLK_RDn = 30
)

const (
	DVS       SYS_CTRL = 0x0F << 4  //+ Divisor
	DVS_0     SYS_CTRL = 0x00 << 4  //  Divide-by-1
	DVS_1     SYS_CTRL = 0x01 << 4  //  Divide-by-2
	DVS_14    SYS_CTRL = 0x0E << 4  //  Divide-by-15
	DVS_15    SYS_CTRL = 0x0F << 4  //  Divide-by-16
	SDCLKFS   SYS_CTRL = 0xFF << 8  //+ SDCLK Frequency Select
	DTOCV     SYS_CTRL = 0x0F << 16 //+ Data Timeout Counter Value
	DTOCV_0   SYS_CTRL = 0x00 << 16 //  SDCLK x 2 14
	DTOCV_1   SYS_CTRL = 0x01 << 16 //  SDCLK x 2 15
	DTOCV_13  SYS_CTRL = 0x0D << 16 //  SDCLK x 2 27
	DTOCV_14  SYS_CTRL = 0x0E << 16 //  SDCLK x 2 28
	DTOCV_15  SYS_CTRL = 0x0F << 16 //  SDCLK x 2 29
	IPP_RST_N SYS_CTRL = 0x01 << 23 //+ IPP_RST_N
	RSTA      SYS_CTRL = 0x01 << 24 //+ Software Reset For ALL
	RSTC      SYS_CTRL = 0x01 << 25 //+ Software Reset For CMD Line
	RSTD      SYS_CTRL = 0x01 << 26 //+ Software Reset For DATA Line
	INITA     SYS_CTRL = 0x01 << 27 //+ Initialization Active
	RSTT      SYS_CTRL = 0x01 << 28 //+ Reset Tuning
)

const (
	DVSn       = 4
	SDCLKFSn   = 8
	DTOCVn     = 16
	IPP_RST_Nn = 23
	RSTAn      = 24
	RSTCn      = 25
	RSTDn      = 26
	INITAn     = 27
	RSTTn      = 28
)

const (
	CC    INT_STATUS = 0x01 << 0  //+ Command Complete
	TC    INT_STATUS = 0x01 << 1  //+ Transfer Complete
	BGE   INT_STATUS = 0x01 << 2  //+ Block Gap Event
	DINT  INT_STATUS = 0x01 << 3  //+ DMA Interrupt
	BWR   INT_STATUS = 0x01 << 4  //+ Buffer Write Ready
	BRR   INT_STATUS = 0x01 << 5  //+ Buffer Read Ready
	CINS  INT_STATUS = 0x01 << 6  //+ Card Insertion
	CRM   INT_STATUS = 0x01 << 7  //+ Card Removal
	CINT  INT_STATUS = 0x01 << 8  //+ Card Interrupt
	RTE   INT_STATUS = 0x01 << 12 //+ Re-Tuning Event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	TP    INT_STATUS = 0x01 << 14 //+ Tuning Pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
	CTOE  INT_STATUS = 0x01 << 16 //+ Command Timeout Error
	CCE   INT_STATUS = 0x01 << 17 //+ Command CRC Error
	CEBE  INT_STATUS = 0x01 << 18 //+ Command End Bit Error
	CIE   INT_STATUS = 0x01 << 19 //+ Command Index Error
	DTOE  INT_STATUS = 0x01 << 20 //+ Data Timeout Error
	DCE   INT_STATUS = 0x01 << 21 //+ Data CRC Error
	DEBE  INT_STATUS = 0x01 << 22 //+ Data End Bit Error
	AC12E INT_STATUS = 0x01 << 24 //+ Auto CMD12 Error
	TNE   INT_STATUS = 0x01 << 26 //+ Tuning Error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	DMAE  INT_STATUS = 0x01 << 28 //+ DMA Error
)

const (
	CCn    = 0
	TCn    = 1
	BGEn   = 2
	DINTn  = 3
	BWRn   = 4
	BRRn   = 5
	CINSn  = 6
	CRMn   = 7
	CINTn  = 8
	RTEn   = 12
	TPn    = 14
	CTOEn  = 16
	CCEn   = 17
	CEBEn  = 18
	CIEn   = 19
	DTOEn  = 20
	DCEn   = 21
	DEBEn  = 22
	AC12En = 24
	TNEn   = 26
	DMAEn  = 28
)

const (
	CCSEN    INT_STATUS_EN = 0x01 << 0  //+ Command Complete Status Enable
	TCSEN    INT_STATUS_EN = 0x01 << 1  //+ Transfer Complete Status Enable
	BGESEN   INT_STATUS_EN = 0x01 << 2  //+ Block Gap Event Status Enable
	DINTSEN  INT_STATUS_EN = 0x01 << 3  //+ DMA Interrupt Status Enable
	BWRSEN   INT_STATUS_EN = 0x01 << 4  //+ Buffer Write Ready Status Enable
	BRRSEN   INT_STATUS_EN = 0x01 << 5  //+ Buffer Read Ready Status Enable
	CINSSEN  INT_STATUS_EN = 0x01 << 6  //+ Card Insertion Status Enable
	CRMSEN   INT_STATUS_EN = 0x01 << 7  //+ Card Removal Status Enable
	CINTSEN  INT_STATUS_EN = 0x01 << 8  //+ Card Interrupt Status Enable
	RTESEN   INT_STATUS_EN = 0x01 << 12 //+ Re-Tuning Event Status Enable
	TPSEN    INT_STATUS_EN = 0x01 << 14 //+ Tuning Pass Status Enable
	CTOESEN  INT_STATUS_EN = 0x01 << 16 //+ Command Timeout Error Status Enable
	CCESEN   INT_STATUS_EN = 0x01 << 17 //+ Command CRC Error Status Enable
	CEBESEN  INT_STATUS_EN = 0x01 << 18 //+ Command End Bit Error Status Enable
	CIESEN   INT_STATUS_EN = 0x01 << 19 //+ Command Index Error Status Enable
	DTOESEN  INT_STATUS_EN = 0x01 << 20 //+ Data Timeout Error Status Enable
	DCESEN   INT_STATUS_EN = 0x01 << 21 //+ Data CRC Error Status Enable
	DEBESEN  INT_STATUS_EN = 0x01 << 22 //+ Data End Bit Error Status Enable
	AC12ESEN INT_STATUS_EN = 0x01 << 24 //+ Auto CMD12 Error Status Enable
	TNESEN   INT_STATUS_EN = 0x01 << 26 //+ Tuning Error Status Enable
	DMAESEN  INT_STATUS_EN = 0x01 << 28 //+ DMA Error Status Enable
)

const (
	CCSENn    = 0
	TCSENn    = 1
	BGESENn   = 2
	DINTSENn  = 3
	BWRSENn   = 4
	BRRSENn   = 5
	CINSSENn  = 6
	CRMSENn   = 7
	CINTSENn  = 8
	RTESENn   = 12
	TPSENn    = 14
	CTOESENn  = 16
	CCESENn   = 17
	CEBESENn  = 18
	CIESENn   = 19
	DTOESENn  = 20
	DCESENn   = 21
	DEBESENn  = 22
	AC12ESENn = 24
	TNESENn   = 26
	DMAESENn  = 28
)

const (
	CCIEN    INT_SIGNAL_EN = 0x01 << 0  //+ Command Complete Interrupt Enable
	TCIEN    INT_SIGNAL_EN = 0x01 << 1  //+ Transfer Complete Interrupt Enable
	BGEIEN   INT_SIGNAL_EN = 0x01 << 2  //+ Block Gap Event Interrupt Enable
	DINTIEN  INT_SIGNAL_EN = 0x01 << 3  //+ DMA Interrupt Enable
	BWRIEN   INT_SIGNAL_EN = 0x01 << 4  //+ Buffer Write Ready Interrupt Enable
	BRRIEN   INT_SIGNAL_EN = 0x01 << 5  //+ Buffer Read Ready Interrupt Enable
	CINSIEN  INT_SIGNAL_EN = 0x01 << 6  //+ Card Insertion Interrupt Enable
	CRMIEN   INT_SIGNAL_EN = 0x01 << 7  //+ Card Removal Interrupt Enable
	CINTIEN  INT_SIGNAL_EN = 0x01 << 8  //+ Card Interrupt Interrupt Enable
	RTEIEN   INT_SIGNAL_EN = 0x01 << 12 //+ Re-Tuning Event Interrupt Enable
	TPIEN    INT_SIGNAL_EN = 0x01 << 14 //+ Tuning Pass Interrupt Enable
	CTOEIEN  INT_SIGNAL_EN = 0x01 << 16 //+ Command Timeout Error Interrupt Enable
	CCEIEN   INT_SIGNAL_EN = 0x01 << 17 //+ Command CRC Error Interrupt Enable
	CEBEIEN  INT_SIGNAL_EN = 0x01 << 18 //+ Command End Bit Error Interrupt Enable
	CIEIEN   INT_SIGNAL_EN = 0x01 << 19 //+ Command Index Error Interrupt Enable
	DTOEIEN  INT_SIGNAL_EN = 0x01 << 20 //+ Data Timeout Error Interrupt Enable
	DCEIEN   INT_SIGNAL_EN = 0x01 << 21 //+ Data CRC Error Interrupt Enable
	DEBEIEN  INT_SIGNAL_EN = 0x01 << 22 //+ Data End Bit Error Interrupt Enable
	AC12EIEN INT_SIGNAL_EN = 0x01 << 24 //+ Auto CMD12 Error Interrupt Enable
	TNEIEN   INT_SIGNAL_EN = 0x01 << 26 //+ Tuning Error Interrupt Enable
	DMAEIEN  INT_SIGNAL_EN = 0x01 << 28 //+ DMA Error Interrupt Enable
)

const (
	CCIENn    = 0
	TCIENn    = 1
	BGEIENn   = 2
	DINTIENn  = 3
	BWRIENn   = 4
	BRRIENn   = 5
	CINSIENn  = 6
	CRMIENn   = 7
	CINTIENn  = 8
	RTEIENn   = 12
	TPIENn    = 14
	CTOEIENn  = 16
	CCEIENn   = 17
	CEBEIENn  = 18
	CIEIENn   = 19
	DTOEIENn  = 20
	DCEIENn   = 21
	DEBEIENn  = 22
	AC12EIENn = 24
	TNEIENn   = 26
	DMAEIENn  = 28
)

const (
	AC12NE         AUTOCMD12_ERR_STATUS = 0x01 << 0  //+ Auto CMD12 Not Executed
	AC12TOE        AUTOCMD12_ERR_STATUS = 0x01 << 1  //+ Auto CMD12 / 23 Timeout Error
	AC12EBE        AUTOCMD12_ERR_STATUS = 0x01 << 2  //+ Auto CMD12 / 23 End Bit Error
	AC12CE         AUTOCMD12_ERR_STATUS = 0x01 << 3  //+ Auto CMD12 / 23 CRC Error
	AC12IE         AUTOCMD12_ERR_STATUS = 0x01 << 4  //+ Auto CMD12 / 23 Index Error
	CNIBAC12E      AUTOCMD12_ERR_STATUS = 0x01 << 7  //+ Command Not Issued By Auto CMD12 Error
	EXECUTE_TUNING AUTOCMD12_ERR_STATUS = 0x01 << 22 //+ Execute Tuning
	SMP_CLK_SEL    AUTOCMD12_ERR_STATUS = 0x01 << 23 //+ Sample Clock Select
)

const (
	AC12NEn         = 0
	AC12TOEn        = 1
	AC12EBEn        = 2
	AC12CEn         = 3
	AC12IEn         = 4
	CNIBAC12En      = 7
	EXECUTE_TUNINGn = 22
	SMP_CLK_SELn    = 23
)

const (
	SDR50_SUPPORT       HOST_CTRL_CAP = 0x01 << 0  //+ SDR50 support
	SDR104_SUPPORT      HOST_CTRL_CAP = 0x01 << 1  //+ SDR104 support
	DDR50_SUPPORT       HOST_CTRL_CAP = 0x01 << 2  //+ DDR50 support
	TIME_COUNT_RETUNING HOST_CTRL_CAP = 0x0F << 8  //+ Time Counter for Retuning
	USE_TUNING_SDR50    HOST_CTRL_CAP = 0x01 << 13 //+ Use Tuning for SDR50
	RETUNING_MODE       HOST_CTRL_CAP = 0x03 << 14 //+ Retuning Mode
	RETUNING_MODE_0     HOST_CTRL_CAP = 0x00 << 14 //  Mode 1
	RETUNING_MODE_1     HOST_CTRL_CAP = 0x01 << 14 //  Mode 2
	RETUNING_MODE_2     HOST_CTRL_CAP = 0x02 << 14 //  Mode 3
	MBL                 HOST_CTRL_CAP = 0x07 << 16 //+ Max Block Length
	MBL_0               HOST_CTRL_CAP = 0x00 << 16 //  512 bytes
	MBL_1               HOST_CTRL_CAP = 0x01 << 16 //  1024 bytes
	MBL_2               HOST_CTRL_CAP = 0x02 << 16 //  2048 bytes
	MBL_3               HOST_CTRL_CAP = 0x03 << 16 //  4096 bytes
	ADMAS               HOST_CTRL_CAP = 0x01 << 20 //+ ADMA Support
	HSS                 HOST_CTRL_CAP = 0x01 << 21 //+ High Speed Support
	DMAS                HOST_CTRL_CAP = 0x01 << 22 //+ DMA Support
	SRS                 HOST_CTRL_CAP = 0x01 << 23 //+ Suspend / Resume Support
	VS33                HOST_CTRL_CAP = 0x01 << 24 //+ Voltage Support 3.3V
	VS30                HOST_CTRL_CAP = 0x01 << 25 //+ Voltage Support 3.0 V
	VS18                HOST_CTRL_CAP = 0x01 << 26 //+ Voltage Support 1.8 V
)

const (
	SDR50_SUPPORTn       = 0
	SDR104_SUPPORTn      = 1
	DDR50_SUPPORTn       = 2
	TIME_COUNT_RETUNINGn = 8
	USE_TUNING_SDR50n    = 13
	RETUNING_MODEn       = 14
	MBLn                 = 16
	ADMASn               = 20
	HSSn                 = 21
	DMASn                = 22
	SRSn                 = 23
	VS33n                = 24
	VS30n                = 25
	VS18n                = 26
)

const (
	RD_WML      WTMK_LVL = 0xFF << 0  //+ Read Watermark Level
	RD_BRST_LEN WTMK_LVL = 0x1F << 8  //+ Read Burst Length Due to system restriction, the actual burst length may not exceed 16.
	WR_WML      WTMK_LVL = 0xFF << 16 //+ Write Watermark Level
	WR_BRST_LEN WTMK_LVL = 0x1F << 24 //+ Write Burst Length Due to system restriction, the actual burst length may not exceed 16.
)

const (
	RD_WMLn      = 0
	RD_BRST_LENn = 8
	WR_WMLn      = 16
	WR_BRST_LENn = 24
)

const (
	DMAEN        MIX_CTRL = 0x01 << 0  //+ DMA Enable
	BCEN         MIX_CTRL = 0x01 << 1  //+ Block Count Enable
	AC12EN       MIX_CTRL = 0x01 << 2  //+ Auto CMD12 Enable
	DDR_EN       MIX_CTRL = 0x01 << 3  //+ Dual Data Rate mode selection
	DTDSEL       MIX_CTRL = 0x01 << 4  //+ Data Transfer Direction Select
	MSBSEL       MIX_CTRL = 0x01 << 5  //+ Multi / Single Block Select
	NIBBLE_POS   MIX_CTRL = 0x01 << 6  //+ NIBBLE_POS
	AC23EN       MIX_CTRL = 0x01 << 7  //+ Auto CMD23 Enable
	EXE_TUNE     MIX_CTRL = 0x01 << 22 //+ Execute Tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
	SMP_CLK_SEL  MIX_CTRL = 0x01 << 23 //+ SMP_CLK_SEL
	AUTO_TUNE_EN MIX_CTRL = 0x01 << 24 //+ Auto Tuning Enable (Only used for SD3.0, SDR104 mode and and EMMC HS200 mode)
	FBCLK_SEL    MIX_CTRL = 0x01 << 25 //+ Feedback Clock Source Selection (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
)

const (
	DMAENn        = 0
	BCENn         = 1
	AC12ENn       = 2
	DDR_ENn       = 3
	DTDSELn       = 4
	MSBSELn       = 5
	NIBBLE_POSn   = 6
	AC23ENn       = 7
	EXE_TUNEn     = 22
	SMP_CLK_SELn  = 23
	AUTO_TUNE_ENn = 24
	FBCLK_SELn    = 25
)

const (
	FEVTAC12NE    FORCE_EVENT = 0x01 << 0  //+ Force Event Auto Command 12 Not Executed
	FEVTAC12TOE   FORCE_EVENT = 0x01 << 1  //+ Force Event Auto Command 12 Time Out Error
	FEVTAC12CE    FORCE_EVENT = 0x01 << 2  //+ Force Event Auto Command 12 CRC Error
	FEVTAC12EBE   FORCE_EVENT = 0x01 << 3  //+ Force Event Auto Command 12 End Bit Error
	FEVTAC12IE    FORCE_EVENT = 0x01 << 4  //+ Force Event Auto Command 12 Index Error
	FEVTCNIBAC12E FORCE_EVENT = 0x01 << 7  //+ Force Event Command Not Executed By Auto Command 12 Error
	FEVTCTOE      FORCE_EVENT = 0x01 << 16 //+ Force Event Command Time Out Error
	FEVTCCE       FORCE_EVENT = 0x01 << 17 //+ Force Event Command CRC Error
	FEVTCEBE      FORCE_EVENT = 0x01 << 18 //+ Force Event Command End Bit Error
	FEVTCIE       FORCE_EVENT = 0x01 << 19 //+ Force Event Command Index Error
	FEVTDTOE      FORCE_EVENT = 0x01 << 20 //+ Force Event Data Time Out Error
	FEVTDCE       FORCE_EVENT = 0x01 << 21 //+ Force Event Data CRC Error
	FEVTDEBE      FORCE_EVENT = 0x01 << 22 //+ Force Event Data End Bit Error
	FEVTAC12E     FORCE_EVENT = 0x01 << 24 //+ Force Event Auto Command 12 Error
	FEVTTNE       FORCE_EVENT = 0x01 << 26 //+ Force Tuning Error
	FEVTDMAE      FORCE_EVENT = 0x01 << 28 //+ Force Event DMA Error
	FEVTCINT      FORCE_EVENT = 0x01 << 31 //+ Force Event Card Interrupt
)

const (
	FEVTAC12NEn    = 0
	FEVTAC12TOEn   = 1
	FEVTAC12CEn    = 2
	FEVTAC12EBEn   = 3
	FEVTAC12IEn    = 4
	FEVTCNIBAC12En = 7
	FEVTCTOEn      = 16
	FEVTCCEn       = 17
	FEVTCEBEn      = 18
	FEVTCIEn       = 19
	FEVTDTOEn      = 20
	FEVTDCEn       = 21
	FEVTDEBEn      = 22
	FEVTAC12En     = 24
	FEVTTNEn       = 26
	FEVTDMAEn      = 28
	FEVTCINTn      = 31
)

const (
	ADMAES  ADMA_ERR_STATUS = 0x03 << 0 //+ ADMA Error State (when ADMA Error is occurred)
	ADMALME ADMA_ERR_STATUS = 0x01 << 2 //+ ADMA Length Mismatch Error
	ADMADCE ADMA_ERR_STATUS = 0x01 << 3 //+ ADMA Descriptor Error
)

const (
	ADMAESn  = 0
	ADMALMEn = 2
	ADMADCEn = 3
)

const (
	ADS_ADDR ADMA_SYS_ADDR = 0x3FFFFFFF << 2 //+ ADMA System Address
)

const (
	ADS_ADDRn = 2
)

const (
	DLL_CTRL_ENABLE           DLL_CTRL = 0x01 << 0  //+ DLL_CTRL_ENABLE
	DLL_CTRL_RESET            DLL_CTRL = 0x01 << 1  //+ DLL_CTRL_RESET
	DLL_CTRL_SLV_FORCE_UPD    DLL_CTRL = 0x01 << 2  //+ DLL_CTRL_SLV_FORCE_UPD
	DLL_CTRL_SLV_DLY_TARGET0  DLL_CTRL = 0x0F << 3  //+ DLL_CTRL_SLV_DLY_TARGET0
	DLL_CTRL_GATE_UPDATE      DLL_CTRL = 0x01 << 7  //+ DLL_CTRL_GATE_UPDATE
	DLL_CTRL_SLV_OVERRIDE     DLL_CTRL = 0x01 << 8  //+ DLL_CTRL_SLV_OVERRIDE
	DLL_CTRL_SLV_OVERRIDE_VAL DLL_CTRL = 0x7F << 9  //+ DLL_CTRL_SLV_OVERRIDE_VAL
	DLL_CTRL_SLV_DLY_TARGET1  DLL_CTRL = 0x07 << 16 //+ DLL_CTRL_SLV_DLY_TARGET1
	DLL_CTRL_SLV_UPDATE_INT   DLL_CTRL = 0xFF << 20 //+ DLL_CTRL_SLV_UPDATE_INT
	DLL_CTRL_REF_UPDATE_INT   DLL_CTRL = 0x0F << 28 //+ DLL_CTRL_REF_UPDATE_INT
)

const (
	DLL_CTRL_ENABLEn           = 0
	DLL_CTRL_RESETn            = 1
	DLL_CTRL_SLV_FORCE_UPDn    = 2
	DLL_CTRL_SLV_DLY_TARGET0n  = 3
	DLL_CTRL_GATE_UPDATEn      = 7
	DLL_CTRL_SLV_OVERRIDEn     = 8
	DLL_CTRL_SLV_OVERRIDE_VALn = 9
	DLL_CTRL_SLV_DLY_TARGET1n  = 16
	DLL_CTRL_SLV_UPDATE_INTn   = 20
	DLL_CTRL_REF_UPDATE_INTn   = 28
)

const (
	DLL_STS_SLV_LOCK DLL_STATUS = 0x01 << 0 //+ DLL_STS_SLV_LOCK
	DLL_STS_REF_LOCK DLL_STATUS = 0x01 << 1 //+ DLL_STS_REF_LOCK
	DLL_STS_SLV_SEL  DLL_STATUS = 0x7F << 2 //+ DLL_STS_SLV_SEL
	DLL_STS_REF_SEL  DLL_STATUS = 0x7F << 9 //+ DLL_STS_REF_SEL
)

const (
	DLL_STS_SLV_LOCKn = 0
	DLL_STS_REF_LOCKn = 1
	DLL_STS_SLV_SELn  = 2
	DLL_STS_REF_SELn  = 9
)

const (
	DLY_CELL_SET_POST CLK_TUNE_CTRL_STATUS = 0x0F << 0  //+ DLY_CELL_SET_POST
	DLY_CELL_SET_OUT  CLK_TUNE_CTRL_STATUS = 0x0F << 4  //+ DLY_CELL_SET_OUT
	DLY_CELL_SET_PRE  CLK_TUNE_CTRL_STATUS = 0x7F << 8  //+ DLY_CELL_SET_PRE
	NXT_ERR           CLK_TUNE_CTRL_STATUS = 0x01 << 15 //+ NXT_ERR
	TAP_SEL_POST      CLK_TUNE_CTRL_STATUS = 0x0F << 16 //+ TAP_SEL_POST
	TAP_SEL_OUT       CLK_TUNE_CTRL_STATUS = 0x0F << 20 //+ TAP_SEL_OUT
	TAP_SEL_PRE       CLK_TUNE_CTRL_STATUS = 0x7F << 24 //+ TAP_SEL_PRE
	PRE_ERR           CLK_TUNE_CTRL_STATUS = 0x01 << 31 //+ PRE_ERR
)

const (
	DLY_CELL_SET_POSTn = 0
	DLY_CELL_SET_OUTn  = 4
	DLY_CELL_SET_PREn  = 8
	NXT_ERRn           = 15
	TAP_SEL_POSTn      = 16
	TAP_SEL_OUTn       = 20
	TAP_SEL_PREn       = 24
	PRE_ERRn           = 31
)

const (
	VSELECT            VEND_SPEC = 0x01 << 1  //+ Voltage Selection
	CONFLICT_CHK_EN    VEND_SPEC = 0x01 << 2  //+ Conflict check enable.
	AC12_WR_CHKBUSY_EN VEND_SPEC = 0x01 << 3  //+ AC12_WR_CHKBUSY_EN
	FRC_SDCLK_ON       VEND_SPEC = 0x01 << 8  //+ FRC_SDCLK_ON
	CRC_CHK_DIS        VEND_SPEC = 0x01 << 15 //+ CRC Check Disable
	CMD_BYTE_EN        VEND_SPEC = 0x01 << 31 //+ CMD_BYTE_EN
)

const (
	VSELECTn            = 1
	CONFLICT_CHK_ENn    = 2
	AC12_WR_CHKBUSY_ENn = 3
	FRC_SDCLK_ONn       = 8
	CRC_CHK_DISn        = 15
	CMD_BYTE_ENn        = 31
)

const (
	DTOCV_ACK        MMC_BOOT = 0x0F << 0    //+ DTOCV_ACK
	DTOCV_ACK_0      MMC_BOOT = 0x00 << 0    //  SDCLK x 2^14
	DTOCV_ACK_1      MMC_BOOT = 0x01 << 0    //  SDCLK x 2^15
	DTOCV_ACK_2      MMC_BOOT = 0x02 << 0    //  SDCLK x 2^16
	DTOCV_ACK_3      MMC_BOOT = 0x03 << 0    //  SDCLK x 2^17
	DTOCV_ACK_4      MMC_BOOT = 0x04 << 0    //  SDCLK x 2^18
	DTOCV_ACK_5      MMC_BOOT = 0x05 << 0    //  SDCLK x 2^19
	DTOCV_ACK_6      MMC_BOOT = 0x06 << 0    //  SDCLK x 2^20
	DTOCV_ACK_7      MMC_BOOT = 0x07 << 0    //  SDCLK x 2^21
	DTOCV_ACK_14     MMC_BOOT = 0x0E << 0    //  SDCLK x 2^28
	DTOCV_ACK_15     MMC_BOOT = 0x0F << 0    //  SDCLK x 2^29
	BOOT_ACK         MMC_BOOT = 0x01 << 4    //+ BOOT_ACK
	BOOT_MODE        MMC_BOOT = 0x01 << 5    //+ BOOT_MODE
	BOOT_EN          MMC_BOOT = 0x01 << 6    //+ BOOT_EN
	AUTO_SABG_EN     MMC_BOOT = 0x01 << 7    //+ AUTO_SABG_EN
	DISABLE_TIME_OUT MMC_BOOT = 0x01 << 8    //+ Disable Time Out
	BOOT_BLK_CNT     MMC_BOOT = 0xFFFF << 16 //+ BOOT_BLK_CNT
)

const (
	DTOCV_ACKn        = 0
	BOOT_ACKn         = 4
	BOOT_MODEn        = 5
	BOOT_ENn          = 6
	AUTO_SABG_ENn     = 7
	DISABLE_TIME_OUTn = 8
	BOOT_BLK_CNTn     = 16
)

const (
	CARD_INT_D3_TEST VEND_SPEC2 = 0x01 << 3  //+ Card Interrupt Detection Test
	TUNING_8bit_EN   VEND_SPEC2 = 0x01 << 4  //+ TUNING_8bit_EN
	TUNING_1bit_EN   VEND_SPEC2 = 0x01 << 5  //+ TUNING_1bit_EN
	TUNING_CMD_EN    VEND_SPEC2 = 0x01 << 6  //+ TUNING_CMD_EN
	ACMD23_ARGU2_EN  VEND_SPEC2 = 0x01 << 12 //+ Argument2 register enable for ACMD23
	PART_DLL_DEBUG   VEND_SPEC2 = 0x01 << 13 //+ debug for part dll
	BUS_RST          VEND_SPEC2 = 0x01 << 14 //+ BUS reset
)

const (
	CARD_INT_D3_TESTn = 3
	TUNING_8bit_ENn   = 4
	TUNING_1bit_ENn   = 5
	TUNING_CMD_ENn    = 6
	ACMD23_ARGU2_ENn  = 12
	PART_DLL_DEBUGn   = 13
	BUS_RSTn          = 14
)

const (
	TUNING_START_TAP TUNING_CTRL = 0xFF << 0  //+ TUNING_START_TAP
	TUNING_COUNTER   TUNING_CTRL = 0xFF << 8  //+ TUNING_COUNTER
	TUNING_STEP      TUNING_CTRL = 0x07 << 16 //+ TUNING_STEP
	TUNING_WINDOW    TUNING_CTRL = 0x07 << 20 //+ TUNING_WINDOW
	STD_TUNING_EN    TUNING_CTRL = 0x01 << 24 //+ STD_TUNING_EN
)

const (
	TUNING_START_TAPn = 0
	TUNING_COUNTERn   = 8
	TUNING_STEPn      = 16
	TUNING_WINDOWn    = 20
	STD_TUNING_ENn    = 24
)
