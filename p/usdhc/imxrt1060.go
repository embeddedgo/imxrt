// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package usdhc provides access to the registers of the USDHC peripheral.
//
// Instances:
//  USDHC1  USDHC1_BASE  -  USDHC1*
//  USDHC2  USDHC2_BASE  -  USDHC2*
// Registers:
//  0x000 32  DS_ADDR               DMA System Address
//  0x004 32  BLK_ATT               Block Attributes
//  0x008 32  CMD_ARG               Command Argument
//  0x00C 32  CMD_XFR_TYP           Command Transfer Type
//  0x010 32  CMD_RSP0              Command Response0
//  0x014 32  CMD_RSP1              Command Response1
//  0x018 32  CMD_RSP2              Command Response2
//  0x01C 32  CMD_RSP3              Command Response3
//  0x020 32  DATA_BUFF_ACC_PORT    Data Buffer Access Port
//  0x024 32  PRES_STATE            Present State
//  0x028 32  PROT_CTRL             Protocol Control
//  0x02C 32  SYS_CTRL              System Control
//  0x030 32  INT_STATUS            Interrupt Status
//  0x034 32  INT_STATUS_EN         Interrupt Status Enable
//  0x038 32  INT_SIGNAL_EN         Interrupt Signal Enable
//  0x03C 32  AUTOCMD12_ERR_STATUS  Auto CMD12 Error Status
//  0x040 32  HOST_CTRL_CAP         Host Controller Capabilities
//  0x044 32  WTMK_LVL              Watermark Level
//  0x048 32  MIX_CTRL              Mixer Control
//  0x050 32  FORCE_EVENT           Force Event
//  0x054 32  ADMA_ERR_STATUS       ADMA Error Status Register
//  0x058 32  ADMA_SYS_ADDR         ADMA System Address
//  0x060 32  DLL_CTRL              DLL (Delay Line) Control
//  0x064 32  DLL_STATUS            DLL Status
//  0x068 32  CLK_TUNE_CTRL_STATUS  CLK Tuning Control and Status
//  0x0C0 32  VEND_SPEC             Vendor Specific Register
//  0x0C4 32  MMC_BOOT              MMC Boot Register
//  0x0C8 32  VEND_SPEC2            Vendor Specific 2 Register
//  0x0CC 32  TUNING_CTRL           Tuning Control Register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package usdhc

const (
	DS_ADDR DS_ADDR = 0xFFFFFFFF << 0 //+ DS_ADDR
)

const (
	DS_ADDRn = 0
)

const (
	BLKSIZE      BLK_ATT = 0x1FFF << 0  //+ Block Size
	BLKSIZE_0    BLK_ATT = 0x00 << 0    //  No data transfer
	BLKSIZE_1    BLK_ATT = 0x01 << 0    //  1 Byte
	BLKSIZE_2    BLK_ATT = 0x02 << 0    //  2 Bytes
	BLKSIZE_3    BLK_ATT = 0x03 << 0    //  3 Bytes
	BLKSIZE_4    BLK_ATT = 0x04 << 0    //  4 Bytes
	BLKSIZE_511  BLK_ATT = 0x1FF << 0   //  511 Bytes
	BLKSIZE_512  BLK_ATT = 0x200 << 0   //  512 Bytes
	BLKSIZE_2048 BLK_ATT = 0x800 << 0   //  2048 Bytes
	BLKSIZE_4096 BLK_ATT = 0x1000 << 0  //  4096 Bytes
	BLKCNT       BLK_ATT = 0xFFFF << 16 //+ Block Count
	BLKCNT_0     BLK_ATT = 0x00 << 16   //  Stop Count
	BLKCNT_1     BLK_ATT = 0x01 << 16   //  1 block
	BLKCNT_2     BLK_ATT = 0x02 << 16   //  2 blocks
	BLKCNT_65535 BLK_ATT = 0xFFFF << 16 //  65535 blocks
)

const (
	BLKSIZEn = 0
	BLKCNTn  = 16
)

const (
	CMDARG CMD_ARG = 0xFFFFFFFF << 0 //+ Command Argument
)

const (
	CMDARGn = 0
)

const (
	RSPTYP   CMD_XFR_TYP = 0x03 << 16 //+ Response Type Select
	RSPTYP_0 CMD_XFR_TYP = 0x00 << 16 //  No Response
	RSPTYP_1 CMD_XFR_TYP = 0x01 << 16 //  Response Length 136
	RSPTYP_2 CMD_XFR_TYP = 0x02 << 16 //  Response Length 48
	RSPTYP_3 CMD_XFR_TYP = 0x03 << 16 //  Response Length 48, check Busy after response
	CCCEN    CMD_XFR_TYP = 0x01 << 19 //+ Command CRC Check Enable
	CCCEN_0  CMD_XFR_TYP = 0x00 << 19 //  Disable
	CCCEN_1  CMD_XFR_TYP = 0x01 << 19 //  Enable
	CICEN    CMD_XFR_TYP = 0x01 << 20 //+ Command Index Check Enable
	CICEN_0  CMD_XFR_TYP = 0x00 << 20 //  Disable
	CICEN_1  CMD_XFR_TYP = 0x01 << 20 //  Enable
	DPSEL    CMD_XFR_TYP = 0x01 << 21 //+ Data Present Select
	DPSEL_0  CMD_XFR_TYP = 0x00 << 21 //  No Data Present
	DPSEL_1  CMD_XFR_TYP = 0x01 << 21 //  Data Present
	CMDTYP   CMD_XFR_TYP = 0x03 << 22 //+ Command Type
	CMDTYP_0 CMD_XFR_TYP = 0x00 << 22 //  Normal Other commands
	CMDTYP_1 CMD_XFR_TYP = 0x01 << 22 //  Suspend CMD52 for writing Bus Suspend in CCCR
	CMDTYP_2 CMD_XFR_TYP = 0x02 << 22 //  Resume CMD52 for writing Function Select in CCCR
	CMDTYP_3 CMD_XFR_TYP = 0x03 << 22 //  Abort CMD12, CMD52 for writing I/O Abort in CCCR
	CMDINX   CMD_XFR_TYP = 0x3F << 24 //+ Command Index
)

const (
	RSPTYPn = 16
	CCCENn  = 19
	CICENn  = 20
	DPSELn  = 21
	CMDTYPn = 22
	CMDINXn = 24
)

const (
	CMDRSP0 CMD_RSP0 = 0xFFFFFFFF << 0 //+ Command Response 0
)

const (
	CMDRSP0n = 0
)

const (
	CMDRSP1 CMD_RSP1 = 0xFFFFFFFF << 0 //+ Command Response 1
)

const (
	CMDRSP1n = 0
)

const (
	CMDRSP2 CMD_RSP2 = 0xFFFFFFFF << 0 //+ Command Response 2
)

const (
	CMDRSP2n = 0
)

const (
	CMDRSP3 CMD_RSP3 = 0xFFFFFFFF << 0 //+ Command Response 3
)

const (
	CMDRSP3n = 0
)

const (
	DATCONT DATA_BUFF_ACC_PORT = 0xFFFFFFFF << 0 //+ Data Content
)

const (
	DATCONTn = 0
)

const (
	CIHB     PRES_STATE = 0x01 << 0  //+ Command Inhibit (CMD)
	CIHB_0   PRES_STATE = 0x00 << 0  //  Can issue command using only CMD line
	CIHB_1   PRES_STATE = 0x01 << 0  //  Cannot issue command
	CDIHB    PRES_STATE = 0x01 << 1  //+ Command Inhibit (DATA)
	CDIHB_0  PRES_STATE = 0x00 << 1  //  Can issue command which uses the DATA line
	CDIHB_1  PRES_STATE = 0x01 << 1  //  Cannot issue command which uses the DATA line
	DLA      PRES_STATE = 0x01 << 2  //+ Data Line Active
	DLA_0    PRES_STATE = 0x00 << 2  //  DATA Line Inactive
	DLA_1    PRES_STATE = 0x01 << 2  //  DATA Line Active
	SDSTB    PRES_STATE = 0x01 << 3  //+ SD Clock Stable
	SDSTB_0  PRES_STATE = 0x00 << 3  //  Clock is changing frequency and not stable.
	SDSTB_1  PRES_STATE = 0x01 << 3  //  Clock is stable.
	IPGOFF   PRES_STATE = 0x01 << 4  //+ IPG_CLK Gated Off Internally
	IPGOFF_0 PRES_STATE = 0x00 << 4  //  IPG_CLK is active.
	IPGOFF_1 PRES_STATE = 0x01 << 4  //  IPG_CLK is gated off.
	HCKOFF   PRES_STATE = 0x01 << 5  //+ HCLK Gated Off Internally
	HCKOFF_0 PRES_STATE = 0x00 << 5  //  HCLK is active.
	HCKOFF_1 PRES_STATE = 0x01 << 5  //  HCLK is gated off.
	PEROFF   PRES_STATE = 0x01 << 6  //+ IPG_PERCLK Gated Off Internally
	PEROFF_0 PRES_STATE = 0x00 << 6  //  IPG_PERCLK is active.
	PEROFF_1 PRES_STATE = 0x01 << 6  //  IPG_PERCLK is gated off.
	SDOFF    PRES_STATE = 0x01 << 7  //+ SD Clock Gated Off Internally
	SDOFF_0  PRES_STATE = 0x00 << 7  //  SD Clock is active.
	SDOFF_1  PRES_STATE = 0x01 << 7  //  SD Clock is gated off.
	WTA      PRES_STATE = 0x01 << 8  //+ Write Transfer Active
	WTA_0    PRES_STATE = 0x00 << 8  //  No valid data
	WTA_1    PRES_STATE = 0x01 << 8  //  Transferring data
	RTA      PRES_STATE = 0x01 << 9  //+ Read Transfer Active
	RTA_0    PRES_STATE = 0x00 << 9  //  No valid data
	RTA_1    PRES_STATE = 0x01 << 9  //  Transferring data
	BWEN     PRES_STATE = 0x01 << 10 //+ Buffer Write Enable
	BWEN_0   PRES_STATE = 0x00 << 10 //  Write disable
	BWEN_1   PRES_STATE = 0x01 << 10 //  Write enable
	BREN     PRES_STATE = 0x01 << 11 //+ Buffer Read Enable
	BREN_0   PRES_STATE = 0x00 << 11 //  Read disable
	BREN_1   PRES_STATE = 0x01 << 11 //  Read enable
	RTR      PRES_STATE = 0x01 << 12 //+ Re-Tuning Request (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	RTR_0    PRES_STATE = 0x00 << 12 //  Fixed or well tuned sampling clock
	RTR_1    PRES_STATE = 0x01 << 12 //  Sampling clock needs re-tuning
	TSCD     PRES_STATE = 0x01 << 15 //+ Tape Select Change Done
	TSCD_0   PRES_STATE = 0x00 << 15 //  Delay cell select change is not finished.
	TSCD_1   PRES_STATE = 0x01 << 15 //  Delay cell select change is finished.
	CINST    PRES_STATE = 0x01 << 16 //+ Card Inserted
	CINST_0  PRES_STATE = 0x00 << 16 //  Power on Reset or No Card
	CINST_1  PRES_STATE = 0x01 << 16 //  Card Inserted
	CDPL     PRES_STATE = 0x01 << 18 //+ Card Detect Pin Level
	CDPL_0   PRES_STATE = 0x00 << 18 //  No card present (CD_B = 1)
	CDPL_1   PRES_STATE = 0x01 << 18 //  Card present (CD_B = 0)
	WPSPL    PRES_STATE = 0x01 << 19 //+ Write Protect Switch Pin Level
	WPSPL_0  PRES_STATE = 0x00 << 19 //  Write protected (WP = 1)
	WPSPL_1  PRES_STATE = 0x01 << 19 //  Write enabled (WP = 0)
	CLSL     PRES_STATE = 0x01 << 23 //+ CMD Line Signal Level
	DLSL     PRES_STATE = 0xFF << 24 //+ DATA[7:0] Line Signal Level
	DATA0    PRES_STATE = 0x00 << 24 //  Data 0 line signal level
	DATA1    PRES_STATE = 0x01 << 24 //  Data 1 line signal level
	DATA2    PRES_STATE = 0x02 << 24 //  Data 2 line signal level
	DATA3    PRES_STATE = 0x03 << 24 //  Data 3 line signal level
	DATA4    PRES_STATE = 0x04 << 24 //  Data 4 line signal level
	DATA5    PRES_STATE = 0x05 << 24 //  Data 5 line signal level
	DATA6    PRES_STATE = 0x06 << 24 //  Data 6 line signal level
	DATA7    PRES_STATE = 0x07 << 24 //  Data 7 line signal level
)

const (
	CIHBn   = 0
	CDIHBn  = 1
	DLAn    = 2
	SDSTBn  = 3
	IPGOFFn = 4
	HCKOFFn = 5
	PEROFFn = 6
	SDOFFn  = 7
	WTAn    = 8
	RTAn    = 9
	BWENn   = 10
	BRENn   = 11
	RTRn    = 12
	TSCDn   = 15
	CINSTn  = 16
	CDPLn   = 18
	WPSPLn  = 19
	CLSLn   = 23
	DLSLn   = 24
)

const (
	LCTL               PROT_CTRL = 0x01 << 0  //+ LED Control
	LCTL_0             PROT_CTRL = 0x00 << 0  //  LED off
	LCTL_1             PROT_CTRL = 0x01 << 0  //  LED on
	DTW                PROT_CTRL = 0x03 << 1  //+ Data Transfer Width
	DTW_0              PROT_CTRL = 0x00 << 1  //  1-bit mode
	DTW_1              PROT_CTRL = 0x01 << 1  //  4-bit mode
	DTW_2              PROT_CTRL = 0x02 << 1  //  8-bit mode
	D3CD               PROT_CTRL = 0x01 << 3  //+ DATA3 as Card Detection Pin
	D3CD_0             PROT_CTRL = 0x00 << 3  //  DATA3 does not monitor Card Insertion
	D3CD_1             PROT_CTRL = 0x01 << 3  //  DATA3 as Card Detection Pin
	EMODE              PROT_CTRL = 0x03 << 4  //+ Endian Mode
	EMODE_0            PROT_CTRL = 0x00 << 4  //  Big Endian Mode
	EMODE_1            PROT_CTRL = 0x01 << 4  //  Half Word Big Endian Mode
	EMODE_2            PROT_CTRL = 0x02 << 4  //  Little Endian Mode
	CDTL               PROT_CTRL = 0x01 << 6  //+ Card Detect Test Level
	CDTL_0             PROT_CTRL = 0x00 << 6  //  Card Detect Test Level is 0, no card inserted
	CDTL_1             PROT_CTRL = 0x01 << 6  //  Card Detect Test Level is 1, card inserted
	CDSS               PROT_CTRL = 0x01 << 7  //+ Card Detect Signal Selection
	CDSS_0             PROT_CTRL = 0x00 << 7  //  Card Detection Level is selected (for normal purpose).
	CDSS_1             PROT_CTRL = 0x01 << 7  //  Card Detection Test Level is selected (for test purpose).
	DMASEL             PROT_CTRL = 0x03 << 8  //+ DMA Select
	DMASEL_0           PROT_CTRL = 0x00 << 8  //  No DMA or Simple DMA is selected
	DMASEL_1           PROT_CTRL = 0x01 << 8  //  ADMA1 is selected
	DMASEL_2           PROT_CTRL = 0x02 << 8  //  ADMA2 is selected
	SABGREQ            PROT_CTRL = 0x01 << 16 //+ Stop At Block Gap Request
	SABGREQ_0          PROT_CTRL = 0x00 << 16 //  Transfer
	SABGREQ_1          PROT_CTRL = 0x01 << 16 //  Stop
	CREQ               PROT_CTRL = 0x01 << 17 //+ Continue Request
	CREQ_0             PROT_CTRL = 0x00 << 17 //  No effect
	CREQ_1             PROT_CTRL = 0x01 << 17 //  Restart
	RWCTL              PROT_CTRL = 0x01 << 18 //+ Read Wait Control
	RWCTL_0            PROT_CTRL = 0x00 << 18 //  Disable Read Wait Control, and stop SD Clock at block gap when SABGREQ bit is set
	RWCTL_1            PROT_CTRL = 0x01 << 18 //  Enable Read Wait Control, and assert Read Wait without stopping SD Clock at block gap when SABGREQ bit is set
	IABG               PROT_CTRL = 0x01 << 19 //+ Interrupt At Block Gap
	IABG_0             PROT_CTRL = 0x00 << 19 //  Disabled
	IABG_1             PROT_CTRL = 0x01 << 19 //  Enabled
	RD_DONE_NO_8CLK    PROT_CTRL = 0x01 << 20 //+ RD_DONE_NO_8CLK
	WECINT             PROT_CTRL = 0x01 << 24 //+ Wakeup Event Enable On Card Interrupt
	WECINT_0           PROT_CTRL = 0x00 << 24 //  Disable
	WECINT_1           PROT_CTRL = 0x01 << 24 //  Enable
	WECINS             PROT_CTRL = 0x01 << 25 //+ Wakeup Event Enable On SD Card Insertion
	WECINS_0           PROT_CTRL = 0x00 << 25 //  Disable
	WECINS_1           PROT_CTRL = 0x01 << 25 //  Enable
	WECRM              PROT_CTRL = 0x01 << 26 //+ Wakeup Event Enable On SD Card Removal
	WECRM_0            PROT_CTRL = 0x00 << 26 //  Disable
	WECRM_1            PROT_CTRL = 0x01 << 26 //  Enable
	BURST_LEN_EN       PROT_CTRL = 0x07 << 27 //+ BURST length enable for INCR, INCR4 / INCR8 / INCR16, INCR4-WRAP / INCR8-WRAP / INCR16-WRAP
	BURST_LEN_EN_1     PROT_CTRL = 0x01 << 27 //  Burst length is enabled for INCR
	NON_EXACT_BLK_RD   PROT_CTRL = 0x01 << 30 //+ NON_EXACT_BLK_RD
	NON_EXACT_BLK_RD_0 PROT_CTRL = 0x00 << 30 //  The block read is exact block read. Host driver doesn't need to issue abort command to terminate this multi-block read.
	NON_EXACT_BLK_RD_1 PROT_CTRL = 0x01 << 30 //  The block read is non-exact block read. Host driver needs to issue abort command to terminate this multi-block read.
)

const (
	LCTLn             = 0
	DTWn              = 1
	D3CDn             = 3
	EMODEn            = 4
	CDTLn             = 6
	CDSSn             = 7
	DMASELn           = 8
	SABGREQn          = 16
	CREQn             = 17
	RWCTLn            = 18
	IABGn             = 19
	RD_DONE_NO_8CLKn  = 20
	WECINTn           = 24
	WECINSn           = 25
	WECRMn            = 26
	BURST_LEN_ENn     = 27
	NON_EXACT_BLK_RDn = 30
)

const (
	DVS       SYS_CTRL = 0x0F << 4  //+ Divisor
	DVS_0     SYS_CTRL = 0x00 << 4  //  Divide-by-1
	DVS_1     SYS_CTRL = 0x01 << 4  //  Divide-by-2
	DVS_14    SYS_CTRL = 0x0E << 4  //  Divide-by-15
	DVS_15    SYS_CTRL = 0x0F << 4  //  Divide-by-16
	SDCLKFS   SYS_CTRL = 0xFF << 8  //+ SDCLK Frequency Select
	DTOCV     SYS_CTRL = 0x0F << 16 //+ Data Timeout Counter Value
	DTOCV_0   SYS_CTRL = 0x00 << 16 //  SDCLK x 2 14
	DTOCV_1   SYS_CTRL = 0x01 << 16 //  SDCLK x 2 15
	DTOCV_13  SYS_CTRL = 0x0D << 16 //  SDCLK x 2 27
	DTOCV_14  SYS_CTRL = 0x0E << 16 //  SDCLK x 2 28
	DTOCV_15  SYS_CTRL = 0x0F << 16 //  SDCLK x 2 29
	IPP_RST_N SYS_CTRL = 0x01 << 23 //+ IPP_RST_N
	RSTA      SYS_CTRL = 0x01 << 24 //+ Software Reset For ALL
	RSTA_0    SYS_CTRL = 0x00 << 24 //  No Reset
	RSTA_1    SYS_CTRL = 0x01 << 24 //  Reset
	RSTC      SYS_CTRL = 0x01 << 25 //+ Software Reset For CMD Line
	RSTC_0    SYS_CTRL = 0x00 << 25 //  No Reset
	RSTC_1    SYS_CTRL = 0x01 << 25 //  Reset
	RSTD      SYS_CTRL = 0x01 << 26 //+ Software Reset For DATA Line
	RSTD_0    SYS_CTRL = 0x00 << 26 //  No Reset
	RSTD_1    SYS_CTRL = 0x01 << 26 //  Reset
	INITA     SYS_CTRL = 0x01 << 27 //+ Initialization Active
	RSTT      SYS_CTRL = 0x01 << 28 //+ Reset Tuning
)

const (
	DVSn       = 4
	SDCLKFSn   = 8
	DTOCVn     = 16
	IPP_RST_Nn = 23
	RSTAn      = 24
	RSTCn      = 25
	RSTDn      = 26
	INITAn     = 27
	RSTTn      = 28
)

const (
	CC      INT_STATUS = 0x01 << 0  //+ Command Complete
	CC_0    INT_STATUS = 0x00 << 0  //  Command not complete
	CC_1    INT_STATUS = 0x01 << 0  //  Command complete
	TC      INT_STATUS = 0x01 << 1  //+ Transfer Complete
	TC_0    INT_STATUS = 0x00 << 1  //  Transfer not complete
	TC_1    INT_STATUS = 0x01 << 1  //  Transfer complete
	BGE     INT_STATUS = 0x01 << 2  //+ Block Gap Event
	BGE_0   INT_STATUS = 0x00 << 2  //  No block gap event
	BGE_1   INT_STATUS = 0x01 << 2  //  Transaction stopped at block gap
	DINT    INT_STATUS = 0x01 << 3  //+ DMA Interrupt
	DINT_0  INT_STATUS = 0x00 << 3  //  No DMA Interrupt
	DINT_1  INT_STATUS = 0x01 << 3  //  DMA Interrupt is generated
	BWR     INT_STATUS = 0x01 << 4  //+ Buffer Write Ready
	BWR_0   INT_STATUS = 0x00 << 4  //  Not ready to write buffer
	BWR_1   INT_STATUS = 0x01 << 4  //  Ready to write buffer:
	BRR     INT_STATUS = 0x01 << 5  //+ Buffer Read Ready
	BRR_0   INT_STATUS = 0x00 << 5  //  Not ready to read buffer
	BRR_1   INT_STATUS = 0x01 << 5  //  Ready to read buffer
	CINS    INT_STATUS = 0x01 << 6  //+ Card Insertion
	CINS_0  INT_STATUS = 0x00 << 6  //  Card state unstable or removed
	CINS_1  INT_STATUS = 0x01 << 6  //  Card inserted
	CRM     INT_STATUS = 0x01 << 7  //+ Card Removal
	CRM_0   INT_STATUS = 0x00 << 7  //  Card state unstable or inserted
	CRM_1   INT_STATUS = 0x01 << 7  //  Card removed
	CINT    INT_STATUS = 0x01 << 8  //+ Card Interrupt
	CINT_0  INT_STATUS = 0x00 << 8  //  No Card Interrupt
	CINT_1  INT_STATUS = 0x01 << 8  //  Generate Card Interrupt
	RTE     INT_STATUS = 0x01 << 12 //+ Re-Tuning Event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	RTE_0   INT_STATUS = 0x00 << 12 //  Re-Tuning is not required
	RTE_1   INT_STATUS = 0x01 << 12 //  Re-Tuning should be performed
	TP      INT_STATUS = 0x01 << 14 //+ Tuning Pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
	CTOE    INT_STATUS = 0x01 << 16 //+ Command Timeout Error
	CTOE_0  INT_STATUS = 0x00 << 16 //  No Error
	CTOE_1  INT_STATUS = 0x01 << 16 //  Time out
	CCE     INT_STATUS = 0x01 << 17 //+ Command CRC Error
	CCE_0   INT_STATUS = 0x00 << 17 //  No Error
	CCE_1   INT_STATUS = 0x01 << 17 //  CRC Error Generated.
	CEBE    INT_STATUS = 0x01 << 18 //+ Command End Bit Error
	CEBE_0  INT_STATUS = 0x00 << 18 //  No Error
	CEBE_1  INT_STATUS = 0x01 << 18 //  End Bit Error Generated
	CIE     INT_STATUS = 0x01 << 19 //+ Command Index Error
	CIE_0   INT_STATUS = 0x00 << 19 //  No Error
	CIE_1   INT_STATUS = 0x01 << 19 //  Error
	DTOE    INT_STATUS = 0x01 << 20 //+ Data Timeout Error
	DTOE_0  INT_STATUS = 0x00 << 20 //  No Error
	DTOE_1  INT_STATUS = 0x01 << 20 //  Time out
	DCE     INT_STATUS = 0x01 << 21 //+ Data CRC Error
	DCE_0   INT_STATUS = 0x00 << 21 //  No Error
	DCE_1   INT_STATUS = 0x01 << 21 //  Error
	DEBE    INT_STATUS = 0x01 << 22 //+ Data End Bit Error
	DEBE_0  INT_STATUS = 0x00 << 22 //  No Error
	DEBE_1  INT_STATUS = 0x01 << 22 //  Error
	AC12E   INT_STATUS = 0x01 << 24 //+ Auto CMD12 Error
	AC12E_0 INT_STATUS = 0x00 << 24 //  No Error
	AC12E_1 INT_STATUS = 0x01 << 24 //  Error
	TNE     INT_STATUS = 0x01 << 26 //+ Tuning Error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
	DMAE    INT_STATUS = 0x01 << 28 //+ DMA Error
	DMAE_0  INT_STATUS = 0x00 << 28 //  No Error
	DMAE_1  INT_STATUS = 0x01 << 28 //  Error
)

const (
	CCn    = 0
	TCn    = 1
	BGEn   = 2
	DINTn  = 3
	BWRn   = 4
	BRRn   = 5
	CINSn  = 6
	CRMn   = 7
	CINTn  = 8
	RTEn   = 12
	TPn    = 14
	CTOEn  = 16
	CCEn   = 17
	CEBEn  = 18
	CIEn   = 19
	DTOEn  = 20
	DCEn   = 21
	DEBEn  = 22
	AC12En = 24
	TNEn   = 26
	DMAEn  = 28
)

const (
	CCSEN      INT_STATUS_EN = 0x01 << 0  //+ Command Complete Status Enable
	CCSEN_0    INT_STATUS_EN = 0x00 << 0  //  Masked
	CCSEN_1    INT_STATUS_EN = 0x01 << 0  //  Enabled
	TCSEN      INT_STATUS_EN = 0x01 << 1  //+ Transfer Complete Status Enable
	TCSEN_0    INT_STATUS_EN = 0x00 << 1  //  Masked
	TCSEN_1    INT_STATUS_EN = 0x01 << 1  //  Enabled
	BGESEN     INT_STATUS_EN = 0x01 << 2  //+ Block Gap Event Status Enable
	BGESEN_0   INT_STATUS_EN = 0x00 << 2  //  Masked
	BGESEN_1   INT_STATUS_EN = 0x01 << 2  //  Enabled
	DINTSEN    INT_STATUS_EN = 0x01 << 3  //+ DMA Interrupt Status Enable
	DINTSEN_0  INT_STATUS_EN = 0x00 << 3  //  Masked
	DINTSEN_1  INT_STATUS_EN = 0x01 << 3  //  Enabled
	BWRSEN     INT_STATUS_EN = 0x01 << 4  //+ Buffer Write Ready Status Enable
	BWRSEN_0   INT_STATUS_EN = 0x00 << 4  //  Masked
	BWRSEN_1   INT_STATUS_EN = 0x01 << 4  //  Enabled
	BRRSEN     INT_STATUS_EN = 0x01 << 5  //+ Buffer Read Ready Status Enable
	BRRSEN_0   INT_STATUS_EN = 0x00 << 5  //  Masked
	BRRSEN_1   INT_STATUS_EN = 0x01 << 5  //  Enabled
	CINSSEN    INT_STATUS_EN = 0x01 << 6  //+ Card Insertion Status Enable
	CINSSEN_0  INT_STATUS_EN = 0x00 << 6  //  Masked
	CINSSEN_1  INT_STATUS_EN = 0x01 << 6  //  Enabled
	CRMSEN     INT_STATUS_EN = 0x01 << 7  //+ Card Removal Status Enable
	CRMSEN_0   INT_STATUS_EN = 0x00 << 7  //  Masked
	CRMSEN_1   INT_STATUS_EN = 0x01 << 7  //  Enabled
	CINTSEN    INT_STATUS_EN = 0x01 << 8  //+ Card Interrupt Status Enable
	CINTSEN_0  INT_STATUS_EN = 0x00 << 8  //  Masked
	CINTSEN_1  INT_STATUS_EN = 0x01 << 8  //  Enabled
	RTESEN     INT_STATUS_EN = 0x01 << 12 //+ Re-Tuning Event Status Enable
	RTESEN_0   INT_STATUS_EN = 0x00 << 12 //  Masked
	RTESEN_1   INT_STATUS_EN = 0x01 << 12 //  Enabled
	TPSEN      INT_STATUS_EN = 0x01 << 14 //+ Tuning Pass Status Enable
	TPSEN_0    INT_STATUS_EN = 0x00 << 14 //  Masked
	TPSEN_1    INT_STATUS_EN = 0x01 << 14 //  Enabled
	CTOESEN    INT_STATUS_EN = 0x01 << 16 //+ Command Timeout Error Status Enable
	CTOESEN_0  INT_STATUS_EN = 0x00 << 16 //  Masked
	CTOESEN_1  INT_STATUS_EN = 0x01 << 16 //  Enabled
	CCESEN     INT_STATUS_EN = 0x01 << 17 //+ Command CRC Error Status Enable
	CCESEN_0   INT_STATUS_EN = 0x00 << 17 //  Masked
	CCESEN_1   INT_STATUS_EN = 0x01 << 17 //  Enabled
	CEBESEN    INT_STATUS_EN = 0x01 << 18 //+ Command End Bit Error Status Enable
	CEBESEN_0  INT_STATUS_EN = 0x00 << 18 //  Masked
	CEBESEN_1  INT_STATUS_EN = 0x01 << 18 //  Enabled
	CIESEN     INT_STATUS_EN = 0x01 << 19 //+ Command Index Error Status Enable
	CIESEN_0   INT_STATUS_EN = 0x00 << 19 //  Masked
	CIESEN_1   INT_STATUS_EN = 0x01 << 19 //  Enabled
	DTOESEN    INT_STATUS_EN = 0x01 << 20 //+ Data Timeout Error Status Enable
	DTOESEN_0  INT_STATUS_EN = 0x00 << 20 //  Masked
	DTOESEN_1  INT_STATUS_EN = 0x01 << 20 //  Enabled
	DCESEN     INT_STATUS_EN = 0x01 << 21 //+ Data CRC Error Status Enable
	DCESEN_0   INT_STATUS_EN = 0x00 << 21 //  Masked
	DCESEN_1   INT_STATUS_EN = 0x01 << 21 //  Enabled
	DEBESEN    INT_STATUS_EN = 0x01 << 22 //+ Data End Bit Error Status Enable
	DEBESEN_0  INT_STATUS_EN = 0x00 << 22 //  Masked
	DEBESEN_1  INT_STATUS_EN = 0x01 << 22 //  Enabled
	AC12ESEN   INT_STATUS_EN = 0x01 << 24 //+ Auto CMD12 Error Status Enable
	AC12ESEN_0 INT_STATUS_EN = 0x00 << 24 //  Masked
	AC12ESEN_1 INT_STATUS_EN = 0x01 << 24 //  Enabled
	TNESEN     INT_STATUS_EN = 0x01 << 26 //+ Tuning Error Status Enable
	TNESEN_0   INT_STATUS_EN = 0x00 << 26 //  Masked
	TNESEN_1   INT_STATUS_EN = 0x01 << 26 //  Enabled
	DMAESEN    INT_STATUS_EN = 0x01 << 28 //+ DMA Error Status Enable
	DMAESEN_0  INT_STATUS_EN = 0x00 << 28 //  Masked
	DMAESEN_1  INT_STATUS_EN = 0x01 << 28 //  Enabled
)

const (
	CCSENn    = 0
	TCSENn    = 1
	BGESENn   = 2
	DINTSENn  = 3
	BWRSENn   = 4
	BRRSENn   = 5
	CINSSENn  = 6
	CRMSENn   = 7
	CINTSENn  = 8
	RTESENn   = 12
	TPSENn    = 14
	CTOESENn  = 16
	CCESENn   = 17
	CEBESENn  = 18
	CIESENn   = 19
	DTOESENn  = 20
	DCESENn   = 21
	DEBESENn  = 22
	AC12ESENn = 24
	TNESENn   = 26
	DMAESENn  = 28
)

const (
	CCIEN      INT_SIGNAL_EN = 0x01 << 0  //+ Command Complete Interrupt Enable
	CCIEN_0    INT_SIGNAL_EN = 0x00 << 0  //  Masked
	CCIEN_1    INT_SIGNAL_EN = 0x01 << 0  //  Enabled
	TCIEN      INT_SIGNAL_EN = 0x01 << 1  //+ Transfer Complete Interrupt Enable
	TCIEN_0    INT_SIGNAL_EN = 0x00 << 1  //  Masked
	TCIEN_1    INT_SIGNAL_EN = 0x01 << 1  //  Enabled
	BGEIEN     INT_SIGNAL_EN = 0x01 << 2  //+ Block Gap Event Interrupt Enable
	BGEIEN_0   INT_SIGNAL_EN = 0x00 << 2  //  Masked
	BGEIEN_1   INT_SIGNAL_EN = 0x01 << 2  //  Enabled
	DINTIEN    INT_SIGNAL_EN = 0x01 << 3  //+ DMA Interrupt Enable
	DINTIEN_0  INT_SIGNAL_EN = 0x00 << 3  //  Masked
	DINTIEN_1  INT_SIGNAL_EN = 0x01 << 3  //  Enabled
	BWRIEN     INT_SIGNAL_EN = 0x01 << 4  //+ Buffer Write Ready Interrupt Enable
	BWRIEN_0   INT_SIGNAL_EN = 0x00 << 4  //  Masked
	BWRIEN_1   INT_SIGNAL_EN = 0x01 << 4  //  Enabled
	BRRIEN     INT_SIGNAL_EN = 0x01 << 5  //+ Buffer Read Ready Interrupt Enable
	BRRIEN_0   INT_SIGNAL_EN = 0x00 << 5  //  Masked
	BRRIEN_1   INT_SIGNAL_EN = 0x01 << 5  //  Enabled
	CINSIEN    INT_SIGNAL_EN = 0x01 << 6  //+ Card Insertion Interrupt Enable
	CINSIEN_0  INT_SIGNAL_EN = 0x00 << 6  //  Masked
	CINSIEN_1  INT_SIGNAL_EN = 0x01 << 6  //  Enabled
	CRMIEN     INT_SIGNAL_EN = 0x01 << 7  //+ Card Removal Interrupt Enable
	CRMIEN_0   INT_SIGNAL_EN = 0x00 << 7  //  Masked
	CRMIEN_1   INT_SIGNAL_EN = 0x01 << 7  //  Enabled
	CINTIEN    INT_SIGNAL_EN = 0x01 << 8  //+ Card Interrupt Interrupt Enable
	CINTIEN_0  INT_SIGNAL_EN = 0x00 << 8  //  Masked
	CINTIEN_1  INT_SIGNAL_EN = 0x01 << 8  //  Enabled
	RTEIEN     INT_SIGNAL_EN = 0x01 << 12 //+ Re-Tuning Event Interrupt Enable
	RTEIEN_0   INT_SIGNAL_EN = 0x00 << 12 //  Masked
	RTEIEN_1   INT_SIGNAL_EN = 0x01 << 12 //  Enabled
	TPIEN      INT_SIGNAL_EN = 0x01 << 14 //+ Tuning Pass Interrupt Enable
	TPIEN_0    INT_SIGNAL_EN = 0x00 << 14 //  Masked
	TPIEN_1    INT_SIGNAL_EN = 0x01 << 14 //  Enabled
	CTOEIEN    INT_SIGNAL_EN = 0x01 << 16 //+ Command Timeout Error Interrupt Enable
	CTOEIEN_0  INT_SIGNAL_EN = 0x00 << 16 //  Masked
	CTOEIEN_1  INT_SIGNAL_EN = 0x01 << 16 //  Enabled
	CCEIEN     INT_SIGNAL_EN = 0x01 << 17 //+ Command CRC Error Interrupt Enable
	CCEIEN_0   INT_SIGNAL_EN = 0x00 << 17 //  Masked
	CCEIEN_1   INT_SIGNAL_EN = 0x01 << 17 //  Enabled
	CEBEIEN    INT_SIGNAL_EN = 0x01 << 18 //+ Command End Bit Error Interrupt Enable
	CEBEIEN_0  INT_SIGNAL_EN = 0x00 << 18 //  Masked
	CEBEIEN_1  INT_SIGNAL_EN = 0x01 << 18 //  Enabled
	CIEIEN     INT_SIGNAL_EN = 0x01 << 19 //+ Command Index Error Interrupt Enable
	CIEIEN_0   INT_SIGNAL_EN = 0x00 << 19 //  Masked
	CIEIEN_1   INT_SIGNAL_EN = 0x01 << 19 //  Enabled
	DTOEIEN    INT_SIGNAL_EN = 0x01 << 20 //+ Data Timeout Error Interrupt Enable
	DTOEIEN_0  INT_SIGNAL_EN = 0x00 << 20 //  Masked
	DTOEIEN_1  INT_SIGNAL_EN = 0x01 << 20 //  Enabled
	DCEIEN     INT_SIGNAL_EN = 0x01 << 21 //+ Data CRC Error Interrupt Enable
	DCEIEN_0   INT_SIGNAL_EN = 0x00 << 21 //  Masked
	DCEIEN_1   INT_SIGNAL_EN = 0x01 << 21 //  Enabled
	DEBEIEN    INT_SIGNAL_EN = 0x01 << 22 //+ Data End Bit Error Interrupt Enable
	DEBEIEN_0  INT_SIGNAL_EN = 0x00 << 22 //  Masked
	DEBEIEN_1  INT_SIGNAL_EN = 0x01 << 22 //  Enabled
	AC12EIEN   INT_SIGNAL_EN = 0x01 << 24 //+ Auto CMD12 Error Interrupt Enable
	AC12EIEN_0 INT_SIGNAL_EN = 0x00 << 24 //  Masked
	AC12EIEN_1 INT_SIGNAL_EN = 0x01 << 24 //  Enabled
	TNEIEN     INT_SIGNAL_EN = 0x01 << 26 //+ Tuning Error Interrupt Enable
	TNEIEN_0   INT_SIGNAL_EN = 0x00 << 26 //  Masked
	TNEIEN_1   INT_SIGNAL_EN = 0x01 << 26 //  Enabled
	DMAEIEN    INT_SIGNAL_EN = 0x01 << 28 //+ DMA Error Interrupt Enable
	DMAEIEN_0  INT_SIGNAL_EN = 0x00 << 28 //  Masked
	DMAEIEN_1  INT_SIGNAL_EN = 0x01 << 28 //  Enable
)

const (
	CCIENn    = 0
	TCIENn    = 1
	BGEIENn   = 2
	DINTIENn  = 3
	BWRIENn   = 4
	BRRIENn   = 5
	CINSIENn  = 6
	CRMIENn   = 7
	CINTIENn  = 8
	RTEIENn   = 12
	TPIENn    = 14
	CTOEIENn  = 16
	CCEIENn   = 17
	CEBEIENn  = 18
	CIEIENn   = 19
	DTOEIENn  = 20
	DCEIENn   = 21
	DEBEIENn  = 22
	AC12EIENn = 24
	TNEIENn   = 26
	DMAEIENn  = 28
)

const (
	AC12NE         AUTOCMD12_ERR_STATUS = 0x01 << 0  //+ Auto CMD12 Not Executed
	AC12NE_0       AUTOCMD12_ERR_STATUS = 0x00 << 0  //  Executed
	AC12NE_1       AUTOCMD12_ERR_STATUS = 0x01 << 0  //  Not executed
	AC12TOE        AUTOCMD12_ERR_STATUS = 0x01 << 1  //+ Auto CMD12 / 23 Timeout Error
	AC12TOE_0      AUTOCMD12_ERR_STATUS = 0x00 << 1  //  No error
	AC12TOE_1      AUTOCMD12_ERR_STATUS = 0x01 << 1  //  Time out
	AC12EBE        AUTOCMD12_ERR_STATUS = 0x01 << 2  //+ Auto CMD12 / 23 End Bit Error
	AC12EBE_0      AUTOCMD12_ERR_STATUS = 0x00 << 2  //  No error
	AC12EBE_1      AUTOCMD12_ERR_STATUS = 0x01 << 2  //  End Bit Error Generated
	AC12CE         AUTOCMD12_ERR_STATUS = 0x01 << 3  //+ Auto CMD12 / 23 CRC Error
	AC12CE_0       AUTOCMD12_ERR_STATUS = 0x00 << 3  //  No CRC error
	AC12CE_1       AUTOCMD12_ERR_STATUS = 0x01 << 3  //  CRC Error Met in Auto CMD12/23 Response
	AC12IE         AUTOCMD12_ERR_STATUS = 0x01 << 4  //+ Auto CMD12 / 23 Index Error
	AC12IE_0       AUTOCMD12_ERR_STATUS = 0x00 << 4  //  No error
	AC12IE_1       AUTOCMD12_ERR_STATUS = 0x01 << 4  //  Error, the CMD index in response is not CMD12/23
	CNIBAC12E      AUTOCMD12_ERR_STATUS = 0x01 << 7  //+ Command Not Issued By Auto CMD12 Error
	CNIBAC12E_0    AUTOCMD12_ERR_STATUS = 0x00 << 7  //  No error
	CNIBAC12E_1    AUTOCMD12_ERR_STATUS = 0x01 << 7  //  Not Issued
	EXECUTE_TUNING AUTOCMD12_ERR_STATUS = 0x01 << 22 //+ Execute Tuning
	SMP_CLK_SEL    AUTOCMD12_ERR_STATUS = 0x01 << 23 //+ Sample Clock Select
	SMP_CLK_SEL_0  AUTOCMD12_ERR_STATUS = 0x00 << 23 //  Fixed clock is used to sample data
	SMP_CLK_SEL_1  AUTOCMD12_ERR_STATUS = 0x01 << 23 //  Tuned clock is used to sample data
)

const (
	AC12NEn         = 0
	AC12TOEn        = 1
	AC12EBEn        = 2
	AC12CEn         = 3
	AC12IEn         = 4
	CNIBAC12En      = 7
	EXECUTE_TUNINGn = 22
	SMP_CLK_SELn    = 23
)

const (
	SDR50_SUPPORT       HOST_CTRL_CAP = 0x01 << 0  //+ SDR50 support
	SDR104_SUPPORT      HOST_CTRL_CAP = 0x01 << 1  //+ SDR104 support
	DDR50_SUPPORT       HOST_CTRL_CAP = 0x01 << 2  //+ DDR50 support
	TIME_COUNT_RETUNING HOST_CTRL_CAP = 0x0F << 8  //+ Time Counter for Retuning
	USE_TUNING_SDR50    HOST_CTRL_CAP = 0x01 << 13 //+ Use Tuning for SDR50
	USE_TUNING_SDR50_0  HOST_CTRL_CAP = 0x00 << 13 //  SDR does not require tuning
	USE_TUNING_SDR50_1  HOST_CTRL_CAP = 0x01 << 13 //  SDR50 requires tuning
	RETUNING_MODE       HOST_CTRL_CAP = 0x03 << 14 //+ Retuning Mode
	RETUNING_MODE_0     HOST_CTRL_CAP = 0x00 << 14 //  Mode 1
	RETUNING_MODE_1     HOST_CTRL_CAP = 0x01 << 14 //  Mode 2
	RETUNING_MODE_2     HOST_CTRL_CAP = 0x02 << 14 //  Mode 3
	MBL                 HOST_CTRL_CAP = 0x07 << 16 //+ Max Block Length
	MBL_0               HOST_CTRL_CAP = 0x00 << 16 //  512 bytes
	MBL_1               HOST_CTRL_CAP = 0x01 << 16 //  1024 bytes
	MBL_2               HOST_CTRL_CAP = 0x02 << 16 //  2048 bytes
	MBL_3               HOST_CTRL_CAP = 0x03 << 16 //  4096 bytes
	ADMAS               HOST_CTRL_CAP = 0x01 << 20 //+ ADMA Support
	ADMAS_0             HOST_CTRL_CAP = 0x00 << 20 //  Advanced DMA Not supported
	ADMAS_1             HOST_CTRL_CAP = 0x01 << 20 //  Advanced DMA Supported
	HSS                 HOST_CTRL_CAP = 0x01 << 21 //+ High Speed Support
	HSS_0               HOST_CTRL_CAP = 0x00 << 21 //  High Speed Not Supported
	HSS_1               HOST_CTRL_CAP = 0x01 << 21 //  High Speed Supported
	DMAS                HOST_CTRL_CAP = 0x01 << 22 //+ DMA Support
	DMAS_0              HOST_CTRL_CAP = 0x00 << 22 //  DMA not supported
	DMAS_1              HOST_CTRL_CAP = 0x01 << 22 //  DMA Supported
	SRS                 HOST_CTRL_CAP = 0x01 << 23 //+ Suspend / Resume Support
	SRS_0               HOST_CTRL_CAP = 0x00 << 23 //  Not supported
	SRS_1               HOST_CTRL_CAP = 0x01 << 23 //  Supported
	VS33                HOST_CTRL_CAP = 0x01 << 24 //+ Voltage Support 3.3V
	VS33_0              HOST_CTRL_CAP = 0x00 << 24 //  3.3V not supported
	VS33_1              HOST_CTRL_CAP = 0x01 << 24 //  3.3V supported
	VS30                HOST_CTRL_CAP = 0x01 << 25 //+ Voltage Support 3.0 V
	VS30_0              HOST_CTRL_CAP = 0x00 << 25 //  3.0V not supported
	VS30_1              HOST_CTRL_CAP = 0x01 << 25 //  3.0V supported
	VS18                HOST_CTRL_CAP = 0x01 << 26 //+ Voltage Support 1.8 V
	VS18_0              HOST_CTRL_CAP = 0x00 << 26 //  1.8V not supported
	VS18_1              HOST_CTRL_CAP = 0x01 << 26 //  1.8V supported
)

const (
	SDR50_SUPPORTn       = 0
	SDR104_SUPPORTn      = 1
	DDR50_SUPPORTn       = 2
	TIME_COUNT_RETUNINGn = 8
	USE_TUNING_SDR50n    = 13
	RETUNING_MODEn       = 14
	MBLn                 = 16
	ADMASn               = 20
	HSSn                 = 21
	DMASn                = 22
	SRSn                 = 23
	VS33n                = 24
	VS30n                = 25
	VS18n                = 26
)

const (
	RD_WML      WTMK_LVL = 0xFF << 0  //+ Read Watermark Level
	RD_BRST_LEN WTMK_LVL = 0x1F << 8  //+ Read Burst Length Due to system restriction, the actual burst length may not exceed 16.
	WR_WML      WTMK_LVL = 0xFF << 16 //+ Write Watermark Level
	WR_BRST_LEN WTMK_LVL = 0x1F << 24 //+ Write Burst Length Due to system restriction, the actual burst length may not exceed 16.
)

const (
	RD_WMLn      = 0
	RD_BRST_LENn = 8
	WR_WMLn      = 16
	WR_BRST_LENn = 24
)

const (
	DMAEN          MIX_CTRL = 0x01 << 0  //+ DMA Enable
	DMAEN_0        MIX_CTRL = 0x00 << 0  //  Disable
	DMAEN_1        MIX_CTRL = 0x01 << 0  //  Enable
	BCEN           MIX_CTRL = 0x01 << 1  //+ Block Count Enable
	BCEN_0         MIX_CTRL = 0x00 << 1  //  Disable
	BCEN_1         MIX_CTRL = 0x01 << 1  //  Enable
	AC12EN         MIX_CTRL = 0x01 << 2  //+ Auto CMD12 Enable
	AC12EN_0       MIX_CTRL = 0x00 << 2  //  Disable
	AC12EN_1       MIX_CTRL = 0x01 << 2  //  Enable
	DDR_EN         MIX_CTRL = 0x01 << 3  //+ Dual Data Rate mode selection
	DTDSEL         MIX_CTRL = 0x01 << 4  //+ Data Transfer Direction Select
	DTDSEL_0       MIX_CTRL = 0x00 << 4  //  Write (Host to Card)
	DTDSEL_1       MIX_CTRL = 0x01 << 4  //  Read (Card to Host)
	MSBSEL         MIX_CTRL = 0x01 << 5  //+ Multi / Single Block Select
	MSBSEL_0       MIX_CTRL = 0x00 << 5  //  Single Block
	MSBSEL_1       MIX_CTRL = 0x01 << 5  //  Multiple Blocks
	NIBBLE_POS     MIX_CTRL = 0x01 << 6  //+ NIBBLE_POS
	AC23EN         MIX_CTRL = 0x01 << 7  //+ Auto CMD23 Enable
	EXE_TUNE       MIX_CTRL = 0x01 << 22 //+ Execute Tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
	EXE_TUNE_0     MIX_CTRL = 0x00 << 22 //  Not Tuned or Tuning Completed
	EXE_TUNE_1     MIX_CTRL = 0x01 << 22 //  Execute Tuning
	SMP_CLK_SEL    MIX_CTRL = 0x01 << 23 //+ SMP_CLK_SEL
	SMP_CLK_SEL_0  MIX_CTRL = 0x00 << 23 //  Fixed clock is used to sample data / cmd
	SMP_CLK_SEL_1  MIX_CTRL = 0x01 << 23 //  Tuned clock is used to sample data / cmd
	AUTO_TUNE_EN   MIX_CTRL = 0x01 << 24 //+ Auto Tuning Enable (Only used for SD3.0, SDR104 mode and and EMMC HS200 mode)
	AUTO_TUNE_EN_0 MIX_CTRL = 0x00 << 24 //  Disable auto tuning
	AUTO_TUNE_EN_1 MIX_CTRL = 0x01 << 24 //  Enable auto tuning
	FBCLK_SEL      MIX_CTRL = 0x01 << 25 //+ Feedback Clock Source Selection (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
	FBCLK_SEL_0    MIX_CTRL = 0x00 << 25 //  Feedback clock comes from the loopback CLK
	FBCLK_SEL_1    MIX_CTRL = 0x01 << 25 //  Feedback clock comes from the ipp_card_clk_out
)

const (
	DMAENn        = 0
	BCENn         = 1
	AC12ENn       = 2
	DDR_ENn       = 3
	DTDSELn       = 4
	MSBSELn       = 5
	NIBBLE_POSn   = 6
	AC23ENn       = 7
	EXE_TUNEn     = 22
	SMP_CLK_SELn  = 23
	AUTO_TUNE_ENn = 24
	FBCLK_SELn    = 25
)

const (
	FEVTAC12NE    FORCE_EVENT = 0x01 << 0  //+ Force Event Auto Command 12 Not Executed
	FEVTAC12TOE   FORCE_EVENT = 0x01 << 1  //+ Force Event Auto Command 12 Time Out Error
	FEVTAC12CE    FORCE_EVENT = 0x01 << 2  //+ Force Event Auto Command 12 CRC Error
	FEVTAC12EBE   FORCE_EVENT = 0x01 << 3  //+ Force Event Auto Command 12 End Bit Error
	FEVTAC12IE    FORCE_EVENT = 0x01 << 4  //+ Force Event Auto Command 12 Index Error
	FEVTCNIBAC12E FORCE_EVENT = 0x01 << 7  //+ Force Event Command Not Executed By Auto Command 12 Error
	FEVTCTOE      FORCE_EVENT = 0x01 << 16 //+ Force Event Command Time Out Error
	FEVTCCE       FORCE_EVENT = 0x01 << 17 //+ Force Event Command CRC Error
	FEVTCEBE      FORCE_EVENT = 0x01 << 18 //+ Force Event Command End Bit Error
	FEVTCIE       FORCE_EVENT = 0x01 << 19 //+ Force Event Command Index Error
	FEVTDTOE      FORCE_EVENT = 0x01 << 20 //+ Force Event Data Time Out Error
	FEVTDCE       FORCE_EVENT = 0x01 << 21 //+ Force Event Data CRC Error
	FEVTDEBE      FORCE_EVENT = 0x01 << 22 //+ Force Event Data End Bit Error
	FEVTAC12E     FORCE_EVENT = 0x01 << 24 //+ Force Event Auto Command 12 Error
	FEVTTNE       FORCE_EVENT = 0x01 << 26 //+ Force Tuning Error
	FEVTDMAE      FORCE_EVENT = 0x01 << 28 //+ Force Event DMA Error
	FEVTCINT      FORCE_EVENT = 0x01 << 31 //+ Force Event Card Interrupt
)

const (
	FEVTAC12NEn    = 0
	FEVTAC12TOEn   = 1
	FEVTAC12CEn    = 2
	FEVTAC12EBEn   = 3
	FEVTAC12IEn    = 4
	FEVTCNIBAC12En = 7
	FEVTCTOEn      = 16
	FEVTCCEn       = 17
	FEVTCEBEn      = 18
	FEVTCIEn       = 19
	FEVTDTOEn      = 20
	FEVTDCEn       = 21
	FEVTDEBEn      = 22
	FEVTAC12En     = 24
	FEVTTNEn       = 26
	FEVTDMAEn      = 28
	FEVTCINTn      = 31
)

const (
	ADMAES    ADMA_ERR_STATUS = 0x03 << 0 //+ ADMA Error State (when ADMA Error is occurred)
	ADMALME   ADMA_ERR_STATUS = 0x01 << 2 //+ ADMA Length Mismatch Error
	ADMALME_0 ADMA_ERR_STATUS = 0x00 << 2 //  No Error
	ADMALME_1 ADMA_ERR_STATUS = 0x01 << 2 //  Error
	ADMADCE   ADMA_ERR_STATUS = 0x01 << 3 //+ ADMA Descriptor Error
	ADMADCE_0 ADMA_ERR_STATUS = 0x00 << 3 //  No Error
	ADMADCE_1 ADMA_ERR_STATUS = 0x01 << 3 //  Error
)

const (
	ADMAESn  = 0
	ADMALMEn = 2
	ADMADCEn = 3
)

const (
	ADS_ADDR ADMA_SYS_ADDR = 0x3FFFFFFF << 2 //+ ADMA System Address
)

const (
	ADS_ADDRn = 2
)

const (
	DLL_CTRL_ENABLE           DLL_CTRL = 0x01 << 0  //+ DLL_CTRL_ENABLE
	DLL_CTRL_RESET            DLL_CTRL = 0x01 << 1  //+ DLL_CTRL_RESET
	DLL_CTRL_SLV_FORCE_UPD    DLL_CTRL = 0x01 << 2  //+ DLL_CTRL_SLV_FORCE_UPD
	DLL_CTRL_SLV_DLY_TARGET0  DLL_CTRL = 0x0F << 3  //+ DLL_CTRL_SLV_DLY_TARGET0
	DLL_CTRL_GATE_UPDATE      DLL_CTRL = 0x01 << 7  //+ DLL_CTRL_GATE_UPDATE
	DLL_CTRL_SLV_OVERRIDE     DLL_CTRL = 0x01 << 8  //+ DLL_CTRL_SLV_OVERRIDE
	DLL_CTRL_SLV_OVERRIDE_VAL DLL_CTRL = 0x7F << 9  //+ DLL_CTRL_SLV_OVERRIDE_VAL
	DLL_CTRL_SLV_DLY_TARGET1  DLL_CTRL = 0x07 << 16 //+ DLL_CTRL_SLV_DLY_TARGET1
	DLL_CTRL_SLV_UPDATE_INT   DLL_CTRL = 0xFF << 20 //+ DLL_CTRL_SLV_UPDATE_INT
	DLL_CTRL_REF_UPDATE_INT   DLL_CTRL = 0x0F << 28 //+ DLL_CTRL_REF_UPDATE_INT
)

const (
	DLL_CTRL_ENABLEn           = 0
	DLL_CTRL_RESETn            = 1
	DLL_CTRL_SLV_FORCE_UPDn    = 2
	DLL_CTRL_SLV_DLY_TARGET0n  = 3
	DLL_CTRL_GATE_UPDATEn      = 7
	DLL_CTRL_SLV_OVERRIDEn     = 8
	DLL_CTRL_SLV_OVERRIDE_VALn = 9
	DLL_CTRL_SLV_DLY_TARGET1n  = 16
	DLL_CTRL_SLV_UPDATE_INTn   = 20
	DLL_CTRL_REF_UPDATE_INTn   = 28
)

const (
	DLL_STS_SLV_LOCK DLL_STATUS = 0x01 << 0 //+ DLL_STS_SLV_LOCK
	DLL_STS_REF_LOCK DLL_STATUS = 0x01 << 1 //+ DLL_STS_REF_LOCK
	DLL_STS_SLV_SEL  DLL_STATUS = 0x7F << 2 //+ DLL_STS_SLV_SEL
	DLL_STS_REF_SEL  DLL_STATUS = 0x7F << 9 //+ DLL_STS_REF_SEL
)

const (
	DLL_STS_SLV_LOCKn = 0
	DLL_STS_REF_LOCKn = 1
	DLL_STS_SLV_SELn  = 2
	DLL_STS_REF_SELn  = 9
)

const (
	DLY_CELL_SET_POST CLK_TUNE_CTRL_STATUS = 0x0F << 0  //+ DLY_CELL_SET_POST
	DLY_CELL_SET_OUT  CLK_TUNE_CTRL_STATUS = 0x0F << 4  //+ DLY_CELL_SET_OUT
	DLY_CELL_SET_PRE  CLK_TUNE_CTRL_STATUS = 0x7F << 8  //+ DLY_CELL_SET_PRE
	NXT_ERR           CLK_TUNE_CTRL_STATUS = 0x01 << 15 //+ NXT_ERR
	TAP_SEL_POST      CLK_TUNE_CTRL_STATUS = 0x0F << 16 //+ TAP_SEL_POST
	TAP_SEL_OUT       CLK_TUNE_CTRL_STATUS = 0x0F << 20 //+ TAP_SEL_OUT
	TAP_SEL_PRE       CLK_TUNE_CTRL_STATUS = 0x7F << 24 //+ TAP_SEL_PRE
	PRE_ERR           CLK_TUNE_CTRL_STATUS = 0x01 << 31 //+ PRE_ERR
)

const (
	DLY_CELL_SET_POSTn = 0
	DLY_CELL_SET_OUTn  = 4
	DLY_CELL_SET_PREn  = 8
	NXT_ERRn           = 15
	TAP_SEL_POSTn      = 16
	TAP_SEL_OUTn       = 20
	TAP_SEL_PREn       = 24
	PRE_ERRn           = 31
)

const (
	VSELECT              VEND_SPEC = 0x01 << 1  //+ Voltage Selection
	VSELECT_0            VEND_SPEC = 0x00 << 1  //  Change the voltage to high voltage range, around 3.0 V
	VSELECT_1            VEND_SPEC = 0x01 << 1  //  Change the voltage to low voltage range, around 1.8 V
	CONFLICT_CHK_EN      VEND_SPEC = 0x01 << 2  //+ Conflict check enable.
	CONFLICT_CHK_EN_0    VEND_SPEC = 0x00 << 2  //  Conflict check disable
	CONFLICT_CHK_EN_1    VEND_SPEC = 0x01 << 2  //  Conflict check enable
	AC12_WR_CHKBUSY_EN   VEND_SPEC = 0x01 << 3  //+ AC12_WR_CHKBUSY_EN
	AC12_WR_CHKBUSY_EN_0 VEND_SPEC = 0x00 << 3  //  Do not check busy after auto CMD12 for write data packet
	AC12_WR_CHKBUSY_EN_1 VEND_SPEC = 0x01 << 3  //  Check busy after auto CMD12 for write data packet
	FRC_SDCLK_ON         VEND_SPEC = 0x01 << 8  //+ FRC_SDCLK_ON
	FRC_SDCLK_ON_0       VEND_SPEC = 0x00 << 8  //  CLK active or inactive is fully controlled by the hardware.
	FRC_SDCLK_ON_1       VEND_SPEC = 0x01 << 8  //  Force CLK active.
	CRC_CHK_DIS          VEND_SPEC = 0x01 << 15 //+ CRC Check Disable
	CRC_CHK_DIS_0        VEND_SPEC = 0x00 << 15 //  Check CRC16 for every read data packet and check CRC bits for every write data packet
	CRC_CHK_DIS_1        VEND_SPEC = 0x01 << 15 //  Ignore CRC16 check for every read data packet and ignore CRC bits check for every write data packet
	CMD_BYTE_EN          VEND_SPEC = 0x01 << 31 //+ CMD_BYTE_EN
	CMD_BYTE_EN_0        VEND_SPEC = 0x00 << 31 //  Disable
	CMD_BYTE_EN_1        VEND_SPEC = 0x01 << 31 //  Enable
)

const (
	VSELECTn            = 1
	CONFLICT_CHK_ENn    = 2
	AC12_WR_CHKBUSY_ENn = 3
	FRC_SDCLK_ONn       = 8
	CRC_CHK_DISn        = 15
	CMD_BYTE_ENn        = 31
)

const (
	DTOCV_ACK          MMC_BOOT = 0x0F << 0    //+ DTOCV_ACK
	DTOCV_ACK_0        MMC_BOOT = 0x00 << 0    //  SDCLK x 2^14
	DTOCV_ACK_1        MMC_BOOT = 0x01 << 0    //  SDCLK x 2^15
	DTOCV_ACK_2        MMC_BOOT = 0x02 << 0    //  SDCLK x 2^16
	DTOCV_ACK_3        MMC_BOOT = 0x03 << 0    //  SDCLK x 2^17
	DTOCV_ACK_4        MMC_BOOT = 0x04 << 0    //  SDCLK x 2^18
	DTOCV_ACK_5        MMC_BOOT = 0x05 << 0    //  SDCLK x 2^19
	DTOCV_ACK_6        MMC_BOOT = 0x06 << 0    //  SDCLK x 2^20
	DTOCV_ACK_7        MMC_BOOT = 0x07 << 0    //  SDCLK x 2^21
	DTOCV_ACK_14       MMC_BOOT = 0x0E << 0    //  SDCLK x 2^28
	DTOCV_ACK_15       MMC_BOOT = 0x0F << 0    //  SDCLK x 2^29
	BOOT_ACK           MMC_BOOT = 0x01 << 4    //+ BOOT_ACK
	BOOT_ACK_0         MMC_BOOT = 0x00 << 4    //  No ack
	BOOT_ACK_1         MMC_BOOT = 0x01 << 4    //  Ack
	BOOT_MODE          MMC_BOOT = 0x01 << 5    //+ BOOT_MODE
	BOOT_MODE_0        MMC_BOOT = 0x00 << 5    //  Normal boot
	BOOT_MODE_1        MMC_BOOT = 0x01 << 5    //  Alternative boot
	BOOT_EN            MMC_BOOT = 0x01 << 6    //+ BOOT_EN
	BOOT_EN_0          MMC_BOOT = 0x00 << 6    //  Fast boot disable
	BOOT_EN_1          MMC_BOOT = 0x01 << 6    //  Fast boot enable
	AUTO_SABG_EN       MMC_BOOT = 0x01 << 7    //+ AUTO_SABG_EN
	DISABLE_TIME_OUT   MMC_BOOT = 0x01 << 8    //+ Disable Time Out
	DISABLE_TIME_OUT_0 MMC_BOOT = 0x00 << 8    //  Enable time out
	DISABLE_TIME_OUT_1 MMC_BOOT = 0x01 << 8    //  Disable time out
	BOOT_BLK_CNT       MMC_BOOT = 0xFFFF << 16 //+ BOOT_BLK_CNT
)

const (
	DTOCV_ACKn        = 0
	BOOT_ACKn         = 4
	BOOT_MODEn        = 5
	BOOT_ENn          = 6
	AUTO_SABG_ENn     = 7
	DISABLE_TIME_OUTn = 8
	BOOT_BLK_CNTn     = 16
)

const (
	CARD_INT_D3_TEST   VEND_SPEC2 = 0x01 << 3  //+ Card Interrupt Detection Test
	CARD_INT_D3_TEST_0 VEND_SPEC2 = 0x00 << 3  //  Check the card interrupt only when DATA3 is high.
	CARD_INT_D3_TEST_1 VEND_SPEC2 = 0x01 << 3  //  Check the card interrupt by ignoring the status of DATA3.
	TUNING_8bit_EN     VEND_SPEC2 = 0x01 << 4  //+ TUNING_8bit_EN
	TUNING_1bit_EN     VEND_SPEC2 = 0x01 << 5  //+ TUNING_1bit_EN
	TUNING_CMD_EN      VEND_SPEC2 = 0x01 << 6  //+ TUNING_CMD_EN
	TUNING_CMD_EN_0    VEND_SPEC2 = 0x00 << 6  //  Auto tuning circuit does not check the CMD line.
	TUNING_CMD_EN_1    VEND_SPEC2 = 0x01 << 6  //  Auto tuning circuit checks the CMD line.
	ACMD23_ARGU2_EN    VEND_SPEC2 = 0x01 << 12 //+ Argument2 register enable for ACMD23
	ACMD23_ARGU2_EN_0  VEND_SPEC2 = 0x00 << 12 //  Disable
	ACMD23_ARGU2_EN_1  VEND_SPEC2 = 0x01 << 12 //  Argument2 register enable for ACMD23 sharing with SDMA system address register. Default is enable.
	PART_DLL_DEBUG     VEND_SPEC2 = 0x01 << 13 //+ debug for part dll
	BUS_RST            VEND_SPEC2 = 0x01 << 14 //+ BUS reset
)

const (
	CARD_INT_D3_TESTn = 3
	TUNING_8bit_ENn   = 4
	TUNING_1bit_ENn   = 5
	TUNING_CMD_ENn    = 6
	ACMD23_ARGU2_ENn  = 12
	PART_DLL_DEBUGn   = 13
	BUS_RSTn          = 14
)

const (
	TUNING_START_TAP TUNING_CTRL = 0xFF << 0  //+ TUNING_START_TAP
	TUNING_COUNTER   TUNING_CTRL = 0xFF << 8  //+ TUNING_COUNTER
	TUNING_STEP      TUNING_CTRL = 0x07 << 16 //+ TUNING_STEP
	TUNING_WINDOW    TUNING_CTRL = 0x07 << 20 //+ TUNING_WINDOW
	STD_TUNING_EN    TUNING_CTRL = 0x01 << 24 //+ STD_TUNING_EN
)

const (
	TUNING_START_TAPn = 0
	TUNING_COUNTERn   = 8
	TUNING_STEPn      = 16
	TUNING_WINDOWn    = 20
	STD_TUNING_ENn    = 24
)
