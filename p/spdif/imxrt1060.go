// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package spdif provides access to the registers of the SPDIF peripheral.
//
// Instances:
//
//	SPDIF  SPDIF_BASE  -  SPDIF*
//
// Registers:
//
//	0x000 32  SCR     SPDIF Configuration Register
//	0x004 32  SRCD    CDText Control Register
//	0x008 32  SRPC    PhaseConfig Register
//	0x00C 32  SIE     InterruptEn Register
//	0x010 32  SIC     InterruptClear Register
//	0x010 32  SIS     InterruptStat Register
//	0x014 32  SRL     SPDIFRxLeft Register
//	0x018 32  SRR     SPDIFRxRight Register
//	0x01C 32  SRCSH   SPDIFRxCChannel_h Register
//	0x020 32  SRCSL   SPDIFRxCChannel_l Register
//	0x024 32  SRU     UchannelRx Register
//	0x028 32  SRQ     QchannelRx Register
//	0x02C 32  STL     SPDIFTxLeft Register
//	0x030 32  STR     SPDIFTxRight Register
//	0x034 32  STCSCH  SPDIFTxCChannelCons_h Register
//	0x038 32  STCSCL  SPDIFTxCChannelCons_l Register
//	0x044 32  SRFM    FreqMeas Register
//	0x050 32  STC     SPDIFTxClk Register
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package spdif

const (
	USrc_Sel          SCR = 0x03 << 0  //+ no description available
	USrc_Sel_0        SCR = 0x00 << 0  //  No embedded U channel
	USrc_Sel_1        SCR = 0x01 << 0  //  U channel from SPDIF receive block (CD mode)
	USrc_Sel_3        SCR = 0x03 << 0  //  U channel from on chip transmitter
	TxSel             SCR = 0x07 << 2  //+ no description available
	TxSel_0           SCR = 0x00 << 2  //  Off and output 0
	TxSel_1           SCR = 0x01 << 2  //  Feed-through SPDIFIN
	TxSel_5           SCR = 0x05 << 2  //  Tx Normal operation
	ValCtrl           SCR = 0x01 << 5  //+ no description available
	DMA_TX_En         SCR = 0x01 << 8  //+ DMA Transmit Request Enable (Tx FIFO empty)
	DMA_Rx_En         SCR = 0x01 << 9  //+ DMA Receive Request Enable (RX FIFO full)
	TxFIFO_Ctrl       SCR = 0x03 << 10 //+ no description available
	TxFIFO_Ctrl_0     SCR = 0x00 << 10 //  Send out digital zero on SPDIF Tx
	TxFIFO_Ctrl_1     SCR = 0x01 << 10 //  Tx Normal operation
	TxFIFO_Ctrl_2     SCR = 0x02 << 10 //  Reset to 1 sample remaining
	soft_reset        SCR = 0x01 << 12 //+ When write 1 to this bit, it will cause SPDIF software reset
	LOW_POWER         SCR = 0x01 << 13 //+ When write 1 to this bit, it will cause SPDIF enter low-power mode
	TxFIFOEmpty_Sel   SCR = 0x03 << 15 //+ no description available
	TxFIFOEmpty_Sel_0 SCR = 0x00 << 15 //  Empty interrupt if 0 sample in Tx left and right FIFOs
	TxFIFOEmpty_Sel_1 SCR = 0x01 << 15 //  Empty interrupt if at most 4 sample in Tx left and right FIFOs
	TxFIFOEmpty_Sel_2 SCR = 0x02 << 15 //  Empty interrupt if at most 8 sample in Tx left and right FIFOs
	TxFIFOEmpty_Sel_3 SCR = 0x03 << 15 //  Empty interrupt if at most 12 sample in Tx left and right FIFOs
	TxAutoSync        SCR = 0x01 << 17 //+ no description available
	RxAutoSync        SCR = 0x01 << 18 //+ no description available
	RxFIFOFull_Sel    SCR = 0x03 << 19 //+ no description available
	RxFIFOFull_Sel_0  SCR = 0x00 << 19 //  Full interrupt if at least 1 sample in Rx left and right FIFOs
	RxFIFOFull_Sel_1  SCR = 0x01 << 19 //  Full interrupt if at least 4 sample in Rx left and right FIFOs
	RxFIFOFull_Sel_2  SCR = 0x02 << 19 //  Full interrupt if at least 8 sample in Rx left and right FIFOs
	RxFIFOFull_Sel_3  SCR = 0x03 << 19 //  Full interrupt if at least 16 sample in Rx left and right FIFO
	RxFIFO_Rst        SCR = 0x01 << 21 //+ no description available
	RxFIFO_Off_On     SCR = 0x01 << 22 //+ no description available
	RxFIFO_Ctrl       SCR = 0x01 << 23 //+ no description available
)

const (
	USrc_Seln        = 0
	TxSeln           = 2
	ValCtrln         = 5
	DMA_TX_Enn       = 8
	DMA_Rx_Enn       = 9
	TxFIFO_Ctrln     = 10
	soft_resetn      = 12
	LOW_POWERn       = 13
	TxFIFOEmpty_Seln = 15
	TxAutoSyncn      = 17
	RxAutoSyncn      = 18
	RxFIFOFull_Seln  = 19
	RxFIFO_Rstn      = 21
	RxFIFO_Off_Onn   = 22
	RxFIFO_Ctrln     = 23
)

const (
	USyncMode SRCD = 0x01 << 1 //+ no description available
)

const (
	USyncModen = 1
)

const (
	GainSel      SRPC = 0x07 << 3 //+ Gain selection:
	GainSel_0    SRPC = 0x00 << 3 //  24*(2**10)
	GainSel_1    SRPC = 0x01 << 3 //  16*(2**10)
	GainSel_2    SRPC = 0x02 << 3 //  12*(2**10)
	GainSel_3    SRPC = 0x03 << 3 //  8*(2**10)
	GainSel_4    SRPC = 0x04 << 3 //  6*(2**10)
	GainSel_5    SRPC = 0x05 << 3 //  4*(2**10)
	GainSel_6    SRPC = 0x06 << 3 //  3*(2**10)
	LOCK         SRPC = 0x01 << 6 //+ LOCK bit to show that the internal DPLL is locked, read only
	ClkSrc_Sel   SRPC = 0x0F << 7 //+ Clock source selection, all other settings not shown are reserved:
	ClkSrc_Sel_0 SRPC = 0x00 << 7 //  if (DPLL Locked) SPDIF_RxClk else REF_CLK_32K (XTALOSC)
	ClkSrc_Sel_1 SRPC = 0x01 << 7 //  if (DPLL Locked) SPDIF_RxClk else tx_clk (SPDIF0_CLK_ROOT)
	ClkSrc_Sel_3 SRPC = 0x03 << 7 //  if (DPLL Locked) SPDIF_RxClk else SPDIF_EXT_CLK
	ClkSrc_Sel_5 SRPC = 0x05 << 7 //  REF_CLK_32K (XTALOSC)
	ClkSrc_Sel_6 SRPC = 0x06 << 7 //  tx_clk (SPDIF0_CLK_ROOT)
	ClkSrc_Sel_8 SRPC = 0x08 << 7 //  SPDIF_EXT_CLK
)

const (
	GainSeln    = 3
	LOCKn       = 6
	ClkSrc_Seln = 7
)

const (
	RxFIFOFul   SIE = 0x01 << 0  //+ SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
	TxEm        SIE = 0x01 << 1  //+ SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
	LockLoss    SIE = 0x01 << 2  //+ SPDIF receiver loss of lock
	RxFIFOResyn SIE = 0x01 << 3  //+ Rx FIFO resync
	RxFIFOUnOv  SIE = 0x01 << 4  //+ Rx FIFO underrun/overrun
	UQErr       SIE = 0x01 << 5  //+ U/Q Channel framing error
	UQSync      SIE = 0x01 << 6  //+ U/Q Channel sync found
	QRxOv       SIE = 0x01 << 7  //+ Q Channel receive register overrun
	QRxFul      SIE = 0x01 << 8  //+ Q Channel receive register full, can't be cleared with reg
	URxOv       SIE = 0x01 << 9  //+ U Channel receive register overrun
	URxFul      SIE = 0x01 << 10 //+ U Channel receive register full, can't be cleared with reg
	BitErr      SIE = 0x01 << 14 //+ SPDIF receiver found parity bit error
	SymErr      SIE = 0x01 << 15 //+ SPDIF receiver found illegal symbol
	ValNoGood   SIE = 0x01 << 16 //+ SPDIF validity flag no good
	CNew        SIE = 0x01 << 17 //+ SPDIF receive change in value of control channel
	TxResyn     SIE = 0x01 << 18 //+ SPDIF Tx FIFO resync
	TxUnOv      SIE = 0x01 << 19 //+ SPDIF Tx FIFO under/overrun
	Lock        SIE = 0x01 << 20 //+ SPDIF receiver's DPLL is locked
)

const (
	RxFIFOFuln   = 0
	TxEmn        = 1
	LockLossn    = 2
	RxFIFOResynn = 3
	RxFIFOUnOvn  = 4
	UQErrn       = 5
	UQSyncn      = 6
	QRxOvn       = 7
	QRxFuln      = 8
	URxOvn       = 9
	URxFuln      = 10
	BitErrn      = 14
	SymErrn      = 15
	ValNoGoodn   = 16
	CNewn        = 17
	TxResynn     = 18
	TxUnOvn      = 19
	Lockn        = 20
)

const (
	LockLoss    SIC = 0x01 << 2  //+ SPDIF receiver loss of lock
	RxFIFOResyn SIC = 0x01 << 3  //+ Rx FIFO resync
	RxFIFOUnOv  SIC = 0x01 << 4  //+ Rx FIFO underrun/overrun
	UQErr       SIC = 0x01 << 5  //+ U/Q Channel framing error
	UQSync      SIC = 0x01 << 6  //+ U/Q Channel sync found
	QRxOv       SIC = 0x01 << 7  //+ Q Channel receive register overrun
	URxOv       SIC = 0x01 << 9  //+ U Channel receive register overrun
	BitErr      SIC = 0x01 << 14 //+ SPDIF receiver found parity bit error
	SymErr      SIC = 0x01 << 15 //+ SPDIF receiver found illegal symbol
	ValNoGood   SIC = 0x01 << 16 //+ SPDIF validity flag no good
	CNew        SIC = 0x01 << 17 //+ SPDIF receive change in value of control channel
	TxResyn     SIC = 0x01 << 18 //+ SPDIF Tx FIFO resync
	TxUnOv      SIC = 0x01 << 19 //+ SPDIF Tx FIFO under/overrun
	Lock        SIC = 0x01 << 20 //+ SPDIF receiver's DPLL is locked
)

const (
	LockLossn    = 2
	RxFIFOResynn = 3
	RxFIFOUnOvn  = 4
	UQErrn       = 5
	UQSyncn      = 6
	QRxOvn       = 7
	URxOvn       = 9
	BitErrn      = 14
	SymErrn      = 15
	ValNoGoodn   = 16
	CNewn        = 17
	TxResynn     = 18
	TxUnOvn      = 19
	Lockn        = 20
)

const (
	RxFIFOFul   SIS = 0x01 << 0  //+ SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
	TxEm        SIS = 0x01 << 1  //+ SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
	LockLoss    SIS = 0x01 << 2  //+ SPDIF receiver loss of lock
	RxFIFOResyn SIS = 0x01 << 3  //+ Rx FIFO resync
	RxFIFOUnOv  SIS = 0x01 << 4  //+ Rx FIFO underrun/overrun
	UQErr       SIS = 0x01 << 5  //+ U/Q Channel framing error
	UQSync      SIS = 0x01 << 6  //+ U/Q Channel sync found
	QRxOv       SIS = 0x01 << 7  //+ Q Channel receive register overrun
	QRxFul      SIS = 0x01 << 8  //+ Q Channel receive register full, can't be cleared with reg
	URxOv       SIS = 0x01 << 9  //+ U Channel receive register overrun
	URxFul      SIS = 0x01 << 10 //+ U Channel receive register full, can't be cleared with reg
	BitErr      SIS = 0x01 << 14 //+ SPDIF receiver found parity bit error
	SymErr      SIS = 0x01 << 15 //+ SPDIF receiver found illegal symbol
	ValNoGood   SIS = 0x01 << 16 //+ SPDIF validity flag no good
	CNew        SIS = 0x01 << 17 //+ SPDIF receive change in value of control channel
	TxResyn     SIS = 0x01 << 18 //+ SPDIF Tx FIFO resync
	TxUnOv      SIS = 0x01 << 19 //+ SPDIF Tx FIFO under/overrun
	Lock        SIS = 0x01 << 20 //+ SPDIF receiver's DPLL is locked
)

const (
	RxFIFOFuln   = 0
	TxEmn        = 1
	LockLossn    = 2
	RxFIFOResynn = 3
	RxFIFOUnOvn  = 4
	UQErrn       = 5
	UQSyncn      = 6
	QRxOvn       = 7
	QRxFuln      = 8
	URxOvn       = 9
	URxFuln      = 10
	BitErrn      = 14
	SymErrn      = 15
	ValNoGoodn   = 16
	CNewn        = 17
	TxResynn     = 18
	TxUnOvn      = 19
	Lockn        = 20
)

const (
	RxDataLeft SRL = 0xFFFFFF << 0 //+ Processor receive SPDIF data left
)

const (
	RxDataLeftn = 0
)

const (
	RxDataRight SRR = 0xFFFFFF << 0 //+ Processor receive SPDIF data right
)

const (
	RxDataRightn = 0
)

const (
	RxCChannel_h SRCSH = 0xFFFFFF << 0 //+ SPDIF receive C channel register, contains first 24 bits of C channel without interpretation
)

const (
	RxCChannel_hn = 0
)

const (
	RxCChannel_l SRCSL = 0xFFFFFF << 0 //+ SPDIF receive C channel register, contains next 24 bits of C channel without interpretation
)

const (
	RxCChannel_ln = 0
)

const (
	RxUChannel SRU = 0xFFFFFF << 0 //+ SPDIF receive U channel register, contains next 3 U channel bytes
)

const (
	RxUChanneln = 0
)

const (
	RxQChannel SRQ = 0xFFFFFF << 0 //+ SPDIF receive Q channel register, contains next 3 Q channel bytes
)

const (
	RxQChanneln = 0
)

const (
	TxDataLeft STL = 0xFFFFFF << 0 //+ SPDIF transmit left channel data. It is write-only, and always returns zeros when read
)

const (
	TxDataLeftn = 0
)

const (
	TxDataRight STR = 0xFFFFFF << 0 //+ SPDIF transmit right channel data. It is write-only, and always returns zeros when read
)

const (
	TxDataRightn = 0
)

const (
	TxCChannelCons_h STCSCH = 0xFFFFFF << 0 //+ SPDIF transmit Cons
)

const (
	TxCChannelCons_hn = 0
)

const (
	TxCChannelCons_l STCSCL = 0xFFFFFF << 0 //+ SPDIF transmit Cons
)

const (
	TxCChannelCons_ln = 0
)

const (
	FreqMeas SRFM = 0xFFFFFF << 0 //+ Frequency measurement data
)

const (
	FreqMeasn = 0
)

const (
	TxClk_DF       STC = 0x7F << 0   //+ Divider factor (1-128)
	TxClk_DF_0     STC = 0x00 << 0   //  divider factor is 1
	TxClk_DF_1     STC = 0x01 << 0   //  divider factor is 2
	TxClk_DF_127   STC = 0x7F << 0   //  divider factor is 128
	tx_all_clk_en  STC = 0x01 << 7   //+ Spdif transfer clock enable. When data is going to be transfered, this bit should be set to1.
	TxClk_Source   STC = 0x07 << 8   //+ no description available
	TxClk_Source_0 STC = 0x00 << 8   //  XTALOSC input (XTALOSC clock)
	TxClk_Source_1 STC = 0x01 << 8   //  tx_clk input (from SPDIF0_CLK_ROOT. See CCM.)
	TxClk_Source_2 STC = 0x02 << 8   //  tx_clk1 (from SAI1)
	TxClk_Source_3 STC = 0x03 << 8   //  tx_clk2 SPDIF_EXT_CLK, from pads
	TxClk_Source_4 STC = 0x04 << 8   //  tx_clk3 (from SAI2)
	TxClk_Source_5 STC = 0x05 << 8   //  ipg_clk input (frequency divided)
	TxClk_Source_6 STC = 0x06 << 8   //  tx_clk4 (from SAI3)
	SYSCLK_DF      STC = 0x1FF << 11 //+ system clock divider factor, 2~512.
	SYSCLK_DF_0    STC = 0x00 << 11  //  no clock signal
	SYSCLK_DF_1    STC = 0x01 << 11  //  divider factor is 2
	SYSCLK_DF_511  STC = 0x1FF << 11 //  divider factor is 512
)

const (
	TxClk_DFn      = 0
	tx_all_clk_enn = 7
	TxClk_Sourcen  = 8
	SYSCLK_DFn     = 11
)
