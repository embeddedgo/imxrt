// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package csi provides access to the registers of the CSI peripheral.
//
// Instances:
//  CSI  CSI_BASE  -  CSI*
// Registers:
//  0x000 32  CSICR1             CSI Control Register 1
//  0x004 32  CSICR2             CSI Control Register 2
//  0x008 32  CSICR3             CSI Control Register 3
//  0x00C 32  CSISTATFIFO        CSI Statistic FIFO Register
//  0x010 32  CSIRFIFO           CSI RX FIFO Register
//  0x014 32  CSIRXCNT           CSI RX Count Register
//  0x018 32  CSISR              CSI Status Register
//  0x020 32  CSIDMASA_STATFIFO  CSI DMA Start Address Register - for STATFIFO
//  0x024 32  CSIDMATS_STATFIFO  CSI DMA Transfer Size Register - for STATFIFO
//  0x028 32  CSIDMASA_FB1       CSI DMA Start Address Register - for Frame Buffer1
//  0x02C 32  CSIDMASA_FB2       CSI DMA Transfer Size Register - for Frame Buffer2
//  0x030 32  CSIFBUF_PARA       CSI Frame Buffer Parameter Register
//  0x034 32  CSIIMAG_PARA       CSI Image Parameter Register
//  0x048 32  CSICR18            CSI Control Register 18
//  0x04C 32  CSICR19            CSI Control Register 19
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package csi

const (
	PIXEL_BIT            CSICR1 = 0x01 << 0  //+ Pixel Bit
	PIXEL_BIT_0          CSICR1 = 0x00 << 0  //  8-bit data for each pixel
	PIXEL_BIT_1          CSICR1 = 0x01 << 0  //  10-bit data for each pixel
	REDGE                CSICR1 = 0x01 << 1  //+ Valid Pixel Clock Edge Select
	REDGE_0              CSICR1 = 0x00 << 1  //  Pixel data is latched at the falling edge of CSI_PIXCLK
	REDGE_1              CSICR1 = 0x01 << 1  //  Pixel data is latched at the rising edge of CSI_PIXCLK
	INV_PCLK             CSICR1 = 0x01 << 2  //+ Invert Pixel Clock Input
	INV_PCLK_0           CSICR1 = 0x00 << 2  //  CSI_PIXCLK is directly applied to internal circuitry
	INV_PCLK_1           CSICR1 = 0x01 << 2  //  CSI_PIXCLK is inverted before applied to internal circuitry
	INV_DATA             CSICR1 = 0x01 << 3  //+ Invert Data Input. This bit enables or disables internal inverters on the data lines.
	INV_DATA_0           CSICR1 = 0x00 << 3  //  CSI_D[7:0] data lines are directly applied to internal circuitry
	INV_DATA_1           CSICR1 = 0x01 << 3  //  CSI_D[7:0] data lines are inverted before applied to internal circuitry
	GCLK_MODE            CSICR1 = 0x01 << 4  //+ Gated Clock Mode Enable
	GCLK_MODE_0          CSICR1 = 0x00 << 4  //  Non-gated clock mode. All incoming pixel clocks are valid. HSYNC is ignored.
	GCLK_MODE_1          CSICR1 = 0x01 << 4  //  Gated clock mode. Pixel clock signal is valid only when HSYNC is active.
	CLR_RXFIFO           CSICR1 = 0x01 << 5  //+ Asynchronous RXFIFO Clear
	CLR_STATFIFO         CSICR1 = 0x01 << 6  //+ Asynchronous STATFIFO Clear
	PACK_DIR             CSICR1 = 0x01 << 7  //+ Data Packing Direction
	PACK_DIR_0           CSICR1 = 0x00 << 7  //  Pack from LSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x44332211 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xBBBBAAAA in STAT FIFO.
	PACK_DIR_1           CSICR1 = 0x01 << 7  //  Pack from MSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x11223344 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xAAAABBBB in STAT FIFO.
	FCC                  CSICR1 = 0x01 << 8  //+ FIFO Clear Control
	FCC_0                CSICR1 = 0x00 << 8  //  Asynchronous FIFO clear is selected.
	FCC_1                CSICR1 = 0x01 << 8  //  Synchronous FIFO clear is selected.
	CCIR_EN              CSICR1 = 0x01 << 10 //+ CCIR656 Interface Enable
	CCIR_EN_0            CSICR1 = 0x00 << 10 //  Traditional interface is selected. Timing interface logic is used to latch data.
	CCIR_EN_1            CSICR1 = 0x01 << 10 //  CCIR656 interface is selected.
	HSYNC_POL            CSICR1 = 0x01 << 11 //+ HSYNC Polarity Select
	HSYNC_POL_0          CSICR1 = 0x00 << 11 //  HSYNC is active low
	HSYNC_POL_1          CSICR1 = 0x01 << 11 //  HSYNC is active high
	SOF_INTEN            CSICR1 = 0x01 << 16 //+ Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF interrupt.
	SOF_INTEN_0          CSICR1 = 0x00 << 16 //  SOF interrupt disable
	SOF_INTEN_1          CSICR1 = 0x01 << 16 //  SOF interrupt enable
	SOF_POL              CSICR1 = 0x01 << 17 //+ SOF Interrupt Polarity. This bit controls the condition that generates an SOF interrupt.
	SOF_POL_0            CSICR1 = 0x00 << 17 //  SOF interrupt is generated on SOF falling edge
	SOF_POL_1            CSICR1 = 0x01 << 17 //  SOF interrupt is generated on SOF rising edge
	RXFF_INTEN           CSICR1 = 0x01 << 18 //+ RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full interrupt.
	RXFF_INTEN_0         CSICR1 = 0x00 << 18 //  RxFIFO full interrupt disable
	RXFF_INTEN_1         CSICR1 = 0x01 << 18 //  RxFIFO full interrupt enable
	FB1_DMA_DONE_INTEN   CSICR1 = 0x01 << 19 //+ Frame Buffer1 DMA Transfer Done Interrupt Enable
	FB1_DMA_DONE_INTEN_0 CSICR1 = 0x00 << 19 //  Frame Buffer1 DMA Transfer Done interrupt disable
	FB1_DMA_DONE_INTEN_1 CSICR1 = 0x01 << 19 //  Frame Buffer1 DMA Transfer Done interrupt enable
	FB2_DMA_DONE_INTEN   CSICR1 = 0x01 << 20 //+ Frame Buffer2 DMA Transfer Done Interrupt Enable
	FB2_DMA_DONE_INTEN_0 CSICR1 = 0x00 << 20 //  Frame Buffer2 DMA Transfer Done interrupt disable
	FB2_DMA_DONE_INTEN_1 CSICR1 = 0x01 << 20 //  Frame Buffer2 DMA Transfer Done interrupt enable
	STATFF_INTEN         CSICR1 = 0x01 << 21 //+ STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO interrupt.
	STATFF_INTEN_0       CSICR1 = 0x00 << 21 //  STATFIFO full interrupt disable
	STATFF_INTEN_1       CSICR1 = 0x01 << 21 //  STATFIFO full interrupt enable
	SFF_DMA_DONE_INTEN   CSICR1 = 0x01 << 22 //+ STATFIFO DMA Transfer Done Interrupt Enable
	SFF_DMA_DONE_INTEN_0 CSICR1 = 0x00 << 22 //  STATFIFO DMA Transfer Done interrupt disable
	SFF_DMA_DONE_INTEN_1 CSICR1 = 0x01 << 22 //  STATFIFO DMA Transfer Done interrupt enable
	RF_OR_INTEN          CSICR1 = 0x01 << 24 //+ RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun interrupt.
	RF_OR_INTEN_0        CSICR1 = 0x00 << 24 //  RxFIFO overrun interrupt is disabled
	RF_OR_INTEN_1        CSICR1 = 0x01 << 24 //  RxFIFO overrun interrupt is enabled
	SF_OR_INTEN          CSICR1 = 0x01 << 25 //+ STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO overrun interrupt.
	SF_OR_INTEN_0        CSICR1 = 0x00 << 25 //  STATFIFO overrun interrupt is disabled
	SF_OR_INTEN_1        CSICR1 = 0x01 << 25 //  STATFIFO overrun interrupt is enabled
	COF_INT_EN           CSICR1 = 0x01 << 26 //+ Change Of Image Field (COF) Interrupt Enable
	COF_INT_EN_0         CSICR1 = 0x00 << 26 //  COF interrupt is disabled
	COF_INT_EN_1         CSICR1 = 0x01 << 26 //  COF interrupt is enabled
	CCIR_MODE            CSICR1 = 0x01 << 27 //+ CCIR Mode Select
	CCIR_MODE_0          CSICR1 = 0x00 << 27 //  Progressive mode is selected
	CCIR_MODE_1          CSICR1 = 0x01 << 27 //  Interlace mode is selected
	PrP_IF_EN            CSICR1 = 0x01 << 28 //+ CSI-PrP Interface Enable
	PrP_IF_EN_0          CSICR1 = 0x00 << 28 //  CSI to PrP bus is disabled
	PrP_IF_EN_1          CSICR1 = 0x01 << 28 //  CSI to PrP bus is enabled
	EOF_INT_EN           CSICR1 = 0x01 << 29 //+ End-of-Frame Interrupt Enable. This bit enables and disables the EOF interrupt.
	EOF_INT_EN_0         CSICR1 = 0x00 << 29 //  EOF interrupt is disabled.
	EOF_INT_EN_1         CSICR1 = 0x01 << 29 //  EOF interrupt is generated when RX count value is reached.
	EXT_VSYNC            CSICR1 = 0x01 << 30 //+ External VSYNC Enable
	EXT_VSYNC_0          CSICR1 = 0x00 << 30 //  Internal VSYNC mode
	EXT_VSYNC_1          CSICR1 = 0x01 << 30 //  External VSYNC mode
	SWAP16_EN            CSICR1 = 0x01 << 31 //+ SWAP 16-Bit Enable
	SWAP16_EN_0          CSICR1 = 0x00 << 31 //  Disable swapping
	SWAP16_EN_1          CSICR1 = 0x01 << 31 //  Enable swapping
)

const (
	PIXEL_BITn          = 0
	REDGEn              = 1
	INV_PCLKn           = 2
	INV_DATAn           = 3
	GCLK_MODEn          = 4
	CLR_RXFIFOn         = 5
	CLR_STATFIFOn       = 6
	PACK_DIRn           = 7
	FCCn                = 8
	CCIR_ENn            = 10
	HSYNC_POLn          = 11
	SOF_INTENn          = 16
	SOF_POLn            = 17
	RXFF_INTENn         = 18
	FB1_DMA_DONE_INTENn = 19
	FB2_DMA_DONE_INTENn = 20
	STATFF_INTENn       = 21
	SFF_DMA_DONE_INTENn = 22
	RF_OR_INTENn        = 24
	SF_OR_INTENn        = 25
	COF_INT_ENn         = 26
	CCIR_MODEn          = 27
	PrP_IF_ENn          = 28
	EOF_INT_ENn         = 29
	EXT_VSYNCn          = 30
	SWAP16_ENn          = 31
)

const (
	HSC                  CSICR2 = 0xFF << 0  //+ Horizontal Skip Count
	VSC                  CSICR2 = 0xFF << 8  //+ Vertical Skip Count. Contains the number of rows to skip. SCE must be 1, otherwise VSC is ignored.
	LVRM                 CSICR2 = 0x07 << 16 //+ Live View Resolution Mode. Selects the grid size used for live view resolution.
	LVRM_0               CSICR2 = 0x00 << 16 //  512 x 384
	LVRM_1               CSICR2 = 0x01 << 16 //  448 x 336
	LVRM_2               CSICR2 = 0x02 << 16 //  384 x 288
	LVRM_3               CSICR2 = 0x03 << 16 //  384 x 256
	LVRM_4               CSICR2 = 0x04 << 16 //  320 x 240
	LVRM_5               CSICR2 = 0x05 << 16 //  288 x 216
	LVRM_6               CSICR2 = 0x06 << 16 //  400 x 300
	BTS                  CSICR2 = 0x03 << 19 //+ Bayer Tile Start. Controls the Bayer pattern starting point.
	BTS_0                CSICR2 = 0x00 << 19 //  GR
	BTS_1                CSICR2 = 0x01 << 19 //  RG
	BTS_2                CSICR2 = 0x02 << 19 //  BG
	BTS_3                CSICR2 = 0x03 << 19 //  GB
	SCE                  CSICR2 = 0x01 << 23 //+ Skip Count Enable. Enables or disables the skip count feature.
	SCE_0                CSICR2 = 0x00 << 23 //  Skip count disable
	SCE_1                CSICR2 = 0x01 << 23 //  Skip count enable
	AFS                  CSICR2 = 0x03 << 24 //+ Auto Focus Spread. Selects which green pixels are used for auto-focus.
	AFS_0                CSICR2 = 0x00 << 24 //  Abs Diff on consecutive green pixels
	AFS_1                CSICR2 = 0x01 << 24 //  Abs Diff on every third green pixels
	AFS_2                CSICR2 = 0x02 << 24 //  Abs Diff on every four green pixels
	DRM                  CSICR2 = 0x01 << 26 //+ Double Resolution Mode. Controls size of statistics grid.
	DRM_0                CSICR2 = 0x00 << 26 //  Stats grid of 8 x 6
	DRM_1                CSICR2 = 0x01 << 26 //  Stats grid of 8 x 12
	DMA_BURST_TYPE_SFF   CSICR2 = 0x03 << 28 //+ Burst Type of DMA Transfer from STATFIFO. Selects the burst type of DMA transfer from STATFIFO.
	DMA_BURST_TYPE_SFF_0 CSICR2 = 0x00 << 28 //  INCR8
	DMA_BURST_TYPE_SFF_1 CSICR2 = 0x01 << 28 //  INCR4
	DMA_BURST_TYPE_SFF_3 CSICR2 = 0x03 << 28 //  INCR16
	DMA_BURST_TYPE_RFF   CSICR2 = 0x03 << 30 //+ Burst Type of DMA Transfer from RxFIFO. Selects the burst type of DMA transfer from RxFIFO.
	DMA_BURST_TYPE_RFF_0 CSICR2 = 0x00 << 30 //  INCR8
	DMA_BURST_TYPE_RFF_1 CSICR2 = 0x01 << 30 //  INCR4
	DMA_BURST_TYPE_RFF_3 CSICR2 = 0x03 << 30 //  INCR16
)

const (
	HSCn                = 0
	VSCn                = 8
	LVRMn               = 16
	BTSn                = 19
	SCEn                = 23
	AFSn                = 24
	DRMn                = 26
	DMA_BURST_TYPE_SFFn = 28
	DMA_BURST_TYPE_RFFn = 30
)

const (
	ECC_AUTO_EN       CSICR3 = 0x01 << 0    //+ Automatic Error Correction Enable
	ECC_AUTO_EN_0     CSICR3 = 0x00 << 0    //  Auto Error correction is disabled.
	ECC_AUTO_EN_1     CSICR3 = 0x01 << 0    //  Auto Error correction is enabled.
	ECC_INT_EN        CSICR3 = 0x01 << 1    //+ Error Detection Interrupt Enable
	ECC_INT_EN_0      CSICR3 = 0x00 << 1    //  No interrupt is generated when error is detected. Only the status bit ECC_INT is set.
	ECC_INT_EN_1      CSICR3 = 0x01 << 1    //  Interrupt is generated when error is detected.
	ZERO_PACK_EN      CSICR3 = 0x01 << 2    //+ Dummy Zero Packing Enable
	ZERO_PACK_EN_0    CSICR3 = 0x00 << 2    //  Zero packing disabled
	ZERO_PACK_EN_1    CSICR3 = 0x01 << 2    //  Zero packing enabled
	TWO_8BIT_SENSOR   CSICR3 = 0x01 << 3    //+ Two 8-bit Sensor Mode
	TWO_8BIT_SENSOR_0 CSICR3 = 0x00 << 3    //  Only one sensor is connected.
	TWO_8BIT_SENSOR_1 CSICR3 = 0x01 << 3    //  Two 8-bit sensors are connected or one 16-bit sensor is connected.
	RxFF_LEVEL        CSICR3 = 0x07 << 4    //+ RxFIFO Full Level
	RxFF_LEVEL_0      CSICR3 = 0x00 << 4    //  4 Double words
	RxFF_LEVEL_1      CSICR3 = 0x01 << 4    //  8 Double words
	RxFF_LEVEL_2      CSICR3 = 0x02 << 4    //  16 Double words
	RxFF_LEVEL_3      CSICR3 = 0x03 << 4    //  24 Double words
	RxFF_LEVEL_4      CSICR3 = 0x04 << 4    //  32 Double words
	RxFF_LEVEL_5      CSICR3 = 0x05 << 4    //  48 Double words
	RxFF_LEVEL_6      CSICR3 = 0x06 << 4    //  64 Double words
	RxFF_LEVEL_7      CSICR3 = 0x07 << 4    //  96 Double words
	HRESP_ERR_EN      CSICR3 = 0x01 << 7    //+ Hresponse Error Enable. This bit enables the hresponse error interrupt.
	HRESP_ERR_EN_0    CSICR3 = 0x00 << 7    //  Disable hresponse error interrupt
	HRESP_ERR_EN_1    CSICR3 = 0x01 << 7    //  Enable hresponse error interrupt
	STATFF_LEVEL      CSICR3 = 0x07 << 8    //+ STATFIFO Full Level
	STATFF_LEVEL_0    CSICR3 = 0x00 << 8    //  4 Double words
	STATFF_LEVEL_1    CSICR3 = 0x01 << 8    //  8 Double words
	STATFF_LEVEL_2    CSICR3 = 0x02 << 8    //  12 Double words
	STATFF_LEVEL_3    CSICR3 = 0x03 << 8    //  16 Double words
	STATFF_LEVEL_4    CSICR3 = 0x04 << 8    //  24 Double words
	STATFF_LEVEL_5    CSICR3 = 0x05 << 8    //  32 Double words
	STATFF_LEVEL_6    CSICR3 = 0x06 << 8    //  48 Double words
	STATFF_LEVEL_7    CSICR3 = 0x07 << 8    //  64 Double words
	DMA_REQ_EN_SFF    CSICR3 = 0x01 << 11   //+ DMA Request Enable for STATFIFO
	DMA_REQ_EN_SFF_0  CSICR3 = 0x00 << 11   //  Disable the dma request
	DMA_REQ_EN_SFF_1  CSICR3 = 0x01 << 11   //  Enable the dma request
	DMA_REQ_EN_RFF    CSICR3 = 0x01 << 12   //+ DMA Request Enable for RxFIFO
	DMA_REQ_EN_RFF_0  CSICR3 = 0x00 << 12   //  Disable the dma request
	DMA_REQ_EN_RFF_1  CSICR3 = 0x01 << 12   //  Enable the dma request
	DMA_REFLASH_SFF   CSICR3 = 0x01 << 13   //+ Reflash DMA Controller for STATFIFO
	DMA_REFLASH_SFF_0 CSICR3 = 0x00 << 13   //  No reflashing
	DMA_REFLASH_SFF_1 CSICR3 = 0x01 << 13   //  Reflash the embedded DMA controller
	DMA_REFLASH_RFF   CSICR3 = 0x01 << 14   //+ Reflash DMA Controller for RxFIFO
	DMA_REFLASH_RFF_0 CSICR3 = 0x00 << 14   //  No reflashing
	DMA_REFLASH_RFF_1 CSICR3 = 0x01 << 14   //  Reflash the embedded DMA controller
	FRMCNT_RST        CSICR3 = 0x01 << 15   //+ Frame Count Reset. Resets the Frame Counter. (Cleared automatically after reset is done)
	FRMCNT_RST_0      CSICR3 = 0x00 << 15   //  Do not reset
	FRMCNT_RST_1      CSICR3 = 0x01 << 15   //  Reset frame counter immediately
	FRMCNT            CSICR3 = 0xFFFF << 16 //+ Frame Counter
)

const (
	ECC_AUTO_ENn     = 0
	ECC_INT_ENn      = 1
	ZERO_PACK_ENn    = 2
	TWO_8BIT_SENSORn = 3
	RxFF_LEVELn      = 4
	HRESP_ERR_ENn    = 7
	STATFF_LEVELn    = 8
	DMA_REQ_EN_SFFn  = 11
	DMA_REQ_EN_RFFn  = 12
	DMA_REFLASH_SFFn = 13
	DMA_REFLASH_RFFn = 14
	FRMCNT_RSTn      = 15
	FRMCNTn          = 16
)

const (
	STAT CSISTATFIFO = 0xFFFFFFFF << 0 //+ Static data from sensor
)

const (
	STATn = 0
)

const (
	IMAGE CSIRFIFO = 0xFFFFFFFF << 0 //+ Received image data
)

const (
	IMAGEn = 0
)

const (
	RXCNT CSIRXCNT = 0x3FFFFF << 0 //+ RxFIFO Count
)

const (
	RXCNTn = 0
)

const (
	DRDY                   CSISR = 0x01 << 0  //+ RXFIFO Data Ready
	DRDY_0                 CSISR = 0x00 << 0  //  No data (word) is ready
	DRDY_1                 CSISR = 0x01 << 0  //  At least 1 datum (word) is ready in RXFIFO.
	ECC_INT                CSISR = 0x01 << 1  //+ CCIR Error Interrupt
	ECC_INT_0              CSISR = 0x00 << 1  //  No error detected
	ECC_INT_1              CSISR = 0x01 << 1  //  Error is detected in CCIR coding
	HRESP_ERR_INT          CSISR = 0x01 << 7  //+ Hresponse Error Interrupt Status
	HRESP_ERR_INT_0        CSISR = 0x00 << 7  //  No hresponse error.
	HRESP_ERR_INT_1        CSISR = 0x01 << 7  //  Hresponse error is detected.
	COF_INT                CSISR = 0x01 << 13 //+ Change Of Field Interrupt Status
	COF_INT_0              CSISR = 0x00 << 13 //  Video field has no change.
	COF_INT_1              CSISR = 0x01 << 13 //  Change of video field is detected.
	F1_INT                 CSISR = 0x01 << 14 //+ CCIR Field 1 Interrupt Status
	F1_INT_0               CSISR = 0x00 << 14 //  Field 1 of video is not detected.
	F1_INT_1               CSISR = 0x01 << 14 //  Field 1 of video is about to start.
	F2_INT                 CSISR = 0x01 << 15 //+ CCIR Field 2 Interrupt Status
	F2_INT_0               CSISR = 0x00 << 15 //  Field 2 of video is not detected
	F2_INT_1               CSISR = 0x01 << 15 //  Field 2 of video is about to start
	SOF_INT                CSISR = 0x01 << 16 //+ Start of Frame Interrupt Status. Indicates when SOF is detected. (Cleared by writing 1)
	SOF_INT_0              CSISR = 0x00 << 16 //  SOF is not detected.
	SOF_INT_1              CSISR = 0x01 << 16 //  SOF is detected.
	EOF_INT                CSISR = 0x01 << 17 //+ End of Frame (EOF) Interrupt Status. Indicates when EOF is detected. (Cleared by writing 1)
	EOF_INT_0              CSISR = 0x00 << 17 //  EOF is not detected.
	EOF_INT_1              CSISR = 0x01 << 17 //  EOF is detected.
	RxFF_INT               CSISR = 0x01 << 18 //+ RXFIFO Full Interrupt Status
	RxFF_INT_0             CSISR = 0x00 << 18 //  RxFIFO is not full.
	RxFF_INT_1             CSISR = 0x01 << 18 //  RxFIFO is full.
	DMA_TSF_DONE_FB1       CSISR = 0x01 << 19 //+ DMA Transfer Done in Frame Buffer1
	DMA_TSF_DONE_FB1_0     CSISR = 0x00 << 19 //  DMA transfer is not completed.
	DMA_TSF_DONE_FB1_1     CSISR = 0x01 << 19 //  DMA transfer is completed.
	DMA_TSF_DONE_FB2       CSISR = 0x01 << 20 //+ DMA Transfer Done in Frame Buffer2
	DMA_TSF_DONE_FB2_0     CSISR = 0x00 << 20 //  DMA transfer is not completed.
	DMA_TSF_DONE_FB2_1     CSISR = 0x01 << 20 //  DMA transfer is completed.
	STATFF_INT             CSISR = 0x01 << 21 //+ STATFIFO Full Interrupt Status
	STATFF_INT_0           CSISR = 0x00 << 21 //  STATFIFO is not full.
	STATFF_INT_1           CSISR = 0x01 << 21 //  STATFIFO is full.
	DMA_TSF_DONE_SFF       CSISR = 0x01 << 22 //+ DMA Transfer Done from StatFIFO
	DMA_TSF_DONE_SFF_0     CSISR = 0x00 << 22 //  DMA transfer is not completed.
	DMA_TSF_DONE_SFF_1     CSISR = 0x01 << 22 //  DMA transfer is completed.
	RF_OR_INT              CSISR = 0x01 << 24 //+ RxFIFO Overrun Interrupt Status
	RF_OR_INT_0            CSISR = 0x00 << 24 //  RXFIFO has not overflowed.
	RF_OR_INT_1            CSISR = 0x01 << 24 //  RXFIFO has overflowed.
	SF_OR_INT              CSISR = 0x01 << 25 //+ STATFIFO Overrun Interrupt Status
	SF_OR_INT_0            CSISR = 0x00 << 25 //  STATFIFO has not overflowed.
	SF_OR_INT_1            CSISR = 0x01 << 25 //  STATFIFO has overflowed.
	DMA_FIELD1_DONE        CSISR = 0x01 << 26 //+ When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
	DMA_FIELD0_DONE        CSISR = 0x01 << 27 //+ When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
	BASEADDR_CHHANGE_ERROR CSISR = 0x01 << 28 //+ When using base address switching enable, this bit will be 1 when switching occur before DMA complete
)

const (
	DRDYn                   = 0
	ECC_INTn                = 1
	HRESP_ERR_INTn          = 7
	COF_INTn                = 13
	F1_INTn                 = 14
	F2_INTn                 = 15
	SOF_INTn                = 16
	EOF_INTn                = 17
	RxFF_INTn               = 18
	DMA_TSF_DONE_FB1n       = 19
	DMA_TSF_DONE_FB2n       = 20
	STATFF_INTn             = 21
	DMA_TSF_DONE_SFFn       = 22
	RF_OR_INTn              = 24
	SF_OR_INTn              = 25
	DMA_FIELD1_DONEn        = 26
	DMA_FIELD0_DONEn        = 27
	BASEADDR_CHHANGE_ERRORn = 28
)

const (
	DMA_START_ADDR_SFF CSIDMASA_STATFIFO = 0x3FFFFFFF << 2 //+ DMA Start Address for STATFIFO
)

const (
	DMA_START_ADDR_SFFn = 2
)

const (
	DMA_TSF_SIZE_SFF CSIDMATS_STATFIFO = 0xFFFFFFFF << 0 //+ DMA Transfer Size for STATFIFO
)

const (
	DMA_TSF_SIZE_SFFn = 0
)

const (
	DMA_START_ADDR_FB1 CSIDMASA_FB1 = 0x3FFFFFFF << 2 //+ DMA Start Address in Frame Buffer1
)

const (
	DMA_START_ADDR_FB1n = 2
)

const (
	DMA_START_ADDR_FB2 CSIDMASA_FB2 = 0x3FFFFFFF << 2 //+ DMA Start Address in Frame Buffer2
)

const (
	DMA_START_ADDR_FB2n = 2
)

const (
	FBUF_STRIDE        CSIFBUF_PARA = 0xFFFF << 0  //+ Frame Buffer Parameter
	DEINTERLACE_STRIDE CSIFBUF_PARA = 0xFFFF << 16 //+ DEINTERLACE_STRIDE is only used in the deinterlace mode
)

const (
	FBUF_STRIDEn        = 0
	DEINTERLACE_STRIDEn = 16
)

const (
	IMAGE_HEIGHT CSIIMAG_PARA = 0xFFFF << 0  //+ Image Height. Indicates how many pixels in a column of the image from the sensor.
	IMAGE_WIDTH  CSIIMAG_PARA = 0xFFFF << 16 //+ Image Width
)

const (
	IMAGE_HEIGHTn = 0
	IMAGE_WIDTHn  = 16
)

const (
	DEINTERLACE_EN           CSICR18 = 0x01 << 2  //+ This bit is used to select the output method When input is standard CCIR656 video.
	DEINTERLACE_EN_0         CSICR18 = 0x00 << 2  //  Deinterlace disabled
	DEINTERLACE_EN_1         CSICR18 = 0x01 << 2  //  Deinterlace enabled
	PARALLEL24_EN            CSICR18 = 0x01 << 3  //+ When input is parallel rgb888/yuv444 24bit, this bit can be enabled.
	BASEADDR_SWITCH_EN       CSICR18 = 0x01 << 4  //+ When this bit is enabled, CSI DMA will switch the base address according to BASEADDR_SWITCH_SEL rather than atomically by DMA completed
	BASEADDR_SWITCH_SEL      CSICR18 = 0x01 << 5  //+ CSI 2 base addresses switching method. When using this bit, BASEADDR_SWITCH_EN is 1.
	BASEADDR_SWITCH_SEL_0    CSICR18 = 0x00 << 5  //  Switching base address at the edge of the vsync
	BASEADDR_SWITCH_SEL_1    CSICR18 = 0x01 << 5  //  Switching base address at the edge of the first data of each frame
	FIELD0_DONE_IE           CSICR18 = 0x01 << 6  //+ In interlace mode, fileld 0 means interrupt enabled.
	FIELD0_DONE_IE_0         CSICR18 = 0x00 << 6  //  Interrupt disabled
	FIELD0_DONE_IE_1         CSICR18 = 0x01 << 6  //  Interrupt enabled
	DMA_FIELD1_DONE_IE       CSICR18 = 0x01 << 7  //+ When in interlace mode, field 1 done interrupt enable.
	DMA_FIELD1_DONE_IE_0     CSICR18 = 0x00 << 7  //  Interrupt disabled
	DMA_FIELD1_DONE_IE_1     CSICR18 = 0x01 << 7  //  Interrupt enabled
	LAST_DMA_REQ_SEL         CSICR18 = 0x01 << 8  //+ Choosing the last DMA request condition.
	LAST_DMA_REQ_SEL_0       CSICR18 = 0x00 << 8  //  fifo_full_level
	LAST_DMA_REQ_SEL_1       CSICR18 = 0x01 << 8  //  hburst_length
	BASEADDR_CHANGE_ERROR_IE CSICR18 = 0x01 << 9  //+ Base address change error interrupt enable signal.
	RGB888A_FORMAT_SEL       CSICR18 = 0x01 << 10 //+ Output is 32-bit format.
	RGB888A_FORMAT_SEL_0     CSICR18 = 0x00 << 10 //  {8'h0, data[23:0]}
	RGB888A_FORMAT_SEL_1     CSICR18 = 0x01 << 10 //  {data[23:0], 8'h0}
	AHB_HPROT                CSICR18 = 0x0F << 12 //+ Hprot value in AHB bus protocol.
	MASK_OPTION              CSICR18 = 0x03 << 18 //+ These bits used to choose the method to mask the CSI input.
	MASK_OPTION_0            CSICR18 = 0x00 << 18 //  Writing to memory from first completely frame, when using this option, the CSI_ENABLE should be 1.
	MASK_OPTION_1            CSICR18 = 0x01 << 18 //  Writing to memory when CSI_ENABLE is 1.
	MASK_OPTION_2            CSICR18 = 0x02 << 18 //  Writing to memory from second completely frame, when using this option, the CSI_ENABLE should be 1.
	MASK_OPTION_3            CSICR18 = 0x03 << 18 //  Writing to memory when data comes in, not matter the CSI_ENABLE is 1 or 0.
	CSI_ENABLE               CSICR18 = 0x01 << 31 //+ CSI global enable signal
)

const (
	DEINTERLACE_ENn           = 2
	PARALLEL24_ENn            = 3
	BASEADDR_SWITCH_ENn       = 4
	BASEADDR_SWITCH_SELn      = 5
	FIELD0_DONE_IEn           = 6
	DMA_FIELD1_DONE_IEn       = 7
	LAST_DMA_REQ_SELn         = 8
	BASEADDR_CHANGE_ERROR_IEn = 9
	RGB888A_FORMAT_SELn       = 10
	AHB_HPROTn                = 12
	MASK_OPTIONn              = 18
	CSI_ENABLEn               = 31
)

const (
	DMA_RFIFO_HIGHEST_FIFO_LEVEL CSICR19 = 0xFF << 0 //+ This byte stores the highest FIFO level achieved by CSI FIFO timely and will be clear by writing 8'ff to it
)

const (
	DMA_RFIFO_HIGHEST_FIFO_LEVELn = 0
)
