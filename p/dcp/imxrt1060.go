// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package dcp provides access to the registers of the DCP peripheral.
//
// Instances:
//  DCP  DCP_BASE  -  DCP*,DCP_VMI*  DCP register reference index
// Registers:
//  0x000 32  CTRL             DCP control register 0
//  0x004 32  CTRL_SET         DCP control register 0
//  0x008 32  CTRL_CLR         DCP control register 0
//  0x00C 32  CTRL_TOG         DCP control register 0
//  0x010 32  STAT             DCP status register
//  0x014 32  STAT_SET         DCP status register
//  0x018 32  STAT_CLR         DCP status register
//  0x01C 32  STAT_TOG         DCP status register
//  0x020 32  CHANNELCTRL      DCP channel control register
//  0x024 32  CHANNELCTRL_SET  DCP channel control register
//  0x028 32  CHANNELCTRL_CLR  DCP channel control register
//  0x02C 32  CHANNELCTRL_TOG  DCP channel control register
//  0x030 32  CAPABILITY0      DCP capability 0 register
//  0x040 32  CAPABILITY1      DCP capability 1 register
//  0x050 32  CONTEXT          DCP context buffer pointer
//  0x060 32  KEY              DCP key index
//  0x070 32  KEYDATA          DCP key data
//  0x080 32  PACKET0          DCP work packet 0 status register
//  0x090 32  PACKET1          DCP work packet 1 status register
//  0x0A0 32  PACKET2          DCP work packet 2 status register
//  0x0B0 32  PACKET3          DCP work packet 3 status register
//  0x0C0 32  PACKET4          DCP work packet 4 status register
//  0x0D0 32  PACKET5          DCP work packet 5 status register
//  0x0E0 32  PACKET6          DCP work packet 6 status register
//  0x100 32  CH0CMDPTR        DCP channel 0 command pointer address register
//  0x110 32  CH0SEMA          DCP channel 0 semaphore register
//  0x120 32  CH0STAT          DCP channel 0 status register
//  0x124 32  CH0STAT_SET      DCP channel 0 status register
//  0x128 32  CH0STAT_CLR      DCP channel 0 status register
//  0x12C 32  CH0STAT_TOG      DCP channel 0 status register
//  0x130 32  CH0OPTS          DCP channel 0 options register
//  0x134 32  CH0OPTS_SET      DCP channel 0 options register
//  0x138 32  CH0OPTS_CLR      DCP channel 0 options register
//  0x13C 32  CH0OPTS_TOG      DCP channel 0 options register
//  0x140 32  CH1CMDPTR        DCP channel 1 command pointer address register
//  0x150 32  CH1SEMA          DCP channel 1 semaphore register
//  0x160 32  CH1STAT          DCP channel 1 status register
//  0x164 32  CH1STAT_SET      DCP channel 1 status register
//  0x168 32  CH1STAT_CLR      DCP channel 1 status register
//  0x16C 32  CH1STAT_TOG      DCP channel 1 status register
//  0x170 32  CH1OPTS          DCP channel 1 options register
//  0x174 32  CH1OPTS_SET      DCP channel 1 options register
//  0x178 32  CH1OPTS_CLR      DCP channel 1 options register
//  0x17C 32  CH1OPTS_TOG      DCP channel 1 options register
//  0x180 32  CH2CMDPTR        DCP channel 2 command pointer address register
//  0x190 32  CH2SEMA          DCP channel 2 semaphore register
//  0x1A0 32  CH2STAT          DCP channel 2 status register
//  0x1A4 32  CH2STAT_SET      DCP channel 2 status register
//  0x1A8 32  CH2STAT_CLR      DCP channel 2 status register
//  0x1AC 32  CH2STAT_TOG      DCP channel 2 status register
//  0x1B0 32  CH2OPTS          DCP channel 2 options register
//  0x1B4 32  CH2OPTS_SET      DCP channel 2 options register
//  0x1B8 32  CH2OPTS_CLR      DCP channel 2 options register
//  0x1BC 32  CH2OPTS_TOG      DCP channel 2 options register
//  0x1C0 32  CH3CMDPTR        DCP channel 3 command pointer address register
//  0x1D0 32  CH3SEMA          DCP channel 3 semaphore register
//  0x1E0 32  CH3STAT          DCP channel 3 status register
//  0x1E4 32  CH3STAT_SET      DCP channel 3 status register
//  0x1E8 32  CH3STAT_CLR      DCP channel 3 status register
//  0x1EC 32  CH3STAT_TOG      DCP channel 3 status register
//  0x1F0 32  CH3OPTS          DCP channel 3 options register
//  0x1F4 32  CH3OPTS_SET      DCP channel 3 options register
//  0x1F8 32  CH3OPTS_CLR      DCP channel 3 options register
//  0x1FC 32  CH3OPTS_TOG      DCP channel 3 options register
//  0x400 32  DBGSELECT        DCP debug select register
//  0x410 32  DBGDATA          DCP debug data register
//  0x420 32  PAGETABLE        DCP page table register
//  0x430 32  VERSION          DCP version register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package dcp

const (
	CHANNEL_INTERRUPT_ENABLE CTRL = 0xFF << 0  //+ Per-channel interrupt enable bit
	CH0                      CTRL = 0x01 << 0  //  CH0
	CH1                      CTRL = 0x02 << 0  //  CH1
	CH2                      CTRL = 0x04 << 0  //  CH2
	CH3                      CTRL = 0x08 << 0  //  CH3
	ENABLE_CONTEXT_SWITCHING CTRL = 0x01 << 21 //+ Enable automatic context switching for the channels
	ENABLE_CONTEXT_CACHING   CTRL = 0x01 << 22 //+ The software must set this bit to enable the caching of contexts between the operations
	GATHER_RESIDUAL_WRITES   CTRL = 0x01 << 23 //+ The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
	PRESENT_SHA              CTRL = 0x01 << 28 //+ Indicates whether the SHA1/SHA2 functions are present.
	PRESENT_CRYPTO           CTRL = 0x01 << 29 //+ Indicates whether the crypto (cipher/hash) functions are present.
	CLKGATE                  CTRL = 0x01 << 30 //+ This bit must be set to zero for a normal operation
	SFTRST                   CTRL = 0x01 << 31 //+ Set this bit to zero to enable a normal DCP operation
)

const (
	CHANNEL_INTERRUPT_ENABLEn = 0
	ENABLE_CONTEXT_SWITCHINGn = 21
	ENABLE_CONTEXT_CACHINGn   = 22
	GATHER_RESIDUAL_WRITESn   = 23
	PRESENT_SHAn              = 28
	PRESENT_CRYPTOn           = 29
	CLKGATEn                  = 30
	SFTRSTn                   = 31
)

const (
	CHANNEL_INTERRUPT_ENABLE CTRL_SET = 0xFF << 0  //+ Per-channel interrupt enable bit
	CH0                      CTRL_SET = 0x01 << 0  //  CH0
	CH1                      CTRL_SET = 0x02 << 0  //  CH1
	CH2                      CTRL_SET = 0x04 << 0  //  CH2
	CH3                      CTRL_SET = 0x08 << 0  //  CH3
	ENABLE_CONTEXT_SWITCHING CTRL_SET = 0x01 << 21 //+ Enable automatic context switching for the channels
	ENABLE_CONTEXT_CACHING   CTRL_SET = 0x01 << 22 //+ The software must set this bit to enable the caching of contexts between the operations
	GATHER_RESIDUAL_WRITES   CTRL_SET = 0x01 << 23 //+ The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
	PRESENT_SHA              CTRL_SET = 0x01 << 28 //+ Indicates whether the SHA1/SHA2 functions are present.
	PRESENT_CRYPTO           CTRL_SET = 0x01 << 29 //+ Indicates whether the crypto (cipher/hash) functions are present.
	CLKGATE                  CTRL_SET = 0x01 << 30 //+ This bit must be set to zero for a normal operation
	SFTRST                   CTRL_SET = 0x01 << 31 //+ Set this bit to zero to enable a normal DCP operation
)

const (
	CHANNEL_INTERRUPT_ENABLEn = 0
	ENABLE_CONTEXT_SWITCHINGn = 21
	ENABLE_CONTEXT_CACHINGn   = 22
	GATHER_RESIDUAL_WRITESn   = 23
	PRESENT_SHAn              = 28
	PRESENT_CRYPTOn           = 29
	CLKGATEn                  = 30
	SFTRSTn                   = 31
)

const (
	CHANNEL_INTERRUPT_ENABLE CTRL_CLR = 0xFF << 0  //+ Per-channel interrupt enable bit
	CH0                      CTRL_CLR = 0x01 << 0  //  CH0
	CH1                      CTRL_CLR = 0x02 << 0  //  CH1
	CH2                      CTRL_CLR = 0x04 << 0  //  CH2
	CH3                      CTRL_CLR = 0x08 << 0  //  CH3
	ENABLE_CONTEXT_SWITCHING CTRL_CLR = 0x01 << 21 //+ Enable automatic context switching for the channels
	ENABLE_CONTEXT_CACHING   CTRL_CLR = 0x01 << 22 //+ The software must set this bit to enable the caching of contexts between the operations
	GATHER_RESIDUAL_WRITES   CTRL_CLR = 0x01 << 23 //+ The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
	PRESENT_SHA              CTRL_CLR = 0x01 << 28 //+ Indicates whether the SHA1/SHA2 functions are present.
	PRESENT_CRYPTO           CTRL_CLR = 0x01 << 29 //+ Indicates whether the crypto (cipher/hash) functions are present.
	CLKGATE                  CTRL_CLR = 0x01 << 30 //+ This bit must be set to zero for a normal operation
	SFTRST                   CTRL_CLR = 0x01 << 31 //+ Set this bit to zero to enable a normal DCP operation
)

const (
	CHANNEL_INTERRUPT_ENABLEn = 0
	ENABLE_CONTEXT_SWITCHINGn = 21
	ENABLE_CONTEXT_CACHINGn   = 22
	GATHER_RESIDUAL_WRITESn   = 23
	PRESENT_SHAn              = 28
	PRESENT_CRYPTOn           = 29
	CLKGATEn                  = 30
	SFTRSTn                   = 31
)

const (
	CHANNEL_INTERRUPT_ENABLE CTRL_TOG = 0xFF << 0  //+ Per-channel interrupt enable bit
	CH0                      CTRL_TOG = 0x01 << 0  //  CH0
	CH1                      CTRL_TOG = 0x02 << 0  //  CH1
	CH2                      CTRL_TOG = 0x04 << 0  //  CH2
	CH3                      CTRL_TOG = 0x08 << 0  //  CH3
	ENABLE_CONTEXT_SWITCHING CTRL_TOG = 0x01 << 21 //+ Enable automatic context switching for the channels
	ENABLE_CONTEXT_CACHING   CTRL_TOG = 0x01 << 22 //+ The software must set this bit to enable the caching of contexts between the operations
	GATHER_RESIDUAL_WRITES   CTRL_TOG = 0x01 << 23 //+ The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
	PRESENT_SHA              CTRL_TOG = 0x01 << 28 //+ Indicates whether the SHA1/SHA2 functions are present.
	PRESENT_CRYPTO           CTRL_TOG = 0x01 << 29 //+ Indicates whether the crypto (cipher/hash) functions are present.
	CLKGATE                  CTRL_TOG = 0x01 << 30 //+ This bit must be set to zero for a normal operation
	SFTRST                   CTRL_TOG = 0x01 << 31 //+ Set this bit to zero to enable a normal DCP operation
)

const (
	CHANNEL_INTERRUPT_ENABLEn = 0
	ENABLE_CONTEXT_SWITCHINGn = 21
	ENABLE_CONTEXT_CACHINGn   = 22
	GATHER_RESIDUAL_WRITESn   = 23
	PRESENT_SHAn              = 28
	PRESENT_CRYPTOn           = 29
	CLKGATEn                  = 30
	SFTRSTn                   = 31
)

const (
	IRQ            STAT = 0x0F << 0  //+ Indicates which channels have pending interrupt requests
	READY_CHANNELS STAT = 0xFF << 16 //+ Indicates which channels are ready to proceed with a transfer (the active channel is also included)
	CH0            STAT = 0x01 << 16 //  CH0
	CH1            STAT = 0x02 << 16 //  CH1
	CH2            STAT = 0x04 << 16 //  CH2
	CH3            STAT = 0x08 << 16 //  CH3
	CUR_CHANNEL    STAT = 0x0F << 24 //+ Current (active) channel (encoded)
	None           STAT = 0x00 << 24 //  None
	CH0            STAT = 0x01 << 24 //  CH0
	CH1            STAT = 0x02 << 24 //  CH1
	CH2            STAT = 0x03 << 24 //  CH2
	CH3            STAT = 0x04 << 24 //  CH3
	OTP_KEY_READY  STAT = 0x01 << 28 //+ When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
)

const (
	IRQn            = 0
	READY_CHANNELSn = 16
	CUR_CHANNELn    = 24
	OTP_KEY_READYn  = 28
)

const (
	IRQ            STAT_SET = 0x0F << 0  //+ Indicates which channels have pending interrupt requests
	READY_CHANNELS STAT_SET = 0xFF << 16 //+ Indicates which channels are ready to proceed with a transfer (the active channel is also included)
	CH0            STAT_SET = 0x01 << 16 //  CH0
	CH1            STAT_SET = 0x02 << 16 //  CH1
	CH2            STAT_SET = 0x04 << 16 //  CH2
	CH3            STAT_SET = 0x08 << 16 //  CH3
	CUR_CHANNEL    STAT_SET = 0x0F << 24 //+ Current (active) channel (encoded)
	None           STAT_SET = 0x00 << 24 //  None
	CH0            STAT_SET = 0x01 << 24 //  CH0
	CH1            STAT_SET = 0x02 << 24 //  CH1
	CH2            STAT_SET = 0x03 << 24 //  CH2
	CH3            STAT_SET = 0x04 << 24 //  CH3
	OTP_KEY_READY  STAT_SET = 0x01 << 28 //+ When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
)

const (
	IRQn            = 0
	READY_CHANNELSn = 16
	CUR_CHANNELn    = 24
	OTP_KEY_READYn  = 28
)

const (
	IRQ            STAT_CLR = 0x0F << 0  //+ Indicates which channels have pending interrupt requests
	READY_CHANNELS STAT_CLR = 0xFF << 16 //+ Indicates which channels are ready to proceed with a transfer (the active channel is also included)
	CH0            STAT_CLR = 0x01 << 16 //  CH0
	CH1            STAT_CLR = 0x02 << 16 //  CH1
	CH2            STAT_CLR = 0x04 << 16 //  CH2
	CH3            STAT_CLR = 0x08 << 16 //  CH3
	CUR_CHANNEL    STAT_CLR = 0x0F << 24 //+ Current (active) channel (encoded)
	None           STAT_CLR = 0x00 << 24 //  None
	CH0            STAT_CLR = 0x01 << 24 //  CH0
	CH1            STAT_CLR = 0x02 << 24 //  CH1
	CH2            STAT_CLR = 0x03 << 24 //  CH2
	CH3            STAT_CLR = 0x04 << 24 //  CH3
	OTP_KEY_READY  STAT_CLR = 0x01 << 28 //+ When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
)

const (
	IRQn            = 0
	READY_CHANNELSn = 16
	CUR_CHANNELn    = 24
	OTP_KEY_READYn  = 28
)

const (
	IRQ            STAT_TOG = 0x0F << 0  //+ Indicates which channels have pending interrupt requests
	READY_CHANNELS STAT_TOG = 0xFF << 16 //+ Indicates which channels are ready to proceed with a transfer (the active channel is also included)
	CH0            STAT_TOG = 0x01 << 16 //  CH0
	CH1            STAT_TOG = 0x02 << 16 //  CH1
	CH2            STAT_TOG = 0x04 << 16 //  CH2
	CH3            STAT_TOG = 0x08 << 16 //  CH3
	CUR_CHANNEL    STAT_TOG = 0x0F << 24 //+ Current (active) channel (encoded)
	None           STAT_TOG = 0x00 << 24 //  None
	CH0            STAT_TOG = 0x01 << 24 //  CH0
	CH1            STAT_TOG = 0x02 << 24 //  CH1
	CH2            STAT_TOG = 0x03 << 24 //  CH2
	CH3            STAT_TOG = 0x04 << 24 //  CH3
	OTP_KEY_READY  STAT_TOG = 0x01 << 28 //+ When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
)

const (
	IRQn            = 0
	READY_CHANNELSn = 16
	CUR_CHANNELn    = 24
	OTP_KEY_READYn  = 28
)

const (
	ENABLE_CHANNEL        CHANNELCTRL = 0xFF << 0  //+ Setting a bit in this field enables the DMA channel associated with it
	CH0                   CHANNELCTRL = 0x01 << 0  //  CH0
	CH1                   CHANNELCTRL = 0x02 << 0  //  CH1
	CH2                   CHANNELCTRL = 0x04 << 0  //  CH2
	CH3                   CHANNELCTRL = 0x08 << 0  //  CH3
	HIGH_PRIORITY_CHANNEL CHANNELCTRL = 0xFF << 8  //+ Setting a bit in this field causes the corresponding channel to have high-priority arbitration
	CH0                   CHANNELCTRL = 0x01 << 8  //  CH0
	CH1                   CHANNELCTRL = 0x02 << 8  //  CH1
	CH2                   CHANNELCTRL = 0x04 << 8  //  CH2
	CH3                   CHANNELCTRL = 0x08 << 8  //  CH3
	CH0_IRQ_MERGED        CHANNELCTRL = 0x01 << 16 //+ Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
)

const (
	ENABLE_CHANNELn        = 0
	HIGH_PRIORITY_CHANNELn = 8
	CH0_IRQ_MERGEDn        = 16
)

const (
	ENABLE_CHANNEL        CHANNELCTRL_SET = 0xFF << 0  //+ Setting a bit in this field enables the DMA channel associated with it
	CH0                   CHANNELCTRL_SET = 0x01 << 0  //  CH0
	CH1                   CHANNELCTRL_SET = 0x02 << 0  //  CH1
	CH2                   CHANNELCTRL_SET = 0x04 << 0  //  CH2
	CH3                   CHANNELCTRL_SET = 0x08 << 0  //  CH3
	HIGH_PRIORITY_CHANNEL CHANNELCTRL_SET = 0xFF << 8  //+ Setting a bit in this field causes the corresponding channel to have high-priority arbitration
	CH0                   CHANNELCTRL_SET = 0x01 << 8  //  CH0
	CH1                   CHANNELCTRL_SET = 0x02 << 8  //  CH1
	CH2                   CHANNELCTRL_SET = 0x04 << 8  //  CH2
	CH3                   CHANNELCTRL_SET = 0x08 << 8  //  CH3
	CH0_IRQ_MERGED        CHANNELCTRL_SET = 0x01 << 16 //+ Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
)

const (
	ENABLE_CHANNELn        = 0
	HIGH_PRIORITY_CHANNELn = 8
	CH0_IRQ_MERGEDn        = 16
)

const (
	ENABLE_CHANNEL        CHANNELCTRL_CLR = 0xFF << 0  //+ Setting a bit in this field enables the DMA channel associated with it
	CH0                   CHANNELCTRL_CLR = 0x01 << 0  //  CH0
	CH1                   CHANNELCTRL_CLR = 0x02 << 0  //  CH1
	CH2                   CHANNELCTRL_CLR = 0x04 << 0  //  CH2
	CH3                   CHANNELCTRL_CLR = 0x08 << 0  //  CH3
	HIGH_PRIORITY_CHANNEL CHANNELCTRL_CLR = 0xFF << 8  //+ Setting a bit in this field causes the corresponding channel to have high-priority arbitration
	CH0                   CHANNELCTRL_CLR = 0x01 << 8  //  CH0
	CH1                   CHANNELCTRL_CLR = 0x02 << 8  //  CH1
	CH2                   CHANNELCTRL_CLR = 0x04 << 8  //  CH2
	CH3                   CHANNELCTRL_CLR = 0x08 << 8  //  CH3
	CH0_IRQ_MERGED        CHANNELCTRL_CLR = 0x01 << 16 //+ Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
)

const (
	ENABLE_CHANNELn        = 0
	HIGH_PRIORITY_CHANNELn = 8
	CH0_IRQ_MERGEDn        = 16
)

const (
	ENABLE_CHANNEL        CHANNELCTRL_TOG = 0xFF << 0  //+ Setting a bit in this field enables the DMA channel associated with it
	CH0                   CHANNELCTRL_TOG = 0x01 << 0  //  CH0
	CH1                   CHANNELCTRL_TOG = 0x02 << 0  //  CH1
	CH2                   CHANNELCTRL_TOG = 0x04 << 0  //  CH2
	CH3                   CHANNELCTRL_TOG = 0x08 << 0  //  CH3
	HIGH_PRIORITY_CHANNEL CHANNELCTRL_TOG = 0xFF << 8  //+ Setting a bit in this field causes the corresponding channel to have high-priority arbitration
	CH0                   CHANNELCTRL_TOG = 0x01 << 8  //  CH0
	CH1                   CHANNELCTRL_TOG = 0x02 << 8  //  CH1
	CH2                   CHANNELCTRL_TOG = 0x04 << 8  //  CH2
	CH3                   CHANNELCTRL_TOG = 0x08 << 8  //  CH3
	CH0_IRQ_MERGED        CHANNELCTRL_TOG = 0x01 << 16 //+ Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
)

const (
	ENABLE_CHANNELn        = 0
	HIGH_PRIORITY_CHANNELn = 8
	CH0_IRQ_MERGEDn        = 16
)

const (
	NUM_KEYS           CAPABILITY0 = 0xFF << 0  //+ Encoded value indicating the number of key-storage locations implemented in the design
	NUM_CHANNELS       CAPABILITY0 = 0x0F << 8  //+ Encoded value indicating the number of channels implemented in the design
	DISABLE_UNIQUE_KEY CAPABILITY0 = 0x01 << 29 //+ Write to a 1 to disable the per-device unique key
	DISABLE_DECRYPT    CAPABILITY0 = 0x01 << 31 //+ Write to 1 to disable the decryption
)

const (
	NUM_KEYSn           = 0
	NUM_CHANNELSn       = 8
	DISABLE_UNIQUE_KEYn = 29
	DISABLE_DECRYPTn    = 31
)

const (
	CIPHER_ALGORITHMS CAPABILITY1 = 0xFFFF << 0  //+ One-hot field indicating which cipher algorithms are available
	AES128            CAPABILITY1 = 0x01 << 0    //  AES128
	HASH_ALGORITHMS   CAPABILITY1 = 0xFFFF << 16 //+ One-hot field indicating which hashing features are implemented in the hardware
	SHA1              CAPABILITY1 = 0x01 << 16   //  SHA1
	CRC32             CAPABILITY1 = 0x02 << 16   //  CRC32
	SHA256            CAPABILITY1 = 0x04 << 16   //  SHA256
)

const (
	CIPHER_ALGORITHMSn = 0
	HASH_ALGORITHMSn   = 16
)

const (
	ADDR CONTEXT = 0xFFFFFFFF << 0 //+ Context pointer address
)

const (
	ADDRn = 0
)

const (
	SUBWORD KEY = 0x03 << 0 //+ Key subword pointer
	INDEX   KEY = 0x03 << 4 //+ Key index pointer. The valid indices are 0-[number_keys].
)

const (
	SUBWORDn = 0
	INDEXn   = 4
)

const (
	DATA KEYDATA = 0xFFFFFFFF << 0 //+ Word 0 data for the key. This is the least-significant word.
)

const (
	DATAn = 0
)

const (
	ADDR PACKET0 = 0xFFFFFFFF << 0 //+ Next pointer register
)

const (
	ADDRn = 0
)

const (
	INTERRUPT        PACKET1 = 0x01 << 0  //+ Reflects whether the channel must issue an interrupt upon the completion of the packet.
	DECR_SEMAPHORE   PACKET1 = 0x01 << 1  //+ Reflects whether the channel's semaphore must be decremented at the end of the current operation
	CHAIN            PACKET1 = 0x01 << 2  //+ Reflects whether the next command pointer register must be loaded into the channel's current descriptor pointer
	CHAIN_CONTIGUOUS PACKET1 = 0x01 << 3  //+ Reflects whether the next packet's address is located following this packet's payload.
	ENABLE_MEMCOPY   PACKET1 = 0x01 << 4  //+ Reflects whether the selected hashing function should be enabled for this operation.
	ENABLE_CIPHER    PACKET1 = 0x01 << 5  //+ Reflects whether the selected cipher function must be enabled for this operation.
	ENABLE_HASH      PACKET1 = 0x01 << 6  //+ Reflects whether the selected hashing function must be enabled for this operation.
	ENABLE_BLIT      PACKET1 = 0x01 << 7  //+ Reflects whether the DCP must perform a blit operation
	CIPHER_ENCRYPT   PACKET1 = 0x01 << 8  //+ When the cipher block is enabled, this bit indicates whether the operation is encryption or decryption
	CIPHER_INIT      PACKET1 = 0x01 << 9  //+ Reflects whether the cipher block must load the initialization vector from the payload for this operation
	OTP_KEY          PACKET1 = 0x01 << 10 //+ Reflects whether a hardware-based key must be used
	PAYLOAD_KEY      PACKET1 = 0x01 << 11 //+ When set, it indicates the payload contains the key
	HASH_INIT        PACKET1 = 0x01 << 12 //+ Reflects whether the current hashing block is the initial block in the hashing operation, so the hash registers must be initialized before the operation
	HASH_TERM        PACKET1 = 0x01 << 13 //+ Reflects whether the current hashing block is the final block in the hashing operation, so the hash padding must be applied by the hardware
	CHECK_HASH       PACKET1 = 0x01 << 14 //+ Reflects whether the calculated hash value must be compared to the hash provided in the payload.
	HASH_OUTPUT      PACKET1 = 0x01 << 15 //+ When the hashing is enabled, this bit controls whether the input or output data is hashed.
	CONSTANT_FILL    PACKET1 = 0x01 << 16 //+ When this bit is set (MEMCOPY and BLIT modes only), the DCP simply fills the destination buffer with the value found in the source address field
	TEST_SEMA_IRQ    PACKET1 = 0x01 << 17 //+ This bit is used to test the channel semaphore transition to 0. FOR TEST USE ONLY!
	KEY_BYTESWAP     PACKET1 = 0x01 << 18 //+ Reflects whether the DCP engine swaps the key bytes (big-endian key).
	KEY_WORDSWAP     PACKET1 = 0x01 << 19 //+ Reflects whether the DCP engine swaps the key words (big-endian key).
	INPUT_BYTESWAP   PACKET1 = 0x01 << 20 //+ Reflects whether the DCP engine byteswaps the input data (big-endian data).
	INPUT_WORDSWAP   PACKET1 = 0x01 << 21 //+ Reflects whether the DCP engine wordswaps the input data (big-endian data).
	OUTPUT_BYTESWAP  PACKET1 = 0x01 << 22 //+ Reflects whether the DCP engine byteswaps the output data (big-endian data).
	OUTPUT_WORDSWAP  PACKET1 = 0x01 << 23 //+ Reflects whether the DCP engine wordswaps the output data (big-endian data).
	TAG              PACKET1 = 0xFF << 24 //+ Packet Tag
)

const (
	INTERRUPTn        = 0
	DECR_SEMAPHOREn   = 1
	CHAINn            = 2
	CHAIN_CONTIGUOUSn = 3
	ENABLE_MEMCOPYn   = 4
	ENABLE_CIPHERn    = 5
	ENABLE_HASHn      = 6
	ENABLE_BLITn      = 7
	CIPHER_ENCRYPTn   = 8
	CIPHER_INITn      = 9
	OTP_KEYn          = 10
	PAYLOAD_KEYn      = 11
	HASH_INITn        = 12
	HASH_TERMn        = 13
	CHECK_HASHn       = 14
	HASH_OUTPUTn      = 15
	CONSTANT_FILLn    = 16
	TEST_SEMA_IRQn    = 17
	KEY_BYTESWAPn     = 18
	KEY_WORDSWAPn     = 19
	INPUT_BYTESWAPn   = 20
	INPUT_WORDSWAPn   = 21
	OUTPUT_BYTESWAPn  = 22
	OUTPUT_WORDSWAPn  = 23
	TAGn              = 24
)

const (
	CIPHER_SELECT PACKET2 = 0x0F << 0  //+ Cipher selection field
	AES128        PACKET2 = 0x00 << 0  //  AES128
	CIPHER_MODE   PACKET2 = 0x0F << 4  //+ Cipher mode selection field. Reflects the mode of operation for the cipher operations.
	ECB           PACKET2 = 0x00 << 4  //  ECB
	CBC           PACKET2 = 0x01 << 4  //  CBC
	KEY_SELECT    PACKET2 = 0xFF << 8  //+ Key selection field
	KEY0          PACKET2 = 0x00 << 8  //  KEY0
	KEY1          PACKET2 = 0x01 << 8  //  KEY1
	KEY2          PACKET2 = 0x02 << 8  //  KEY2
	KEY3          PACKET2 = 0x03 << 8  //  KEY3
	UNIQUE_KEY    PACKET2 = 0xFE << 8  //  UNIQUE_KEY
	OTP_KEY       PACKET2 = 0xFF << 8  //  OTP_KEY
	HASH_SELECT   PACKET2 = 0x0F << 16 //+ Hash Selection Field
	SHA1          PACKET2 = 0x00 << 16 //  SHA1
	CRC32         PACKET2 = 0x01 << 16 //  CRC32
	SHA256        PACKET2 = 0x02 << 16 //  SHA256
	CIPHER_CFG    PACKET2 = 0xFF << 24 //+ Cipher configuration bits. Optional configuration bits are required for the ciphers.
)

const (
	CIPHER_SELECTn = 0
	CIPHER_MODEn   = 4
	KEY_SELECTn    = 8
	HASH_SELECTn   = 16
	CIPHER_CFGn    = 24
)

const (
	ADDR PACKET3 = 0xFFFFFFFF << 0 //+ Source buffer address pointer
)

const (
	ADDRn = 0
)

const (
	ADDR PACKET4 = 0xFFFFFFFF << 0 //+ Destination buffer address pointer
)

const (
	ADDRn = 0
)

const (
	COUNT PACKET5 = 0xFFFFFFFF << 0 //+ Byte count register. This value is the working value and updates as the operation proceeds.
)

const (
	COUNTn = 0
)

const (
	ADDR PACKET6 = 0xFFFFFFFF << 0 //+ This regiser reflects the payload pointer for the current control packet.
)

const (
	ADDRn = 0
)

const (
	ADDR CH0CMDPTR = 0xFFFFFFFF << 0 //+ Pointer to the descriptor structure to be processed for channel 0.
)

const (
	ADDRn = 0
)

const (
	INCREMENT CH0SEMA = 0xFF << 0  //+ The value written to this field is added to the semaphore count in an atomic way such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
	VALUE     CH0SEMA = 0xFF << 16 //+ This read-only field shows the current (instantaneous) value of the semaphore counter.
)

const (
	INCREMENTn = 0
	VALUEn     = 16
)

const (
	HASH_MISMATCH   CH0STAT = 0x01 << 1  //+ This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH0STAT = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH0STAT = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
	ERROR_SRC       CH0STAT = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH0STAT = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH0STAT = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH0STAT = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions
	NEXT_CHAIN_IS_0 CH0STAT = 0x01 << 16 //  Error signalled because the next pointer is 0x00000000
	NO_CHAIN        CH0STAT = 0x02 << 16 //  Error signalled because the semaphore is non-zero and neither chain bit is set
	CONTEXT_ERROR   CH0STAT = 0x03 << 16 //  Error signalled because an error is reported reading/writing the context buffer
	PAYLOAD_ERROR   CH0STAT = 0x04 << 16 //  Error signalled because an error is reported reading/writing the payload
	INVALID_MODE    CH0STAT = 0x05 << 16 //  Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	TAG             CH0STAT = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH0STAT_SET = 0x01 << 1  //+ This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH0STAT_SET = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH0STAT_SET = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
	ERROR_SRC       CH0STAT_SET = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH0STAT_SET = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH0STAT_SET = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH0STAT_SET = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions
	NEXT_CHAIN_IS_0 CH0STAT_SET = 0x01 << 16 //  Error signalled because the next pointer is 0x00000000
	NO_CHAIN        CH0STAT_SET = 0x02 << 16 //  Error signalled because the semaphore is non-zero and neither chain bit is set
	CONTEXT_ERROR   CH0STAT_SET = 0x03 << 16 //  Error signalled because an error is reported reading/writing the context buffer
	PAYLOAD_ERROR   CH0STAT_SET = 0x04 << 16 //  Error signalled because an error is reported reading/writing the payload
	INVALID_MODE    CH0STAT_SET = 0x05 << 16 //  Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	TAG             CH0STAT_SET = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH0STAT_CLR = 0x01 << 1  //+ This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH0STAT_CLR = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH0STAT_CLR = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
	ERROR_SRC       CH0STAT_CLR = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH0STAT_CLR = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH0STAT_CLR = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH0STAT_CLR = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions
	NEXT_CHAIN_IS_0 CH0STAT_CLR = 0x01 << 16 //  Error signalled because the next pointer is 0x00000000
	NO_CHAIN        CH0STAT_CLR = 0x02 << 16 //  Error signalled because the semaphore is non-zero and neither chain bit is set
	CONTEXT_ERROR   CH0STAT_CLR = 0x03 << 16 //  Error signalled because an error is reported reading/writing the context buffer
	PAYLOAD_ERROR   CH0STAT_CLR = 0x04 << 16 //  Error signalled because an error is reported reading/writing the payload
	INVALID_MODE    CH0STAT_CLR = 0x05 << 16 //  Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	TAG             CH0STAT_CLR = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH0STAT_TOG = 0x01 << 1  //+ This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH0STAT_TOG = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH0STAT_TOG = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
	ERROR_SRC       CH0STAT_TOG = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH0STAT_TOG = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH0STAT_TOG = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH0STAT_TOG = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions
	NEXT_CHAIN_IS_0 CH0STAT_TOG = 0x01 << 16 //  Error signalled because the next pointer is 0x00000000
	NO_CHAIN        CH0STAT_TOG = 0x02 << 16 //  Error signalled because the semaphore is non-zero and neither chain bit is set
	CONTEXT_ERROR   CH0STAT_TOG = 0x03 << 16 //  Error signalled because an error is reported reading/writing the context buffer
	PAYLOAD_ERROR   CH0STAT_TOG = 0x04 << 16 //  Error signalled because an error is reported reading/writing the payload
	INVALID_MODE    CH0STAT_TOG = 0x05 << 16 //  Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	TAG             CH0STAT_TOG = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	RECOVERY_TIMER CH0OPTS = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH0OPTS_SET = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH0OPTS_CLR = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH0OPTS_TOG = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	ADDR CH1CMDPTR = 0xFFFFFFFF << 0 //+ Pointer to the descriptor structure to be processed for channel 1.
)

const (
	ADDRn = 0
)

const (
	INCREMENT CH1SEMA = 0xFF << 0  //+ The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and the DCP hardware substracts happening on the same clock are protected
	VALUE     CH1SEMA = 0xFF << 16 //+ This read-only field shows the current (instantaneous) value of the semaphore counter.
)

const (
	INCREMENTn = 0
	VALUEn     = 16
)

const (
	HASH_MISMATCH   CH1STAT = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH1STAT = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH1STAT = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH1STAT = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH1STAT = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH1STAT = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH1STAT = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH1STAT = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH1STAT = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH1STAT = 0x03 << 16 //  Error is signalled because an error was reported when reading/writing the context buffer.
	PAYLOAD_ERROR   CH1STAT = 0x04 << 16 //  Error is signalled because an error was reported when reading/writing the payload.
	INVALID_MODE    CH1STAT = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH1STAT = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH1STAT_SET = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH1STAT_SET = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH1STAT_SET = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH1STAT_SET = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH1STAT_SET = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH1STAT_SET = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH1STAT_SET = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH1STAT_SET = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH1STAT_SET = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH1STAT_SET = 0x03 << 16 //  Error is signalled because an error was reported when reading/writing the context buffer.
	PAYLOAD_ERROR   CH1STAT_SET = 0x04 << 16 //  Error is signalled because an error was reported when reading/writing the payload.
	INVALID_MODE    CH1STAT_SET = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH1STAT_SET = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH1STAT_CLR = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH1STAT_CLR = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH1STAT_CLR = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH1STAT_CLR = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH1STAT_CLR = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH1STAT_CLR = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH1STAT_CLR = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH1STAT_CLR = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH1STAT_CLR = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH1STAT_CLR = 0x03 << 16 //  Error is signalled because an error was reported when reading/writing the context buffer.
	PAYLOAD_ERROR   CH1STAT_CLR = 0x04 << 16 //  Error is signalled because an error was reported when reading/writing the payload.
	INVALID_MODE    CH1STAT_CLR = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH1STAT_CLR = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH1STAT_TOG = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH1STAT_TOG = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH1STAT_TOG = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH1STAT_TOG = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH1STAT_TOG = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH1STAT_TOG = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH1STAT_TOG = 0xFF << 16 //+ Indicates the additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH1STAT_TOG = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH1STAT_TOG = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH1STAT_TOG = 0x03 << 16 //  Error is signalled because an error was reported when reading/writing the context buffer.
	PAYLOAD_ERROR   CH1STAT_TOG = 0x04 << 16 //  Error is signalled because an error was reported when reading/writing the payload.
	INVALID_MODE    CH1STAT_TOG = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH1STAT_TOG = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	RECOVERY_TIMER CH1OPTS = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH1OPTS_SET = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH1OPTS_CLR = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH1OPTS_TOG = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	ADDR CH2CMDPTR = 0xFFFFFFFF << 0 //+ Pointer to the descriptor structure to be processed for channel 2.
)

const (
	ADDRn = 0
)

const (
	INCREMENT CH2SEMA = 0xFF << 0  //+ The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
	VALUE     CH2SEMA = 0xFF << 16 //+ This read-only field shows the current (instantaneous) value of the semaphore counter.
)

const (
	INCREMENTn = 0
	VALUEn     = 16
)

const (
	HASH_MISMATCH   CH2STAT = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH2STAT = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH2STAT = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH2STAT = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH2STAT = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH2STAT = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH2STAT = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH2STAT = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH2STAT = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH2STAT = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH2STAT = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH2STAT = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	TAG             CH2STAT = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH2STAT_SET = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH2STAT_SET = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH2STAT_SET = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH2STAT_SET = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH2STAT_SET = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH2STAT_SET = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH2STAT_SET = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH2STAT_SET = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH2STAT_SET = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH2STAT_SET = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH2STAT_SET = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH2STAT_SET = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	TAG             CH2STAT_SET = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH2STAT_CLR = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH2STAT_CLR = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH2STAT_CLR = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH2STAT_CLR = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH2STAT_CLR = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH2STAT_CLR = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH2STAT_CLR = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH2STAT_CLR = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH2STAT_CLR = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH2STAT_CLR = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH2STAT_CLR = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH2STAT_CLR = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	TAG             CH2STAT_CLR = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH2STAT_TOG = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH2STAT_TOG = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH2STAT_TOG = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
	ERROR_SRC       CH2STAT_TOG = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH2STAT_TOG = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH2STAT_TOG = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH2STAT_TOG = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH2STAT_TOG = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH2STAT_TOG = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH2STAT_TOG = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH2STAT_TOG = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH2STAT_TOG = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	TAG             CH2STAT_TOG = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	RECOVERY_TIMER CH2OPTS = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH2OPTS_SET = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH2OPTS_CLR = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH2OPTS_TOG = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	ADDR CH3CMDPTR = 0xFFFFFFFF << 0 //+ Pointer to the descriptor structure to be processed for channel 3.
)

const (
	ADDRn = 0
)

const (
	INCREMENT CH3SEMA = 0xFF << 0  //+ The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
	VALUE     CH3SEMA = 0xFF << 16 //+ This read-only field shows the current (instantaneous) value of the semaphore counter.
)

const (
	INCREMENTn = 0
	VALUEn     = 16
)

const (
	HASH_MISMATCH   CH3STAT = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH3STAT = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH3STAT = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
	ERROR_SRC       CH3STAT = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH3STAT = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH3STAT = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH3STAT = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH3STAT = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH3STAT = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH3STAT = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH3STAT = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH3STAT = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH3STAT = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH3STAT_SET = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH3STAT_SET = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH3STAT_SET = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
	ERROR_SRC       CH3STAT_SET = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH3STAT_SET = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH3STAT_SET = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH3STAT_SET = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH3STAT_SET = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH3STAT_SET = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH3STAT_SET = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH3STAT_SET = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH3STAT_SET = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH3STAT_SET = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH3STAT_CLR = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH3STAT_CLR = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH3STAT_CLR = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
	ERROR_SRC       CH3STAT_CLR = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH3STAT_CLR = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH3STAT_CLR = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH3STAT_CLR = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH3STAT_CLR = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH3STAT_CLR = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH3STAT_CLR = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH3STAT_CLR = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH3STAT_CLR = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH3STAT_CLR = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	HASH_MISMATCH   CH3STAT_TOG = 0x01 << 1  //+ This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
	ERROR_SETUP     CH3STAT_TOG = 0x01 << 2  //+ This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
	ERROR_PACKET    CH3STAT_TOG = 0x01 << 3  //+ This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
	ERROR_SRC       CH3STAT_TOG = 0x01 << 4  //+ This bit indicates that a bus error occurred when reading from the source buffer
	ERROR_DST       CH3STAT_TOG = 0x01 << 5  //+ This bit indicates that a bus error occurred when storing to the destination buffer
	ERROR_PAGEFAULT CH3STAT_TOG = 0x01 << 6  //+ This bit indicates that a page fault occurred while converting a virtual address to a physical address
	ERROR_CODE      CH3STAT_TOG = 0xFF << 16 //+ Indicates additional error codes for some of the error conditions.
	NEXT_CHAIN_IS_0 CH3STAT_TOG = 0x01 << 16 //  Error is signalled because the next pointer is 0x00000000.
	NO_CHAIN        CH3STAT_TOG = 0x02 << 16 //  Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	CONTEXT_ERROR   CH3STAT_TOG = 0x03 << 16 //  Error is signalled because an error was reported while reading/writing the context buffer.
	PAYLOAD_ERROR   CH3STAT_TOG = 0x04 << 16 //  Error is signalled because an error was reported while reading/writing the payload.
	INVALID_MODE    CH3STAT_TOG = 0x05 << 16 //  Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	TAG             CH3STAT_TOG = 0xFF << 24 //+ Indicates the tag from the last completed packet in the command structure.
)

const (
	HASH_MISMATCHn   = 1
	ERROR_SETUPn     = 2
	ERROR_PACKETn    = 3
	ERROR_SRCn       = 4
	ERROR_DSTn       = 5
	ERROR_PAGEFAULTn = 6
	ERROR_CODEn      = 16
	TAGn             = 24
)

const (
	RECOVERY_TIMER CH3OPTS = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH3OPTS_SET = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH3OPTS_CLR = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	RECOVERY_TIMER CH3OPTS_TOG = 0xFFFF << 0 //+ This field indicates the recovery time for the channel
)

const (
	RECOVERY_TIMERn = 0
)

const (
	INDEX   DBGSELECT = 0xFF << 0 //+ Selects a value to read via the debug data register.
	CONTROL DBGSELECT = 0x01 << 0 //  CONTROL
	OTPKEY0 DBGSELECT = 0x10 << 0 //  OTPKEY0
	OTPKEY1 DBGSELECT = 0x11 << 0 //  OTPKEY1
	OTPKEY2 DBGSELECT = 0x12 << 0 //  OTPKEY2
	OTPKEY3 DBGSELECT = 0x13 << 0 //  OTPKEY3
)

const (
	INDEXn = 0
)

const (
	DATA DBGDATA = 0xFFFFFFFF << 0 //+ Debug data
)

const (
	DATAn = 0
)

const (
	ENABLE PAGETABLE = 0x01 << 0       //+ Page table enable control
	FLUSH  PAGETABLE = 0x01 << 1       //+ Page table flush control. To flush the TLB, write this bit to 1 and then back to 0.
	BASE   PAGETABLE = 0x3FFFFFFF << 2 //+ Page table base address
)

const (
	ENABLEn = 0
	FLUSHn  = 1
	BASEn   = 2
)

const (
	STEP  VERSION = 0xFFFF << 0 //+ Fixed read-only value reflecting the stepping of the version of the design implementation.
	MINOR VERSION = 0xFF << 16  //+ Fixed read-only value reflecting the MINOR version of the design implementation.
	MAJOR VERSION = 0xFF << 24  //+ Fixed read-only value reflecting the MAJOR version of the design implementation.
)

const (
	STEPn  = 0
	MINORn = 16
	MAJORn = 24
)
