// Code generated by svdxgen; DO NOT EDIT.

//go:build imxrt1060

// Package pmu provides access to the registers of the PMU peripheral.
//
// Instances:
//
//	PMU  PMU_BASE  -  PMU_EVENT*
//
// Registers:
//
//	0x110 32  REG_1P1(REG)            Regulator 1P1 Register
//	0x114 32  REG_1P1_SET(REG)        Regulator 1P1 Register
//	0x118 32  REG_1P1_CLR(REG)        Regulator 1P1 Register
//	0x11C 32  REG_1P1_TOG(REG)        Regulator 1P1 Register
//	0x120 32  REG_3P0(REG)            Regulator 3P0 Register
//	0x124 32  REG_3P0_SET(REG)        Regulator 3P0 Register
//	0x128 32  REG_3P0_CLR(REG)        Regulator 3P0 Register
//	0x12C 32  REG_3P0_TOG(REG)        Regulator 3P0 Register
//	0x130 32  REG_2P5(REG)            Regulator 2P5 Register
//	0x134 32  REG_2P5_SET(REG)        Regulator 2P5 Register
//	0x138 32  REG_2P5_CLR(REG)        Regulator 2P5 Register
//	0x13C 32  REG_2P5_TOG(REG)        Regulator 2P5 Register
//	0x140 32  REG_CORE                Digital Regulator Core Register
//	0x144 32  REG_CORE_SET(REG_CORE)  Digital Regulator Core Register
//	0x148 32  REG_CORE_CLR(REG_CORE)  Digital Regulator Core Register
//	0x14C 32  REG_CORE_TOG(REG_CORE)  Digital Regulator Core Register
//	0x150 32  MISC0                   Miscellaneous Register 0
//	0x154 32  MISC0_SET(MISC0)        Miscellaneous Register 0
//	0x158 32  MISC0_CLR(MISC0)        Miscellaneous Register 0
//	0x15C 32  MISC0_TOG(MISC0)        Miscellaneous Register 0
//	0x160 32  MISC1                   Miscellaneous Register 1
//	0x164 32  MISC1_SET(MISC1)        Miscellaneous Register 1
//	0x168 32  MISC1_CLR(MISC1)        Miscellaneous Register 1
//	0x16C 32  MISC1_TOG(MISC1)        Miscellaneous Register 1
//	0x170 32  MISC2                   Miscellaneous Control Register
//	0x174 32  MISC2_SET(MISC2)        Miscellaneous Control Register
//	0x178 32  MISC2_CLR(MISC2)        Miscellaneous Control Register
//	0x17C 32  MISC2_TOG(MISC2)        Miscellaneous Control Register
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package pmu

const (
	ENABLE_LINREG      REG = 0x01 << 0  //+ Control bit to enable the regulator output.
	ENABLE_BO          REG = 0x01 << 1  //+ Control bit to enable the brownout circuitry in the regulator.
	ENABLE_ILIMIT      REG = 0x01 << 2  //+ Control bit to enable the current-limit circuitry in the regulator.
	ENABLE_PULLDOWN    REG = 0x01 << 3  //+ Control bit to enable the pull-down circuitry in the regulator
	BO_OFFSET          REG = 0x07 << 4  //+ Control bits to adjust the regulator brownout offset voltage in 25mV steps
	OUTPUT_TRG         REG = 0x1F << 8  //+ Control bits to adjust the regulator output voltage
	BO_VDD1P1          REG = 0x01 << 16 //+ Status bit that signals when a brownout is detected on the regulator output.
	OK_VDD1P1          REG = 0x01 << 17 //+ Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
	ENABLE_WEAK_LINREG REG = 0x01 << 18 //+ Enables the weak 1p1 or 2p5 regulator
	SELREF_WEAK_LINREG REG = 0x01 << 19 //+ Selects the source for the reference voltage of the weak 1p1 regulator.
)

const (
	ENABLE_LINREGn      = 0
	ENABLE_BOn          = 1
	ENABLE_ILIMITn      = 2
	ENABLE_PULLDOWNn    = 3
	BO_OFFSETn          = 4
	OUTPUT_TRGn         = 8
	BO_VDD1P1n          = 16
	OK_VDD1P1n          = 17
	ENABLE_WEAK_LINREGn = 18
	SELREF_WEAK_LINREGn = 19
)

const (
	REG0_TARG    REG_CORE = 0x1F << 0  //+ This field defines the target voltage for the ARM core power domain
	REG0_TARG_0  REG_CORE = 0x00 << 0  //  Power gated off
	REG0_TARG_1  REG_CORE = 0x01 << 0  //  Target core voltage = 0.725V
	REG0_TARG_2  REG_CORE = 0x02 << 0  //  Target core voltage = 0.750V
	REG0_TARG_3  REG_CORE = 0x03 << 0  //  Target core voltage = 0.775V
	REG0_TARG_16 REG_CORE = 0x10 << 0  //  Target core voltage = 1.100V
	REG0_TARG_30 REG_CORE = 0x1E << 0  //  Target core voltage = 1.450V
	REG0_TARG_31 REG_CORE = 0x1F << 0  //  Power FET switched full on. No regulation.
	REG0_ADJ     REG_CORE = 0x0F << 5  //+ This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
	REG0_ADJ_0   REG_CORE = 0x00 << 5  //  No adjustment
	REG0_ADJ_1   REG_CORE = 0x01 << 5  //  + 0.25%
	REG0_ADJ_2   REG_CORE = 0x02 << 5  //  + 0.50%
	REG0_ADJ_3   REG_CORE = 0x03 << 5  //  + 0.75%
	REG0_ADJ_4   REG_CORE = 0x04 << 5  //  + 1.00%
	REG0_ADJ_5   REG_CORE = 0x05 << 5  //  + 1.25%
	REG0_ADJ_6   REG_CORE = 0x06 << 5  //  + 1.50%
	REG0_ADJ_7   REG_CORE = 0x07 << 5  //  + 1.75%
	REG0_ADJ_8   REG_CORE = 0x08 << 5  //  - 0.25%
	REG0_ADJ_9   REG_CORE = 0x09 << 5  //  - 0.50%
	REG0_ADJ_10  REG_CORE = 0x0A << 5  //  - 0.75%
	REG0_ADJ_11  REG_CORE = 0x0B << 5  //  - 1.00%
	REG0_ADJ_12  REG_CORE = 0x0C << 5  //  - 1.25%
	REG0_ADJ_13  REG_CORE = 0x0D << 5  //  - 1.50%
	REG0_ADJ_14  REG_CORE = 0x0E << 5  //  - 1.75%
	REG0_ADJ_15  REG_CORE = 0x0F << 5  //  - 2.00%
	REG1_TARG    REG_CORE = 0x1F << 9  //+ This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
	REG1_TARG_0  REG_CORE = 0x00 << 9  //  Power gated off
	REG1_TARG_1  REG_CORE = 0x01 << 9  //  Target core voltage = 0.725V
	REG1_TARG_2  REG_CORE = 0x02 << 9  //  Target core voltage = 0.750V
	REG1_TARG_3  REG_CORE = 0x03 << 9  //  Target core voltage = 0.775V
	REG1_TARG_16 REG_CORE = 0x10 << 9  //  Target core voltage = 1.100V
	REG1_TARG_30 REG_CORE = 0x1E << 9  //  Target core voltage = 1.450V
	REG1_TARG_31 REG_CORE = 0x1F << 9  //  Power FET switched full on. No regulation.
	REG1_ADJ     REG_CORE = 0x0F << 14 //+ This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
	REG1_ADJ_0   REG_CORE = 0x00 << 14 //  No adjustment
	REG1_ADJ_1   REG_CORE = 0x01 << 14 //  + 0.25%
	REG1_ADJ_2   REG_CORE = 0x02 << 14 //  + 0.50%
	REG1_ADJ_3   REG_CORE = 0x03 << 14 //  + 0.75%
	REG1_ADJ_4   REG_CORE = 0x04 << 14 //  + 1.00%
	REG1_ADJ_5   REG_CORE = 0x05 << 14 //  + 1.25%
	REG1_ADJ_6   REG_CORE = 0x06 << 14 //  + 1.50%
	REG1_ADJ_7   REG_CORE = 0x07 << 14 //  + 1.75%
	REG1_ADJ_8   REG_CORE = 0x08 << 14 //  - 0.25%
	REG1_ADJ_9   REG_CORE = 0x09 << 14 //  - 0.50%
	REG1_ADJ_10  REG_CORE = 0x0A << 14 //  - 0.75%
	REG1_ADJ_11  REG_CORE = 0x0B << 14 //  - 1.00%
	REG1_ADJ_12  REG_CORE = 0x0C << 14 //  - 1.25%
	REG1_ADJ_13  REG_CORE = 0x0D << 14 //  - 1.50%
	REG1_ADJ_14  REG_CORE = 0x0E << 14 //  - 1.75%
	REG1_ADJ_15  REG_CORE = 0x0F << 14 //  - 2.00%
	REG2_TARG    REG_CORE = 0x1F << 18 //+ This field defines the target voltage for the SOC power domain
	REG2_TARG_0  REG_CORE = 0x00 << 18 //  Power gated off
	REG2_TARG_1  REG_CORE = 0x01 << 18 //  Target core voltage = 0.725V
	REG2_TARG_2  REG_CORE = 0x02 << 18 //  Target core voltage = 0.750V
	REG2_TARG_3  REG_CORE = 0x03 << 18 //  Target core voltage = 0.775V
	REG2_TARG_16 REG_CORE = 0x10 << 18 //  Target core voltage = 1.100V
	REG2_TARG_30 REG_CORE = 0x1E << 18 //  Target core voltage = 1.450V
	REG2_TARG_31 REG_CORE = 0x1F << 18 //  Power FET switched full on. No regulation.
	REG2_ADJ     REG_CORE = 0x0F << 23 //+ This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
	REG2_ADJ_0   REG_CORE = 0x00 << 23 //  No adjustment
	REG2_ADJ_1   REG_CORE = 0x01 << 23 //  + 0.25%
	REG2_ADJ_2   REG_CORE = 0x02 << 23 //  + 0.50%
	REG2_ADJ_3   REG_CORE = 0x03 << 23 //  + 0.75%
	REG2_ADJ_4   REG_CORE = 0x04 << 23 //  + 1.00%
	REG2_ADJ_5   REG_CORE = 0x05 << 23 //  + 1.25%
	REG2_ADJ_6   REG_CORE = 0x06 << 23 //  + 1.50%
	REG2_ADJ_7   REG_CORE = 0x07 << 23 //  + 1.75%
	REG2_ADJ_8   REG_CORE = 0x08 << 23 //  - 0.25%
	REG2_ADJ_9   REG_CORE = 0x09 << 23 //  - 0.50%
	REG2_ADJ_10  REG_CORE = 0x0A << 23 //  - 0.75%
	REG2_ADJ_11  REG_CORE = 0x0B << 23 //  - 1.00%
	REG2_ADJ_12  REG_CORE = 0x0C << 23 //  - 1.25%
	REG2_ADJ_13  REG_CORE = 0x0D << 23 //  - 1.50%
	REG2_ADJ_14  REG_CORE = 0x0E << 23 //  - 1.75%
	REG2_ADJ_15  REG_CORE = 0x0F << 23 //  - 2.00%
	RAMP_RATE    REG_CORE = 0x03 << 27 //+ Regulator voltage ramp rate.
	RAMP_RATE_0  REG_CORE = 0x00 << 27 //  Fast
	RAMP_RATE_1  REG_CORE = 0x01 << 27 //  Medium Fast
	RAMP_RATE_2  REG_CORE = 0x02 << 27 //  Medium Slow
	RAMP_RATE_3  REG_CORE = 0x03 << 27 //  Slow
	FET_ODRIVE   REG_CORE = 0x01 << 29 //+ If set, increases the gate drive on power gating FETs to reduce leakage in the off state
)

const (
	REG0_TARGn  = 0
	REG0_ADJn   = 5
	REG1_TARGn  = 9
	REG1_ADJn   = 14
	REG2_TARGn  = 18
	REG2_ADJn   = 23
	RAMP_RATEn  = 27
	FET_ODRIVEn = 29
)

const (
	REFTOP_PWD         MISC0 = 0x01 << 0  //+ Control bit to power-down the analog bandgap reference circuitry
	REFTOP_SELFBIASOFF MISC0 = 0x01 << 3  //+ Control bit to disable the self-bias circuit in the analog bandgap
	REFTOP_VBGADJ      MISC0 = 0x07 << 4  //+ no description available
	REFTOP_VBGADJ_0    MISC0 = 0x00 << 4  //  Nominal VBG
	REFTOP_VBGADJ_1    MISC0 = 0x01 << 4  //  VBG+0.78%
	REFTOP_VBGADJ_2    MISC0 = 0x02 << 4  //  VBG+1.56%
	REFTOP_VBGADJ_3    MISC0 = 0x03 << 4  //  VBG+2.34%
	REFTOP_VBGADJ_4    MISC0 = 0x04 << 4  //  VBG-0.78%
	REFTOP_VBGADJ_5    MISC0 = 0x05 << 4  //  VBG-1.56%
	REFTOP_VBGADJ_6    MISC0 = 0x06 << 4  //  VBG-2.34%
	REFTOP_VBGADJ_7    MISC0 = 0x07 << 4  //  VBG-3.12%
	REFTOP_VBGUP       MISC0 = 0x01 << 7  //+ Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
	STOP_MODE_CONFIG   MISC0 = 0x03 << 10 //+ Configure the analog behavior in stop mode.
	STOP_MODE_CONFIG_0 MISC0 = 0x00 << 10 //  SUSPEND (DSM)
	STANDBY            MISC0 = 0x01 << 10 //  Analog regulators are ON.
	STOP_MODE_CONFIG_2 MISC0 = 0x02 << 10 //  STOP (lower power)
	STOP_MODE_CONFIG_3 MISC0 = 0x03 << 10 //  STOP (very lower power)
	DISCON_HIGH_SNVS   MISC0 = 0x01 << 12 //+ This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
	OSC_I              MISC0 = 0x03 << 13 //+ This field determines the bias current in the 24MHz oscillator
	NOMINAL            MISC0 = 0x00 << 13 //  Nominal
	MINUS_12_5_PERCENT MISC0 = 0x01 << 13 //  Decrease current by 12.5%
	MINUS_25_PERCENT   MISC0 = 0x02 << 13 //  Decrease current by 25.0%
	MINUS_37_5_PERCENT MISC0 = 0x03 << 13 //  Decrease current by 37.5%
	OSC_XTALOK         MISC0 = 0x01 << 15 //+ Status bit that signals that the output of the 24-MHz crystal oscillator is stable
	OSC_XTALOK_EN      MISC0 = 0x01 << 16 //+ This bit enables the detector that signals when the 24MHz crystal oscillator is stable
	CLKGATE_CTRL       MISC0 = 0x01 << 25 //+ This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
	CLKGATE_DELAY      MISC0 = 0x07 << 26 //+ This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
	CLKGATE_DELAY_0    MISC0 = 0x00 << 26 //  0.5ms
	CLKGATE_DELAY_1    MISC0 = 0x01 << 26 //  1.0ms
	CLKGATE_DELAY_2    MISC0 = 0x02 << 26 //  2.0ms
	CLKGATE_DELAY_3    MISC0 = 0x03 << 26 //  3.0ms
	CLKGATE_DELAY_4    MISC0 = 0x04 << 26 //  4.0ms
	CLKGATE_DELAY_5    MISC0 = 0x05 << 26 //  5.0ms
	CLKGATE_DELAY_6    MISC0 = 0x06 << 26 //  6.0ms
	CLKGATE_DELAY_7    MISC0 = 0x07 << 26 //  7.0ms
	RTC_XTAL_SOURCE    MISC0 = 0x01 << 29 //+ This field indicates which chip source is being used for the rtc clock.
	XTAL_24M_PWD       MISC0 = 0x01 << 30 //+ This field powers down the 24M crystal oscillator if set true.
	VID_PLL_PREDIV     MISC0 = 0x01 << 31 //+ Predivider for the source clock of the PLL's.
)

const (
	REFTOP_PWDn         = 0
	REFTOP_SELFBIASOFFn = 3
	REFTOP_VBGADJn      = 4
	REFTOP_VBGUPn       = 7
	STOP_MODE_CONFIGn   = 10
	DISCON_HIGH_SNVSn   = 12
	OSC_In              = 13
	OSC_XTALOKn         = 15
	OSC_XTALOK_ENn      = 16
	CLKGATE_CTRLn       = 25
	CLKGATE_DELAYn      = 26
	RTC_XTAL_SOURCEn    = 29
	XTAL_24M_PWDn       = 30
	VID_PLL_PREDIVn     = 31
)

const (
	LVDS1_CLK_SEL       MISC1 = 0x1F << 0  //+ This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
	LVDS1_ARM_PLL       MISC1 = 0x00 << 0  //  Arm PLL
	LVDS1_SYS_PLL       MISC1 = 0x01 << 0  //  System PLL
	LVDS1_PFD4          MISC1 = 0x02 << 0  //  ref_pfd4_clk == pll2_pfd0_clk
	LVDS1_PFD5          MISC1 = 0x03 << 0  //  ref_pfd5_clk == pll2_pfd1_clk
	LVDS1_PFD6          MISC1 = 0x04 << 0  //  ref_pfd6_clk == pll2_pfd2_clk
	LVDS1_PFD7          MISC1 = 0x05 << 0  //  ref_pfd7_clk == pll2_pfd3_clk
	LVDS1_AUDIO_PLL     MISC1 = 0x06 << 0  //  Audio PLL
	LVDS1_VIDEO_PLL     MISC1 = 0x07 << 0  //  Video PLL
	LVDS1_ETHERNET_REF  MISC1 = 0x09 << 0  //  ethernet ref clock (ENET_PLL)
	LVDS1_USB1_PLL      MISC1 = 0x0C << 0  //  USB1 PLL clock
	LVDS1_USB2_PLL      MISC1 = 0x0D << 0  //  USB2 PLL clock
	LVDS1_PFD0          MISC1 = 0x0E << 0  //  ref_pfd0_clk == pll3_pfd0_clk
	LVDS1_PFD1          MISC1 = 0x0F << 0  //  ref_pfd1_clk == pll3_pfd1_clk
	LVDS1_PFD2          MISC1 = 0x10 << 0  //  ref_pfd2_clk == pll3_pfd2_clk
	LVDS1_PFD3          MISC1 = 0x11 << 0  //  ref_pfd3_clk == pll3_pfd3_clk
	LVDS1_XTAL          MISC1 = 0x12 << 0  //  xtal (24M)
	LVDS2_CLK_SEL       MISC1 = 0x1F << 5  //+ This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
	LVDS2_ARM_PLL       MISC1 = 0x00 << 5  //  Arm PLL
	LVDS2_SYS_PLL       MISC1 = 0x01 << 5  //  System PLL
	LVDS2_PFD4          MISC1 = 0x02 << 5  //  ref_pfd4_clk == pll2_pfd0_clk
	LVDS2_PFD5          MISC1 = 0x03 << 5  //  ref_pfd5_clk == pll2_pfd1_clk
	LVDS2_PFD6          MISC1 = 0x04 << 5  //  ref_pfd6_clk == pll2_pfd2_clk
	LVDS2_PFD7          MISC1 = 0x05 << 5  //  ref_pfd7_clk == pll2_pfd3_clk
	LVDS2_AUDIO_PLL     MISC1 = 0x06 << 5  //  Audio PLL
	LVDS2_VIDEO_PLL     MISC1 = 0x07 << 5  //  Video PLL
	LVDS2_MLB_PLL       MISC1 = 0x08 << 5  //  MLB PLL
	LVDS2_ETHERNET_REF  MISC1 = 0x09 << 5  //  ethernet ref clock (ENET_PLL)
	LVDS2_PCIE_REF      MISC1 = 0x0A << 5  //  PCIe ref clock (125M)
	LVDS2_SATA_REF      MISC1 = 0x0B << 5  //  SATA ref clock (100M)
	LVDS2_USB1_PLL      MISC1 = 0x0C << 5  //  USB1 PLL clock
	LVDS2_USB2_PLL      MISC1 = 0x0D << 5  //  USB2 PLL clock
	LVDS2_PFD0          MISC1 = 0x0E << 5  //  ref_pfd0_clk == pll3_pfd0_clk
	LVDS2_PFD1          MISC1 = 0x0F << 5  //  ref_pfd1_clk == pll3_pfd1_clk
	LVDS2_PFD2          MISC1 = 0x10 << 5  //  ref_pfd2_clk == pll3_pfd2_clk
	LVDS2_PFD3          MISC1 = 0x11 << 5  //  ref_pfd3_clk == pll3_pfd3_clk
	LVDS2_XTAL          MISC1 = 0x12 << 5  //  xtal (24M)
	LVDS2_LVDS1         MISC1 = 0x13 << 5  //  LVDS1 (loopback)
	LVDS2_LVDS2         MISC1 = 0x14 << 5  //  LVDS2 (not useful)
	LVDSCLK1_OBEN       MISC1 = 0x01 << 10 //+ This enables the LVDS output buffer for anaclk1/1b
	LVDSCLK2_OBEN       MISC1 = 0x01 << 11 //+ This enables the LVDS output buffer for anaclk2/2b
	LVDSCLK1_IBEN       MISC1 = 0x01 << 12 //+ This enables the LVDS input buffer for anaclk1/1b
	LVDSCLK2_IBEN       MISC1 = 0x01 << 13 //+ This enables the LVDS input buffer for anaclk2/2b
	PFD_480_AUTOGATE_EN MISC1 = 0x01 << 16 //+ This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
	PFD_528_AUTOGATE_EN MISC1 = 0x01 << 17 //+ This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
	IRQ_TEMPPANIC       MISC1 = 0x01 << 27 //+ This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
	IRQ_TEMPLOW         MISC1 = 0x01 << 28 //+ This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
	IRQ_TEMPHIGH        MISC1 = 0x01 << 29 //+ This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
	IRQ_ANA_BO          MISC1 = 0x01 << 30 //+ This status bit is set to one when when any of the analog regulator brownout interrupts assert
	IRQ_DIG_BO          MISC1 = 0x01 << 31 //+ This status bit is set to one when when any of the digital regulator brownout interrupts assert
)

const (
	LVDS1_CLK_SELn       = 0
	LVDS2_CLK_SELn       = 5
	LVDSCLK1_OBENn       = 10
	LVDSCLK2_OBENn       = 11
	LVDSCLK1_IBENn       = 12
	LVDSCLK2_IBENn       = 13
	PFD_480_AUTOGATE_ENn = 16
	PFD_528_AUTOGATE_ENn = 17
	IRQ_TEMPPANICn       = 27
	IRQ_TEMPLOWn         = 28
	IRQ_TEMPHIGHn        = 29
	IRQ_ANA_BOn          = 30
	IRQ_DIG_BOn          = 31
)

const (
	REG0_BO_OFFSET            MISC2 = 0x07 << 0  //+ This field defines the brown out voltage offset for the CORE power domain
	REG0_BO_OFFSET_4          MISC2 = 0x04 << 0  //  Brownout offset = 0.100V
	REG0_BO_OFFSET_7          MISC2 = 0x07 << 0  //  Brownout offset = 0.175V
	REG0_BO_STATUS            MISC2 = 0x01 << 3  //+ Reg0 brownout status bit.
	REG0_ENABLE_BO            MISC2 = 0x01 << 5  //+ Enables the brownout detection.
	PLL3_disable              MISC2 = 0x01 << 7  //+ Default value of "0"
	REG1_BO_OFFSET            MISC2 = 0x07 << 8  //+ This field defines the brown out voltage offset for the xPU power domain
	REG1_BO_OFFSET_4          MISC2 = 0x04 << 8  //  Brownout offset = 0.100V
	REG1_BO_OFFSET_7          MISC2 = 0x07 << 8  //  Brownout offset = 0.175V
	REG1_BO_STATUS            MISC2 = 0x01 << 11 //+ Reg1 brownout status bit.
	REG1_ENABLE_BO            MISC2 = 0x01 << 13 //+ Enables the brownout detection.
	AUDIO_DIV_LSB             MISC2 = 0x01 << 15 //+ LSB of Post-divider for Audio PLL
	REG2_BO_OFFSET            MISC2 = 0x07 << 16 //+ This field defines the brown out voltage offset for the xPU power domain
	REG2_BO_OFFSET_4          MISC2 = 0x04 << 16 //  Brownout offset = 0.100V
	REG2_BO_OFFSET_7          MISC2 = 0x07 << 16 //  Brownout offset = 0.175V
	REG2_BO_STATUS            MISC2 = 0x01 << 19 //+ Reg2 brownout status bit.
	REG2_ENABLE_BO            MISC2 = 0x01 << 21 //+ Enables the brownout detection.
	REG2_OK                   MISC2 = 0x01 << 22 //+ Signals that the voltage is above the brownout level for the SOC supply
	AUDIO_DIV_MSB             MISC2 = 0x01 << 23 //+ MSB of Post-divider for Audio PLL
	REG0_STEP_TIME            MISC2 = 0x03 << 24 //+ Number of clock periods (24MHz clock).
	REG0_STEP_TIME_64_CLOCKS  MISC2 = 0x00 << 24 //  64
	REG0_STEP_TIME_128_CLOCKS MISC2 = 0x01 << 24 //  128
	REG0_STEP_TIME_256_CLOCKS MISC2 = 0x02 << 24 //  256
	REG0_STEP_TIME_512_CLOCKS MISC2 = 0x03 << 24 //  512
	REG1_STEP_TIME            MISC2 = 0x03 << 26 //+ Number of clock periods (24MHz clock).
	REG1_STEP_TIME_64_CLOCKS  MISC2 = 0x00 << 26 //  64
	REG1_STEP_TIME_128_CLOCKS MISC2 = 0x01 << 26 //  128
	REG1_STEP_TIME_256_CLOCKS MISC2 = 0x02 << 26 //  256
	REG1_STEP_TIME_512_CLOCKS MISC2 = 0x03 << 26 //  512
	REG2_STEP_TIME            MISC2 = 0x03 << 28 //+ Number of clock periods (24MHz clock).
	REG2_STEP_TIME_64_CLOCKS  MISC2 = 0x00 << 28 //  64
	REG2_STEP_TIME_128_CLOCKS MISC2 = 0x01 << 28 //  128
	REG2_STEP_TIME_256_CLOCKS MISC2 = 0x02 << 28 //  256
	REG2_STEP_TIME_512_CLOCKS MISC2 = 0x03 << 28 //  512
	VIDEO_DIV                 MISC2 = 0x03 << 30 //+ Post-divider for video
	VIDEO_DIV_0               MISC2 = 0x00 << 30 //  divide by 1 (Default)
	VIDEO_DIV_1               MISC2 = 0x01 << 30 //  divide by 2
	VIDEO_DIV_2               MISC2 = 0x02 << 30 //  divide by 1
	VIDEO_DIV_3               MISC2 = 0x03 << 30 //  divide by 4
)

const (
	REG0_BO_OFFSETn = 0
	REG0_BO_STATUSn = 3
	REG0_ENABLE_BOn = 5
	PLL3_disablen   = 7
	REG1_BO_OFFSETn = 8
	REG1_BO_STATUSn = 11
	REG1_ENABLE_BOn = 13
	AUDIO_DIV_LSBn  = 15
	REG2_BO_OFFSETn = 16
	REG2_BO_STATUSn = 19
	REG2_ENABLE_BOn = 21
	REG2_OKn        = 22
	AUDIO_DIV_MSBn  = 23
	REG0_STEP_TIMEn = 24
	REG1_STEP_TIMEn = 26
	REG2_STEP_TIMEn = 28
	VIDEO_DIVn      = 30
)
