// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package flexspi provides access to the registers of the FLEXSPI peripheral.
//
// Instances:
//
//	FLEXSPI   FLEXSPI_BASE   -  FLEXSPI
//	FLEXSPI2  FLEXSPI2_BASE  -  FLEXSPI2*
//
// Registers:
//
//	0x000 32  MCR0          Module Control Register 0
//	0x004 32  MCR1          Module Control Register 1
//	0x008 32  MCR2          Module Control Register 2
//	0x00C 32  AHBCR         AHB Bus Control Register
//	0x010 32  INTEN         Interrupt Enable Register
//	0x014 32  INTR          Interrupt Register
//	0x018 32  LUTKEY        LUT Key Register
//	0x01C 32  LUTCR         LUT Control Register
//	0x020 32  AHBRXBUF0CR0  AHB RX Buffer 0 Control Register 0
//	0x024 32  AHBRXBUF1CR0  AHB RX Buffer 1 Control Register 0
//	0x028 32  AHBRXBUF2CR0  AHB RX Buffer 2 Control Register 0
//	0x02C 32  AHBRXBUF3CR0  AHB RX Buffer 3 Control Register 0
//	0x060 32  FLSHA1CR0     Flash A1 Control Register 0
//	0x064 32  FLSHA2CR0     Flash A2 Control Register 0
//	0x068 32  FLSHB1CR0     Flash B1 Control Register 0
//	0x06C 32  FLSHB2CR0     Flash B2 Control Register 0
//	0x070 32  FLSHCR1[4]    Flash A1 Control Register 1
//	0x080 32  FLSHCR2[4]    Flash A1 Control Register 2
//	0x094 32  FLSHCR4       Flash Control Register 4
//	0x0A0 32  IPCR0         IP Control Register 0
//	0x0A4 32  IPCR1         IP Control Register 1
//	0x0B0 32  IPCMD         IP Command Register
//	0x0B8 32  IPRXFCR       IP RX FIFO Control Register
//	0x0BC 32  IPTXFCR       IP TX FIFO Control Register
//	0x0C0 32  DLLCR[2]      DLL Control Register 0
//	0x0E0 32  STS0          Status Register 0
//	0x0E4 32  STS1          Status Register 1
//	0x0E8 32  STS2          Status Register 2
//	0x0EC 32  AHBSPNDSTS    AHB Suspend Status Register
//	0x0F0 32  IPRXFSTS      IP RX FIFO Status Register
//	0x0F4 32  IPTXFSTS      IP TX FIFO Status Register
//	0x100 32  RFDR[32]      IP RX FIFO Data Register 0
//	0x180 32  TFDR[32]      IP TX FIFO Data Register 0
//	0x200 32  LUT[64]       LUT 0
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package flexspi

const (
	SWRESET       MCR0 = 0x01 << 0  //+ Software Reset
	MDIS          MCR0 = 0x01 << 1  //+ Module Disable
	RXCLKSRC      MCR0 = 0x03 << 4  //+ Sample Clock source selection for Flash Reading
	RXCLKSRC_0    MCR0 = 0x00 << 4  //  Dummy Read strobe generated by FlexSPI Controller and loopback internally.
	RXCLKSRC_1    MCR0 = 0x01 << 4  //  Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
	RXCLKSRC_3    MCR0 = 0x03 << 4  //  Flash provided Read strobe and input from DQS pad
	ARDFEN        MCR0 = 0x01 << 6  //+ Enable AHB bus Read Access to IP RX FIFO.
	ATDFEN        MCR0 = 0x01 << 7  //+ Enable AHB bus Write Access to IP TX FIFO.
	HSEN          MCR0 = 0x01 << 11 //+ Half Speed Serial Flash access Enable.
	DOZEEN        MCR0 = 0x01 << 12 //+ Doze mode enable bit
	COMBINATIONEN MCR0 = 0x01 << 13 //+ This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA[3:0] and SIOB[3:0]).
	SCKFREERUNEN  MCR0 = 0x01 << 14 //+ This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2).
	IPGRANTWAIT   MCR0 = 0xFF << 16 //+ Time out wait cycle for IP command grant.
	AHBGRANTWAIT  MCR0 = 0xFF << 24 //+ Timeout wait cycle for AHB command grant.
)

const (
	SWRESETn       = 0
	MDISn          = 1
	RXCLKSRCn      = 4
	ARDFENn        = 6
	ATDFENn        = 7
	HSENn          = 11
	DOZEENn        = 12
	COMBINATIONENn = 13
	SCKFREERUNENn  = 14
	IPGRANTWAITn   = 16
	AHBGRANTWAITn  = 24
)

const (
	AHBBUSWAIT MCR1 = 0xFFFF << 0  //+ AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmited after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
	SEQWAIT    MCR1 = 0xFFFF << 16 //+ Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
)

const (
	AHBBUSWAITn = 0
	SEQWAITn    = 16
)

const (
	CLRAHBBUFOPT  MCR2 = 0x01 << 11 //+ This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
	CLRLEARNPHASE MCR2 = 0x01 << 14 //+ The sampling clock phase selection will be reset to phase 0 when this bit is written with 0x1. This bit will be auto-cleared immediately.
	SAMEDEVICEEN  MCR2 = 0x01 << 15 //+ All external devices are same devices (both in types and size) for A1/A2/B1/B2.
	SCKBDIFFOPT   MCR2 = 0x01 << 19 //+ SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA). In this case, port B flash access is not available. After change the value of this feild, MCR0[SWRESET] should be set.
	RESUMEWAIT    MCR2 = 0xFF << 24 //+ Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
)

const (
	CLRAHBBUFOPTn  = 11
	CLRLEARNPHASEn = 14
	SAMEDEVICEENn  = 15
	SCKBDIFFOPTn   = 19
	RESUMEWAITn    = 24
)

const (
	APAREN       AHBCR = 0x01 << 0 //+ Parallel mode enabled for AHB triggered Command (both read and write) .
	CACHABLEEN   AHBCR = 0x01 << 3 //+ Enable AHB bus cachable read access support.
	BUFFERABLEEN AHBCR = 0x01 << 4 //+ Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
	PREFETCHEN   AHBCR = 0x01 << 5 //+ AHB Read Prefetch Enable.
	READADDROPT  AHBCR = 0x01 << 6 //+ AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
)

const (
	APARENn       = 0
	CACHABLEENn   = 3
	BUFFERABLEENn = 4
	PREFETCHENn   = 5
	READADDROPTn  = 6
)

const (
	IPCMDDONEEN     INTEN = 0x01 << 0  //+ IP triggered Command Sequences Execution finished interrupt enable.
	IPCMDGEEN       INTEN = 0x01 << 1  //+ IP triggered Command Sequences Grant Timeout interrupt enable.
	AHBCMDGEEN      INTEN = 0x01 << 2  //+ AHB triggered Command Sequences Grant Timeout interrupt enable.
	IPCMDERREN      INTEN = 0x01 << 3  //+ IP triggered Command Sequences Error Detected interrupt enable.
	AHBCMDERREN     INTEN = 0x01 << 4  //+ AHB triggered Command Sequences Error Detected interrupt enable.
	IPRXWAEN        INTEN = 0x01 << 5  //+ IP RX FIFO WaterMark available interrupt enable.
	IPTXWEEN        INTEN = 0x01 << 6  //+ IP TX FIFO WaterMark empty interrupt enable.
	SCKSTOPBYRDEN   INTEN = 0x01 << 8  //+ SCK is stopped during command sequence because Async RX FIFO full interrupt enable.
	SCKSTOPBYWREN   INTEN = 0x01 << 9  //+ SCK is stopped during command sequence because Async TX FIFO empty interrupt enable.
	AHBBUSTIMEOUTEN INTEN = 0x01 << 10 //+ AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
	SEQTIMEOUTEN    INTEN = 0x01 << 11 //+ Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
)

const (
	IPCMDDONEENn     = 0
	IPCMDGEENn       = 1
	AHBCMDGEENn      = 2
	IPCMDERRENn      = 3
	AHBCMDERRENn     = 4
	IPRXWAENn        = 5
	IPTXWEENn        = 6
	SCKSTOPBYRDENn   = 8
	SCKSTOPBYWRENn   = 9
	AHBBUSTIMEOUTENn = 10
	SEQTIMEOUTENn    = 11
)

const (
	IPCMDDONE     INTR = 0x01 << 0  //+ IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
	IPCMDGE       INTR = 0x01 << 1  //+ IP triggered Command Sequences Grant Timeout interrupt.
	AHBCMDGE      INTR = 0x01 << 2  //+ AHB triggered Command Sequences Grant Timeout interrupt.
	IPCMDERR      INTR = 0x01 << 3  //+ IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
	AHBCMDERR     INTR = 0x01 << 4  //+ AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
	IPRXWA        INTR = 0x01 << 5  //+ IP RX FIFO watermark available interrupt.
	IPTXWE        INTR = 0x01 << 6  //+ IP TX FIFO watermark empty interrupt.
	SCKSTOPBYRD   INTR = 0x01 << 8  //+ SCK is stopped during command sequence because Async RX FIFO full interrupt.
	SCKSTOPBYWR   INTR = 0x01 << 9  //+ SCK is stopped during command sequence because Async TX FIFO empty interrupt.
	AHBBUSTIMEOUT INTR = 0x01 << 10 //+ AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
	SEQTIMEOUT    INTR = 0x01 << 11 //+ Sequence execution timeout interrupt.
)

const (
	IPCMDDONEn     = 0
	IPCMDGEn       = 1
	AHBCMDGEn      = 2
	IPCMDERRn      = 3
	AHBCMDERRn     = 4
	IPRXWAn        = 5
	IPTXWEn        = 6
	SCKSTOPBYRDn   = 8
	SCKSTOPBYWRn   = 9
	AHBBUSTIMEOUTn = 10
	SEQTIMEOUTn    = 11
)

const (
	KEY LUTKEY = 0xFFFFFFFF << 0 //+ The Key to lock or unlock LUT.
)

const (
	KEYn = 0
)

const (
	LOCK   LUTCR = 0x01 << 0 //+ Lock LUT
	UNLOCK LUTCR = 0x01 << 1 //+ Unlock LUT
)

const (
	LOCKn   = 0
	UNLOCKn = 1
)

const (
	BUFSZ      AHBRXBUF0CR0 = 0xFF << 0  //+ AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
	MSTRID     AHBRXBUF0CR0 = 0x0F << 16 //+ This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
	PRIORITY   AHBRXBUF0CR0 = 0x03 << 24 //+ This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
	PREFETCHEN AHBRXBUF0CR0 = 0x01 << 31 //+ AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
)

const (
	BUFSZn      = 0
	MSTRIDn     = 16
	PRIORITYn   = 24
	PREFETCHENn = 31
)

const (
	BUFSZ      AHBRXBUF1CR0 = 0xFF << 0  //+ AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
	MSTRID     AHBRXBUF1CR0 = 0x0F << 16 //+ This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
	PRIORITY   AHBRXBUF1CR0 = 0x03 << 24 //+ This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
	PREFETCHEN AHBRXBUF1CR0 = 0x01 << 31 //+ AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
)

const (
	BUFSZn      = 0
	MSTRIDn     = 16
	PRIORITYn   = 24
	PREFETCHENn = 31
)

const (
	BUFSZ      AHBRXBUF2CR0 = 0xFF << 0  //+ AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
	MSTRID     AHBRXBUF2CR0 = 0x0F << 16 //+ This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
	PRIORITY   AHBRXBUF2CR0 = 0x03 << 24 //+ This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
	PREFETCHEN AHBRXBUF2CR0 = 0x01 << 31 //+ AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
)

const (
	BUFSZn      = 0
	MSTRIDn     = 16
	PRIORITYn   = 24
	PREFETCHENn = 31
)

const (
	BUFSZ      AHBRXBUF3CR0 = 0xFF << 0  //+ AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
	MSTRID     AHBRXBUF3CR0 = 0x0F << 16 //+ This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
	PRIORITY   AHBRXBUF3CR0 = 0x03 << 24 //+ This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
	PREFETCHEN AHBRXBUF3CR0 = 0x01 << 31 //+ AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
)

const (
	BUFSZn      = 0
	MSTRIDn     = 16
	PRIORITYn   = 24
	PREFETCHENn = 31
)

const (
	FLSHSZ FLSHA1CR0 = 0x7FFFFF << 0 //+ Flash Size in KByte.
)

const (
	FLSHSZn = 0
)

const (
	FLSHSZ FLSHA2CR0 = 0x7FFFFF << 0 //+ Flash Size in KByte.
)

const (
	FLSHSZn = 0
)

const (
	FLSHSZ FLSHB1CR0 = 0x7FFFFF << 0 //+ Flash Size in KByte.
)

const (
	FLSHSZn = 0
)

const (
	FLSHSZ FLSHB2CR0 = 0x7FFFFF << 0 //+ Flash Size in KByte.
)

const (
	FLSHSZn = 0
)

const (
	TCSS           FLSHCR1 = 0x1F << 0    //+ Serial Flash CS setup time.
	TCSH           FLSHCR1 = 0x1F << 5    //+ Serial Flash CS Hold time.
	WA             FLSHCR1 = 0x01 << 10   //+ Word Addressable.
	CAS            FLSHCR1 = 0x0F << 11   //+ Column Address Size.
	CSINTERVALUNIT FLSHCR1 = 0x01 << 15   //+ CS interval unit
	CSINTERVAL     FLSHCR1 = 0xFFFF << 16 //+ This field is used to set the minimum interval between flash device Chip selection deassertion and flash device Chip selection assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.
)

const (
	TCSSn           = 0
	TCSHn           = 5
	WAn             = 10
	CASn            = 11
	CSINTERVALUNITn = 15
	CSINTERVALn     = 16
)

const (
	ARDSEQID      FLSHCR2 = 0x0F << 0   //+ Sequence Index for AHB Read triggered Command in LUT.
	ARDSEQNUM     FLSHCR2 = 0x07 << 5   //+ Sequence Number for AHB Read triggered Command in LUT.
	AWRSEQID      FLSHCR2 = 0x0F << 8   //+ Sequence Index for AHB Write triggered Command.
	AWRSEQNUM     FLSHCR2 = 0x07 << 13  //+ Sequence Number for AHB Write triggered Command.
	AWRWAIT       FLSHCR2 = 0xFFF << 16 //+ For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface
	AWRWAITUNIT   FLSHCR2 = 0x07 << 28  //+ AWRWAIT unit
	AWRWAITUNIT_0 FLSHCR2 = 0x00 << 28  //  The AWRWAIT unit is 2 ahb clock cycle
	AWRWAITUNIT_1 FLSHCR2 = 0x01 << 28  //  The AWRWAIT unit is 8 ahb clock cycle
	AWRWAITUNIT_2 FLSHCR2 = 0x02 << 28  //  The AWRWAIT unit is 32 ahb clock cycle
	AWRWAITUNIT_3 FLSHCR2 = 0x03 << 28  //  The AWRWAIT unit is 128 ahb clock cycle
	AWRWAITUNIT_4 FLSHCR2 = 0x04 << 28  //  The AWRWAIT unit is 512 ahb clock cycle
	AWRWAITUNIT_5 FLSHCR2 = 0x05 << 28  //  The AWRWAIT unit is 2048 ahb clock cycle
	AWRWAITUNIT_6 FLSHCR2 = 0x06 << 28  //  The AWRWAIT unit is 8192 ahb clock cycle
	AWRWAITUNIT_7 FLSHCR2 = 0x07 << 28  //  The AWRWAIT unit is 32768 ahb clock cycle
	CLRINSTRPTR   FLSHCR2 = 0x01 << 31  //+ Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer Programmable Sequence Engine for details.
)

const (
	ARDSEQIDn    = 0
	ARDSEQNUMn   = 5
	AWRSEQIDn    = 8
	AWRSEQNUMn   = 13
	AWRWAITn     = 16
	AWRWAITUNITn = 28
	CLRINSTRPTRn = 31
)

const (
	WMOPT1 FLSHCR4 = 0x01 << 0 //+ Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
	WMENA  FLSHCR4 = 0x01 << 2 //+ Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
	WMENB  FLSHCR4 = 0x01 << 3 //+ Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
)

const (
	WMOPT1n = 0
	WMENAn  = 2
	WMENBn  = 3
)

const (
	SFAR IPCR0 = 0xFFFFFFFF << 0 //+ Serial Flash Address for IP command.
)

const (
	SFARn = 0
)

const (
	IDATSZ  IPCR1 = 0xFFFF << 0 //+ Flash Read/Program Data Size (in Bytes) for IP command.
	ISEQID  IPCR1 = 0x0F << 16  //+ Sequence Index in LUT for IP command.
	ISEQNUM IPCR1 = 0x07 << 24  //+ Sequence Number for IP command: ISEQNUM+1.
	IPAREN  IPCR1 = 0x01 << 31  //+ Parallel mode Enabled for IP command.
)

const (
	IDATSZn  = 0
	ISEQIDn  = 16
	ISEQNUMn = 24
	IPARENn  = 31
)

const (
	TRG IPCMD = 0x01 << 0 //+ Setting this bit will trigger an IP Command.
)

const (
	TRGn = 0
)

const (
	CLRIPRXF IPRXFCR = 0x01 << 0 //+ Clear all valid data entries in IP RX FIFO.
	RXDMAEN  IPRXFCR = 0x01 << 1 //+ IP RX FIFO reading by DMA enabled.
	RXWMRK   IPRXFCR = 0x0F << 2 //+ Watermark level is (RXWMRK+1)*64 Bits.
)

const (
	CLRIPRXFn = 0
	RXDMAENn  = 1
	RXWMRKn   = 2
)

const (
	CLRIPTXF IPTXFCR = 0x01 << 0 //+ Clear all valid data entries in IP TX FIFO.
	TXDMAEN  IPTXFCR = 0x01 << 1 //+ IP TX FIFO filling by DMA enabled.
	TXWMRK   IPTXFCR = 0x0F << 2 //+ Watermark level is (TXWMRK+1)*64 Bits.
)

const (
	CLRIPTXFn = 0
	TXDMAENn  = 1
	TXWMRKn   = 2
)

const (
	DLLEN        DLLCR = 0x01 << 0 //+ DLL calibration enable.
	DLLRESET     DLLCR = 0x01 << 1 //+ Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
	SLVDLYTARGET DLLCR = 0x0F << 3 //+ The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial clock).
	OVRDEN       DLLCR = 0x01 << 8 //+ Slave clock delay line delay cell number selection override enable.
	OVRDVAL      DLLCR = 0x3F << 9 //+ Slave clock delay line delay cell number selection override value.
)

const (
	DLLENn        = 0
	DLLRESETn     = 1
	SLVDLYTARGETn = 3
	OVRDENn       = 8
	OVRDVALn      = 9
)

const (
	SEQIDLE     STS0 = 0x01 << 0 //+ This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
	ARBIDLE     STS0 = 0x01 << 1 //+ This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
	ARBCMDSRC   STS0 = 0x03 << 2 //+ This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
	ARBCMDSRC_0 STS0 = 0x00 << 2 //  Triggered by AHB read command (triggered by AHB read).
	ARBCMDSRC_1 STS0 = 0x01 << 2 //  Triggered by AHB write command (triggered by AHB Write).
	ARBCMDSRC_2 STS0 = 0x02 << 2 //  Triggered by IP command (triggered by setting register bit IPCMD.TRG).
	ARBCMDSRC_3 STS0 = 0x03 << 2 //  Triggered by suspended command (resumed).
)

const (
	SEQIDLEn   = 0
	ARBIDLEn   = 1
	ARBCMDSRCn = 2
)

const (
	AHBCMDERRID      STS1 = 0x0F << 0  //+ Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
	AHBCMDERRCODE    STS1 = 0x0F << 8  //+ Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
	AHBCMDERRCODE_0  STS1 = 0x00 << 8  //  No error.
	AHBCMDERRCODE_2  STS1 = 0x02 << 8  //  AHB Write command with JMP_ON_CS instruction used in the sequence.
	AHBCMDERRCODE_3  STS1 = 0x03 << 8  //  There is unknown instruction opcode in the sequence.
	AHBCMDERRCODE_4  STS1 = 0x04 << 8  //  Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	AHBCMDERRCODE_5  STS1 = 0x05 << 8  //  Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	AHBCMDERRCODE_14 STS1 = 0x0E << 8  //  Sequence execution timeout.
	IPCMDERRID       STS1 = 0x0F << 16 //+ Indicates the sequence Index when IP command error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
	IPCMDERRCODE     STS1 = 0x0F << 24 //+ Indicates the Error Code when IP command Error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
	IPCMDERRCODE_0   STS1 = 0x00 << 24 //  No error.
	IPCMDERRCODE_2   STS1 = 0x02 << 24 //  IP command with JMP_ON_CS instruction used in the sequence.
	IPCMDERRCODE_3   STS1 = 0x03 << 24 //  There is unknown instruction opcode in the sequence.
	IPCMDERRCODE_4   STS1 = 0x04 << 24 //  Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	IPCMDERRCODE_5   STS1 = 0x05 << 24 //  Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	IPCMDERRCODE_6   STS1 = 0x06 << 24 //  Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
	IPCMDERRCODE_14  STS1 = 0x0E << 24 //  Sequence execution timeout.
	IPCMDERRCODE_15  STS1 = 0x0F << 24 //  Flash boundary crossed.
)

const (
	AHBCMDERRIDn   = 0
	AHBCMDERRCODEn = 8
	IPCMDERRIDn    = 16
	IPCMDERRCODEn  = 24
)

const (
	ASLVLOCK STS2 = 0x01 << 0  //+ Flash A sample clock slave delay line locked.
	AREFLOCK STS2 = 0x01 << 1  //+ Flash A sample clock reference delay line locked.
	ASLVSEL  STS2 = 0x3F << 2  //+ Flash A sample clock slave delay line delay cell number selection .
	AREFSEL  STS2 = 0x3F << 8  //+ Flash A sample clock reference delay line delay cell number selection.
	BSLVLOCK STS2 = 0x01 << 16 //+ Flash B sample clock slave delay line locked.
	BREFLOCK STS2 = 0x01 << 17 //+ Flash B sample clock reference delay line locked.
	BSLVSEL  STS2 = 0x3F << 18 //+ Flash B sample clock slave delay line delay cell number selection.
	BREFSEL  STS2 = 0x3F << 24 //+ Flash B sample clock reference delay line delay cell number selection.
)

const (
	ASLVLOCKn = 0
	AREFLOCKn = 1
	ASLVSELn  = 2
	AREFSELn  = 8
	BSLVLOCKn = 16
	BREFLOCKn = 17
	BSLVSELn  = 18
	BREFSELn  = 24
)

const (
	ACTIVE AHBSPNDSTS = 0x01 << 0    //+ Indicates if an AHB read prefetch command sequence has been suspended.
	BUFID  AHBSPNDSTS = 0x07 << 1    //+ AHB RX BUF ID for suspended command sequence.
	DATLFT AHBSPNDSTS = 0xFFFF << 16 //+ Left Data size for suspended command sequence (in byte).
)

const (
	ACTIVEn = 0
	BUFIDn  = 1
	DATLFTn = 16
)

const (
	FILL   IPRXFSTS = 0xFF << 0    //+ Fill level of IP RX FIFO.
	RDCNTR IPRXFSTS = 0xFFFF << 16 //+ Total Read Data Counter: RDCNTR * 64 Bits.
)

const (
	FILLn   = 0
	RDCNTRn = 16
)

const (
	FILL   IPTXFSTS = 0xFF << 0    //+ Fill level of IP TX FIFO.
	WRCNTR IPTXFSTS = 0xFFFF << 16 //+ Total Write Data Counter: WRCNTR * 64 Bits.
)

const (
	FILLn   = 0
	WRCNTRn = 16
)

const (
	RXDATA RFDR = 0xFFFFFFFF << 0 //+ RX Data
)

const (
	RXDATAn = 0
)

const (
	TXDATA TFDR = 0xFFFFFFFF << 0 //+ TX Data
)

const (
	TXDATAn = 0
)

const (
	OPERAND0  LUT = 0xFF << 0  //+ OPERAND0
	NUM_PADS0 LUT = 0x03 << 8  //+ NUM_PADS0
	OPCODE0   LUT = 0x3F << 10 //+ OPCODE
	OPERAND1  LUT = 0xFF << 16 //+ OPERAND1
	NUM_PADS1 LUT = 0x03 << 24 //+ NUM_PADS1
	OPCODE1   LUT = 0x3F << 26 //+ OPCODE1
)

const (
	OPERAND0n  = 0
	NUM_PADS0n = 8
	OPCODE0n   = 10
	OPERAND1n  = 16
	NUM_PADS1n = 24
	OPCODE1n   = 26
)
