// Code generated by xgen -g; DO NOT EDIT.

//go:build imxrt1060

package lpspi

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	VERID mmio.R32[VERID]
	PARAM mmio.R32[PARAM]
	_     [2]uint32
	CR    mmio.R32[CR]
	SR    mmio.R32[SR]
	IER   mmio.R32[IER]
	DER   mmio.R32[DER]
	CFGR0 mmio.R32[CFGR0]
	CFGR1 mmio.R32[CFGR1]
	_     [2]uint32
	DMR0  mmio.R32[uint32]
	DMR1  mmio.R32[uint32]
	_     [2]uint32
	CCR   mmio.R32[CCR]
	_     [5]uint32
	FCR   mmio.R32[FCR]
	FSR   mmio.R32[FSR]
	TCR   mmio.R32[TCR]
	TDR   mmio.R32[uint32]
	_     [2]uint32
	RSR   mmio.R32[RSR]
	RDR   mmio.R32[uint32]
}

func LPSPI1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.LPSPI1_BASE))) }
func LPSPI2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.LPSPI2_BASE))) }
func LPSPI3() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.LPSPI3_BASE))) }
func LPSPI4() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.LPSPI4_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type VERID uint32

func FEATURE_(p *Periph) mmio.RM32[VERID] { return mmio.RM32[VERID]{R: &p.VERID, Mask: FEATURE} }
func MINOR_(p *Periph) mmio.RM32[VERID]   { return mmio.RM32[VERID]{R: &p.VERID, Mask: MINOR} }
func MAJOR_(p *Periph) mmio.RM32[VERID]   { return mmio.RM32[VERID]{R: &p.VERID, Mask: MAJOR} }

type PARAM uint32

func TXFIFO_(p *Periph) mmio.RM32[PARAM] { return mmio.RM32[PARAM]{R: &p.PARAM, Mask: TXFIFO} }
func RXFIFO_(p *Periph) mmio.RM32[PARAM] { return mmio.RM32[PARAM]{R: &p.PARAM, Mask: RXFIFO} }
func PCSNUM_(p *Periph) mmio.RM32[PARAM] { return mmio.RM32[PARAM]{R: &p.PARAM, Mask: PCSNUM} }

type CR uint32

func MEN_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: MEN} }
func RST_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: RST} }
func DOZEN_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: DOZEN} }
func DBGEN_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: DBGEN} }
func RTF_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: RTF} }
func RRF_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: RRF} }

type SR uint32

func TDF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: TDF} }
func RDF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: RDF} }
func WCF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: WCF} }
func FCF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: FCF} }
func TCF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: TCF} }
func TEF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: TEF} }
func REF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: REF} }
func DMF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: DMF} }
func MBF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: MBF} }

type IER uint32

func TDIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: TDIE} }
func RDIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: RDIE} }
func WCIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: WCIE} }
func FCIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: FCIE} }
func TCIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: TCIE} }
func TEIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: TEIE} }
func REIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: REIE} }
func DMIE_(p *Periph) mmio.RM32[IER] { return mmio.RM32[IER]{R: &p.IER, Mask: DMIE} }

type DER uint32

func TDDE_(p *Periph) mmio.RM32[DER] { return mmio.RM32[DER]{R: &p.DER, Mask: TDDE} }
func RDDE_(p *Periph) mmio.RM32[DER] { return mmio.RM32[DER]{R: &p.DER, Mask: RDDE} }

type CFGR0 uint32

func HREN_(p *Periph) mmio.RM32[CFGR0]    { return mmio.RM32[CFGR0]{R: &p.CFGR0, Mask: HREN} }
func HRPOL_(p *Periph) mmio.RM32[CFGR0]   { return mmio.RM32[CFGR0]{R: &p.CFGR0, Mask: HRPOL} }
func HRSEL_(p *Periph) mmio.RM32[CFGR0]   { return mmio.RM32[CFGR0]{R: &p.CFGR0, Mask: HRSEL} }
func CIRFIFO_(p *Periph) mmio.RM32[CFGR0] { return mmio.RM32[CFGR0]{R: &p.CFGR0, Mask: CIRFIFO} }
func RDMO_(p *Periph) mmio.RM32[CFGR0]    { return mmio.RM32[CFGR0]{R: &p.CFGR0, Mask: RDMO} }

type CFGR1 uint32

func MASTER_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: MASTER} }
func SAMPLE_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: SAMPLE} }
func AUTOPCS_(p *Periph) mmio.RM32[CFGR1] { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: AUTOPCS} }
func NOSTALL_(p *Periph) mmio.RM32[CFGR1] { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: NOSTALL} }
func PCSPOL_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: PCSPOL} }
func MATCFG_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: MATCFG} }
func PINCFG_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: PINCFG} }
func OUTCFG_(p *Periph) mmio.RM32[CFGR1]  { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: OUTCFG} }
func PCSDATA_(p *Periph) mmio.RM32[CFGR1] { return mmio.RM32[CFGR1]{R: &p.CFGR1, Mask: PCSDATA} }

type CCR uint32

func SCKDIV_(p *Periph) mmio.RM32[CCR] { return mmio.RM32[CCR]{R: &p.CCR, Mask: SCKDIV} }
func DBT_(p *Periph) mmio.RM32[CCR]    { return mmio.RM32[CCR]{R: &p.CCR, Mask: DBT} }
func PCSSCK_(p *Periph) mmio.RM32[CCR] { return mmio.RM32[CCR]{R: &p.CCR, Mask: PCSSCK} }
func SCKPCS_(p *Periph) mmio.RM32[CCR] { return mmio.RM32[CCR]{R: &p.CCR, Mask: SCKPCS} }

type FCR uint32

func TXWATER_(p *Periph) mmio.RM32[FCR] { return mmio.RM32[FCR]{R: &p.FCR, Mask: TXWATER} }
func RXWATER_(p *Periph) mmio.RM32[FCR] { return mmio.RM32[FCR]{R: &p.FCR, Mask: RXWATER} }

type FSR uint32

func TXCOUNT_(p *Periph) mmio.RM32[FSR] { return mmio.RM32[FSR]{R: &p.FSR, Mask: TXCOUNT} }
func RXCOUNT_(p *Periph) mmio.RM32[FSR] { return mmio.RM32[FSR]{R: &p.FSR, Mask: RXCOUNT} }

type TCR uint32

func FRAMESZ_(p *Periph) mmio.RM32[TCR]  { return mmio.RM32[TCR]{R: &p.TCR, Mask: FRAMESZ} }
func WIDTH_(p *Periph) mmio.RM32[TCR]    { return mmio.RM32[TCR]{R: &p.TCR, Mask: WIDTH} }
func TXMSK_(p *Periph) mmio.RM32[TCR]    { return mmio.RM32[TCR]{R: &p.TCR, Mask: TXMSK} }
func RXMSK_(p *Periph) mmio.RM32[TCR]    { return mmio.RM32[TCR]{R: &p.TCR, Mask: RXMSK} }
func CONTC_(p *Periph) mmio.RM32[TCR]    { return mmio.RM32[TCR]{R: &p.TCR, Mask: CONTC} }
func CONT_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: CONT} }
func BYSW_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: BYSW} }
func LSBF_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: LSBF} }
func TPCS_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: TPCS} }
func PRESCALE_(p *Periph) mmio.RM32[TCR] { return mmio.RM32[TCR]{R: &p.TCR, Mask: PRESCALE} }
func CPHA_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: CPHA} }
func CPOL_(p *Periph) mmio.RM32[TCR]     { return mmio.RM32[TCR]{R: &p.TCR, Mask: CPOL} }

type RSR uint32

func SOF_(p *Periph) mmio.RM32[RSR]     { return mmio.RM32[RSR]{R: &p.RSR, Mask: SOF} }
func RXEMPTY_(p *Periph) mmio.RM32[RSR] { return mmio.RM32[RSR]{R: &p.RSR, Mask: RXEMPTY} }
