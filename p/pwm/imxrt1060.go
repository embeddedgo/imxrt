// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package pwm provides access to the registers of the PWM peripheral.
//
// Instances:
//  PWM1  PWM1_BASE  -  PWM1_0*,PWM1_1*,PWM1_2*,PWM1_3*,PWM1_FAULT*
//  PWM2  PWM2_BASE  -  PWM2_0*,PWM2_1*,PWM2_2*,PWM2_3*,PWM2_FAULT*
//  PWM3  PWM3_BASE  -  PWM3_0*,PWM3_1*,PWM3_2*,PWM3_3*,PWM3_FAULT*
//  PWM4  PWM4_BASE  -  PWM4_0*,PWM4_1*,PWM4_2*,PWM4_3*,PWM4_FAULT*
// Registers:
//  0x000 16  SM0CNT        Counter Register
//  0x002 16  SM0INIT       Initial Count Register
//  0x004 16  SM0CTRL2      Control 2 Register
//  0x006 16  SM0CTRL       Control Register
//  0x00A 16  SM0VAL0       Value Register 0
//  0x00C 16  SM0FRACVAL1   Fractional Value Register 1
//  0x00E 16  SM0VAL1       Value Register 1
//  0x010 16  SM0FRACVAL2   Fractional Value Register 2
//  0x012 16  SM0VAL2       Value Register 2
//  0x014 16  SM0FRACVAL3   Fractional Value Register 3
//  0x016 16  SM0VAL3       Value Register 3
//  0x018 16  SM0FRACVAL4   Fractional Value Register 4
//  0x01A 16  SM0VAL4       Value Register 4
//  0x01C 16  SM0FRACVAL5   Fractional Value Register 5
//  0x01E 16  SM0VAL5       Value Register 5
//  0x020 16  SM0FRCTRL     Fractional Control Register
//  0x022 16  SM0OCTRL      Output Control Register
//  0x024 16  SM0STS        Status Register
//  0x026 16  SM0INTEN      Interrupt Enable Register
//  0x028 16  SM0DMAEN      DMA Enable Register
//  0x02A 16  SM0TCTRL      Output Trigger Control Register
//  0x02C 16  SM0DISMAP0    Fault Disable Mapping Register 0
//  0x02E 16  SM0DISMAP1    Fault Disable Mapping Register 1
//  0x030 16  SM0DTCNT0     Deadtime Count Register 0
//  0x032 16  SM0DTCNT1     Deadtime Count Register 1
//  0x034 16  SM0CAPTCTRLA  Capture Control A Register
//  0x036 16  SM0CAPTCOMPA  Capture Compare A Register
//  0x038 16  SM0CAPTCTRLB  Capture Control B Register
//  0x03A 16  SM0CAPTCOMPB  Capture Compare B Register
//  0x03C 16  SM0CAPTCTRLX  Capture Control X Register
//  0x03E 16  SM0CAPTCOMPX  Capture Compare X Register
//  0x040 16  SM0CVAL0      Capture Value 0 Register
//  0x042 16  SM0CVAL0CYC   Capture Value 0 Cycle Register
//  0x044 16  SM0CVAL1      Capture Value 1 Register
//  0x046 16  SM0CVAL1CYC   Capture Value 1 Cycle Register
//  0x048 16  SM0CVAL2      Capture Value 2 Register
//  0x04A 16  SM0CVAL2CYC   Capture Value 2 Cycle Register
//  0x04C 16  SM0CVAL3      Capture Value 3 Register
//  0x04E 16  SM0CVAL3CYC   Capture Value 3 Cycle Register
//  0x050 16  SM0CVAL4      Capture Value 4 Register
//  0x052 16  SM0CVAL4CYC   Capture Value 4 Cycle Register
//  0x054 16  SM0CVAL5      Capture Value 5 Register
//  0x056 16  SM0CVAL5CYC   Capture Value 5 Cycle Register
//  0x060 16  SM1CNT        Counter Register
//  0x062 16  SM1INIT       Initial Count Register
//  0x064 16  SM1CTRL2      Control 2 Register
//  0x066 16  SM1CTRL       Control Register
//  0x06A 16  SM1VAL0       Value Register 0
//  0x06C 16  SM1FRACVAL1   Fractional Value Register 1
//  0x06E 16  SM1VAL1       Value Register 1
//  0x070 16  SM1FRACVAL2   Fractional Value Register 2
//  0x072 16  SM1VAL2       Value Register 2
//  0x074 16  SM1FRACVAL3   Fractional Value Register 3
//  0x076 16  SM1VAL3       Value Register 3
//  0x078 16  SM1FRACVAL4   Fractional Value Register 4
//  0x07A 16  SM1VAL4       Value Register 4
//  0x07C 16  SM1FRACVAL5   Fractional Value Register 5
//  0x07E 16  SM1VAL5       Value Register 5
//  0x080 16  SM1FRCTRL     Fractional Control Register
//  0x082 16  SM1OCTRL      Output Control Register
//  0x084 16  SM1STS        Status Register
//  0x086 16  SM1INTEN      Interrupt Enable Register
//  0x088 16  SM1DMAEN      DMA Enable Register
//  0x08A 16  SM1TCTRL      Output Trigger Control Register
//  0x08C 16  SM1DISMAP0    Fault Disable Mapping Register 0
//  0x08E 16  SM1DISMAP1    Fault Disable Mapping Register 1
//  0x090 16  SM1DTCNT0     Deadtime Count Register 0
//  0x092 16  SM1DTCNT1     Deadtime Count Register 1
//  0x094 16  SM1CAPTCTRLA  Capture Control A Register
//  0x096 16  SM1CAPTCOMPA  Capture Compare A Register
//  0x098 16  SM1CAPTCTRLB  Capture Control B Register
//  0x09A 16  SM1CAPTCOMPB  Capture Compare B Register
//  0x09C 16  SM1CAPTCTRLX  Capture Control X Register
//  0x09E 16  SM1CAPTCOMPX  Capture Compare X Register
//  0x0A0 16  SM1CVAL0      Capture Value 0 Register
//  0x0A2 16  SM1CVAL0CYC   Capture Value 0 Cycle Register
//  0x0A4 16  SM1CVAL1      Capture Value 1 Register
//  0x0A6 16  SM1CVAL1CYC   Capture Value 1 Cycle Register
//  0x0A8 16  SM1CVAL2      Capture Value 2 Register
//  0x0AA 16  SM1CVAL2CYC   Capture Value 2 Cycle Register
//  0x0AC 16  SM1CVAL3      Capture Value 3 Register
//  0x0AE 16  SM1CVAL3CYC   Capture Value 3 Cycle Register
//  0x0B0 16  SM1CVAL4      Capture Value 4 Register
//  0x0B2 16  SM1CVAL4CYC   Capture Value 4 Cycle Register
//  0x0B4 16  SM1CVAL5      Capture Value 5 Register
//  0x0B6 16  SM1CVAL5CYC   Capture Value 5 Cycle Register
//  0x0C0 16  SM2CNT        Counter Register
//  0x0C2 16  SM2INIT       Initial Count Register
//  0x0C4 16  SM2CTRL2      Control 2 Register
//  0x0C6 16  SM2CTRL       Control Register
//  0x0CA 16  SM2VAL0       Value Register 0
//  0x0CC 16  SM2FRACVAL1   Fractional Value Register 1
//  0x0CE 16  SM2VAL1       Value Register 1
//  0x0D0 16  SM2FRACVAL2   Fractional Value Register 2
//  0x0D2 16  SM2VAL2       Value Register 2
//  0x0D4 16  SM2FRACVAL3   Fractional Value Register 3
//  0x0D6 16  SM2VAL3       Value Register 3
//  0x0D8 16  SM2FRACVAL4   Fractional Value Register 4
//  0x0DA 16  SM2VAL4       Value Register 4
//  0x0DC 16  SM2FRACVAL5   Fractional Value Register 5
//  0x0DE 16  SM2VAL5       Value Register 5
//  0x0E0 16  SM2FRCTRL     Fractional Control Register
//  0x0E2 16  SM2OCTRL      Output Control Register
//  0x0E4 16  SM2STS        Status Register
//  0x0E6 16  SM2INTEN      Interrupt Enable Register
//  0x0E8 16  SM2DMAEN      DMA Enable Register
//  0x0EA 16  SM2TCTRL      Output Trigger Control Register
//  0x0EC 16  SM2DISMAP0    Fault Disable Mapping Register 0
//  0x0EE 16  SM2DISMAP1    Fault Disable Mapping Register 1
//  0x0F0 16  SM2DTCNT0     Deadtime Count Register 0
//  0x0F2 16  SM2DTCNT1     Deadtime Count Register 1
//  0x0F4 16  SM2CAPTCTRLA  Capture Control A Register
//  0x0F6 16  SM2CAPTCOMPA  Capture Compare A Register
//  0x0F8 16  SM2CAPTCTRLB  Capture Control B Register
//  0x0FA 16  SM2CAPTCOMPB  Capture Compare B Register
//  0x0FC 16  SM2CAPTCTRLX  Capture Control X Register
//  0x0FE 16  SM2CAPTCOMPX  Capture Compare X Register
//  0x100 16  SM2CVAL0      Capture Value 0 Register
//  0x102 16  SM2CVAL0CYC   Capture Value 0 Cycle Register
//  0x104 16  SM2CVAL1      Capture Value 1 Register
//  0x106 16  SM2CVAL1CYC   Capture Value 1 Cycle Register
//  0x108 16  SM2CVAL2      Capture Value 2 Register
//  0x10A 16  SM2CVAL2CYC   Capture Value 2 Cycle Register
//  0x10C 16  SM2CVAL3      Capture Value 3 Register
//  0x10E 16  SM2CVAL3CYC   Capture Value 3 Cycle Register
//  0x110 16  SM2CVAL4      Capture Value 4 Register
//  0x112 16  SM2CVAL4CYC   Capture Value 4 Cycle Register
//  0x114 16  SM2CVAL5      Capture Value 5 Register
//  0x116 16  SM2CVAL5CYC   Capture Value 5 Cycle Register
//  0x120 16  SM3CNT        Counter Register
//  0x122 16  SM3INIT       Initial Count Register
//  0x124 16  SM3CTRL2      Control 2 Register
//  0x126 16  SM3CTRL       Control Register
//  0x12A 16  SM3VAL0       Value Register 0
//  0x12C 16  SM3FRACVAL1   Fractional Value Register 1
//  0x12E 16  SM3VAL1       Value Register 1
//  0x130 16  SM3FRACVAL2   Fractional Value Register 2
//  0x132 16  SM3VAL2       Value Register 2
//  0x134 16  SM3FRACVAL3   Fractional Value Register 3
//  0x136 16  SM3VAL3       Value Register 3
//  0x138 16  SM3FRACVAL4   Fractional Value Register 4
//  0x13A 16  SM3VAL4       Value Register 4
//  0x13C 16  SM3FRACVAL5   Fractional Value Register 5
//  0x13E 16  SM3VAL5       Value Register 5
//  0x140 16  SM3FRCTRL     Fractional Control Register
//  0x142 16  SM3OCTRL      Output Control Register
//  0x144 16  SM3STS        Status Register
//  0x146 16  SM3INTEN      Interrupt Enable Register
//  0x148 16  SM3DMAEN      DMA Enable Register
//  0x14A 16  SM3TCTRL      Output Trigger Control Register
//  0x14C 16  SM3DISMAP0    Fault Disable Mapping Register 0
//  0x14E 16  SM3DISMAP1    Fault Disable Mapping Register 1
//  0x150 16  SM3DTCNT0     Deadtime Count Register 0
//  0x152 16  SM3DTCNT1     Deadtime Count Register 1
//  0x154 16  SM3CAPTCTRLA  Capture Control A Register
//  0x156 16  SM3CAPTCOMPA  Capture Compare A Register
//  0x158 16  SM3CAPTCTRLB  Capture Control B Register
//  0x15A 16  SM3CAPTCOMPB  Capture Compare B Register
//  0x15C 16  SM3CAPTCTRLX  Capture Control X Register
//  0x15E 16  SM3CAPTCOMPX  Capture Compare X Register
//  0x160 16  SM3CVAL0      Capture Value 0 Register
//  0x162 16  SM3CVAL0CYC   Capture Value 0 Cycle Register
//  0x164 16  SM3CVAL1      Capture Value 1 Register
//  0x166 16  SM3CVAL1CYC   Capture Value 1 Cycle Register
//  0x168 16  SM3CVAL2      Capture Value 2 Register
//  0x16A 16  SM3CVAL2CYC   Capture Value 2 Cycle Register
//  0x16C 16  SM3CVAL3      Capture Value 3 Register
//  0x16E 16  SM3CVAL3CYC   Capture Value 3 Cycle Register
//  0x170 16  SM3CVAL4      Capture Value 4 Register
//  0x172 16  SM3CVAL4CYC   Capture Value 4 Cycle Register
//  0x174 16  SM3CVAL5      Capture Value 5 Register
//  0x176 16  SM3CVAL5CYC   Capture Value 5 Cycle Register
//  0x180 16  OUTEN         Output Enable Register
//  0x182 16  MASK          Mask Register
//  0x184 16  SWCOUT        Software Controlled Output Register
//  0x186 16  DTSRCSEL      PWM Source Select Register
//  0x188 16  MCTRL         Master Control Register
//  0x18A 16  MCTRL2        Master Control 2 Register
//  0x18C 16  FCTRL0        Fault Control Register
//  0x18E 16  FSTS0         Fault Status Register
//  0x190 16  FFILT0        Fault Filter Register
//  0x192 16  FTST0         Fault Test Register
//  0x194 16  FCTRL20       Fault Control 2 Register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package pwm

const (
	CNT SM0CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM0INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL      SM0CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0    SM0CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1    SM0CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2    SM0CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL   SM0CTRL2 = 0x01 << 2  //+ Reload Source Select
	RELOAD_SEL_0 SM0CTRL2 = 0x00 << 2  //  The local RELOAD signal is used to reload registers.
	RELOAD_SEL_1 SM0CTRL2 = 0x01 << 2  //  The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	FORCE_SEL    SM0CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0  SM0CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1  SM0CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2  SM0CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3  SM0CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4  SM0CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5  SM0CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6  SM0CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7  SM0CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE        SM0CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN        SM0CTRL2 = 0x01 << 7  //+ FRCEN
	FRCEN_0      SM0CTRL2 = 0x00 << 7  //  Initialization from a FORCE_OUT is disabled.
	FRCEN_1      SM0CTRL2 = 0x01 << 7  //  Initialization from a FORCE_OUT is enabled.
	INIT_SEL     SM0CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0   SM0CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1   SM0CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2   SM0CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3   SM0CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT    SM0CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT   SM0CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT   SM0CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP        SM0CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	INDEP_0      SM0CTRL2 = 0x00 << 13 //  PWM_A and PWM_B form a complementary PWM pair.
	INDEP_1      SM0CTRL2 = 0x01 << 13 //  PWM_A and PWM_B outputs are independent PWMs.
	WAITEN       SM0CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN        SM0CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN      SM0CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLEN_0    SM0CTRL = 0x00 << 0  //  Double switching disabled.
	DBLEN_1    SM0CTRL = 0x01 << 0  //  Double switching enabled.
	DBLX       SM0CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	DBLX_0     SM0CTRL = 0x00 << 1  //  PWMX double pulse disabled.
	DBLX_1     SM0CTRL = 0x01 << 1  //  PWMX double pulse enabled.
	LDMOD      SM0CTRL = 0x01 << 2  //+ Load Mode Select
	LDMOD_0    SM0CTRL = 0x00 << 2  //  Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	LDMOD_1    SM0CTRL = 0x01 << 2  //  Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	SPLIT      SM0CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	SPLIT_0    SM0CTRL = 0x00 << 3  //  DBLPWM is not split. PWMA and PWMB each have double pulses.
	SPLIT_1    SM0CTRL = 0x01 << 3  //  DBLPWM is split to PWMA and PWMB.
	PRSC       SM0CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0     SM0CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1     SM0CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2     SM0CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3     SM0CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4     SM0CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5     SM0CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6     SM0CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7     SM0CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE   SM0CTRL = 0x01 << 7  //+ Compare Mode
	COMPMODE_0 SM0CTRL = 0x00 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	COMPMODE_1 SM0CTRL = 0x01 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	DT         SM0CTRL = 0x03 << 8  //+ Deadtime
	FULL       SM0CTRL = 0x01 << 10 //+ Full Cycle Reload
	FULL_0     SM0CTRL = 0x00 << 10 //  Full-cycle reloads disabled.
	FULL_1     SM0CTRL = 0x01 << 10 //  Full-cycle reloads enabled.
	HALF       SM0CTRL = 0x01 << 11 //+ Half Cycle Reload
	HALF_0     SM0CTRL = 0x00 << 11 //  Half-cycle reloads disabled.
	HALF_1     SM0CTRL = 0x01 << 11 //  Half-cycle reloads enabled.
	LDFQ       SM0CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0     SM0CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1     SM0CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2     SM0CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3     SM0CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4     SM0CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5     SM0CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6     SM0CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7     SM0CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8     SM0CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9     SM0CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10    SM0CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11    SM0CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12    SM0CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13    SM0CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14    SM0CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15    SM0CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM0VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM0FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM0VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM0FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM0VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM0FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM0VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM0FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM0VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM0FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM0VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN    SM0FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC1_EN_0  SM0FRCTRL = 0x00 << 1  //  Disable fractional cycle length for the PWM period.
	FRAC1_EN_1  SM0FRCTRL = 0x01 << 1  //  Enable fractional cycle length for the PWM period.
	FRAC23_EN   SM0FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC23_EN_0 SM0FRCTRL = 0x00 << 2  //  Disable fractional cycle placement for PWM_A.
	FRAC23_EN_1 SM0FRCTRL = 0x01 << 2  //  Enable fractional cycle placement for PWM_A.
	FRAC45_EN   SM0FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC45_EN_0 SM0FRCTRL = 0x00 << 4  //  Disable fractional cycle placement for PWM_B.
	FRAC45_EN_1 SM0FRCTRL = 0x01 << 4  //  Enable fractional cycle placement for PWM_B.
	FRAC_PU     SM0FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	FRAC_PU_0   SM0FRCTRL = 0x00 << 8  //  Turn off fractional delay logic.
	FRAC_PU_1   SM0FRCTRL = 0x01 << 8  //  Power up fractional delay logic.
	TEST        SM0FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM0OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM0OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM0OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM0OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM0OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM0OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM0OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM0OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM0OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM0OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM0OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM0OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM0OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM0OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM0OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM0OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLX_0   SM0OCTRL = 0x00 << 8  //  PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	POLX_1   SM0OCTRL = 0x01 << 8  //  PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	POLB     SM0OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLB_0   SM0OCTRL = 0x00 << 9  //  PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	POLB_1   SM0OCTRL = 0x01 << 9  //  PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	POLA     SM0OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	POLA_0   SM0OCTRL = 0x00 << 10 //  PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	POLA_1   SM0OCTRL = 0x01 << 10 //  PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWMX_IN  SM0OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM0OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM0OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM0STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM0STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM0STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM0STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM0STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM0STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM0STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM0STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM0STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM0STS = 0x01 << 12 //+ Reload Flag
	RF_0   SM0STS = 0x00 << 12 //  No new reload cycle since last STS[RF] clearing
	RF_1   SM0STS = 0x01 << 12 //  New reload cycle since last STS[RF] clearing
	REF    SM0STS = 0x01 << 13 //+ Reload Error Flag
	REF_0  SM0STS = 0x00 << 13 //  No reload error occurred.
	REF_1  SM0STS = 0x01 << 13 //  Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	RUF    SM0STS = 0x01 << 14 //+ Registers Updated Flag
	RUF_0  SM0STS = 0x00 << 14 //  No register update has occurred since last reload.
	RUF_1  SM0STS = 0x01 << 14 //  At least one of the double buffered registers has been updated since the last reload.
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM0INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM0INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM0INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM0INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX0IE_0 SM0INTEN = 0x00 << 6  //  Interrupt request disabled for STS[CFX0].
	CX0IE_1 SM0INTEN = 0x01 << 6  //  Interrupt request enabled for STS[CFX0].
	CX1IE   SM0INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CX1IE_0 SM0INTEN = 0x00 << 7  //  Interrupt request disabled for STS[CFX1].
	CX1IE_1 SM0INTEN = 0x01 << 7  //  Interrupt request enabled for STS[CFX1].
	CB0IE   SM0INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB0IE_0 SM0INTEN = 0x00 << 8  //  Interrupt request disabled for STS[CFB0].
	CB0IE_1 SM0INTEN = 0x01 << 8  //  Interrupt request enabled for STS[CFB0].
	CB1IE   SM0INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CB1IE_0 SM0INTEN = 0x00 << 9  //  Interrupt request disabled for STS[CFB1].
	CB1IE_1 SM0INTEN = 0x01 << 9  //  Interrupt request enabled for STS[CFB1].
	CA0IE   SM0INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA0IE_0 SM0INTEN = 0x00 << 10 //  Interrupt request disabled for STS[CFA0].
	CA0IE_1 SM0INTEN = 0x01 << 10 //  Interrupt request enabled for STS[CFA0].
	CA1IE   SM0INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	CA1IE_0 SM0INTEN = 0x00 << 11 //  Interrupt request disabled for STS[CFA1].
	CA1IE_1 SM0INTEN = 0x01 << 11 //  Interrupt request enabled for STS[CFA1].
	RIE     SM0INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	RIE_0   SM0INTEN = 0x00 << 12 //  STS[RF] CPU interrupt requests disabled
	RIE_1   SM0INTEN = 0x01 << 12 //  STS[RF] CPU interrupt requests enabled
	REIE    SM0INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
	REIE_0  SM0INTEN = 0x00 << 13 //  STS[REF] CPU interrupt requests disabled
	REIE_1  SM0INTEN = 0x01 << 13 //  STS[REF] CPU interrupt requests enabled
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM0DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM0DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM0DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM0DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM0DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM0DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM0DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM0DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM0DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM0DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM0DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM0DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	FAND_0   SM0DMAEN = 0x00 << 8 //  Selected FIFO watermarks are OR'ed together.
	FAND_1   SM0DMAEN = 0x01 << 8 //  Selected FIFO watermarks are AND'ed together.
	VALDE    SM0DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
	VALDE_0  SM0DMAEN = 0x00 << 9 //  DMA write requests disabled
	VALDE_1  SM0DMAEN = 0x01 << 9 //  DMA write requests for the VALx and FRACVALx registers enabled
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM0TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM0TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM0TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM0TCTRL = 0x01 << 12 //+ Trigger frequency
	TRGFRQ_0      SM0TCTRL = 0x00 << 12 //  Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	TRGFRQ_1      SM0TCTRL = 0x01 << 12 //  Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWBOT1        SM0TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWBOT1_0      SM0TCTRL = 0x00 << 14 //  Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWBOT1_1      SM0TCTRL = 0x01 << 14 //  Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWAOT0        SM0TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
	PWAOT0_0      SM0TCTRL = 0x00 << 15 //  Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWAOT0_1      SM0TCTRL = 0x01 << 15 //  Route the PWMA output to the PWM_OUT_TRIG0 port.
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM0DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM0DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM0DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM0DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM0DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM0DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM0DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM0DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA         SM0CAPTCTRLA = 0x01 << 0  //+ Arm A
	ARMA_0       SM0CAPTCTRLA = 0x00 << 0  //  Input capture operation is disabled.
	ARMA_1       SM0CAPTCTRLA = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	ONESHOTA     SM0CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	ONESHOTA_0   SM0CAPTCTRLA = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTA_1   SM0CAPTCTRLA = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	EDGA0        SM0CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0      SM0CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1      SM0CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2      SM0CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3      SM0CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1        SM0CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0      SM0CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1      SM0CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2      SM0CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3      SM0CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA     SM0CAPTCTRLA = 0x01 << 6  //+ Input Select A
	INP_SELA_0   SM0CAPTCTRLA = 0x00 << 6  //  Raw PWM_A input signal selected as source.
	INP_SELA_1   SM0CAPTCTRLA = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	EDGCNTA_EN   SM0CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	EDGCNTA_EN_0 SM0CAPTCTRLA = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTA_EN_1 SM0CAPTCTRLA = 0x01 << 7  //  Edge counter enabled
	CFAWM        SM0CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT       SM0CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT       SM0CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM0CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM0CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB         SM0CAPTCTRLB = 0x01 << 0  //+ Arm B
	ARMB_0       SM0CAPTCTRLB = 0x00 << 0  //  Input capture operation is disabled.
	ARMB_1       SM0CAPTCTRLB = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	ONESHOTB     SM0CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	ONESHOTB_0   SM0CAPTCTRLB = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTB_1   SM0CAPTCTRLB = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	EDGB0        SM0CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0      SM0CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1      SM0CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2      SM0CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3      SM0CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1        SM0CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0      SM0CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1      SM0CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2      SM0CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3      SM0CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB     SM0CAPTCTRLB = 0x01 << 6  //+ Input Select B
	INP_SELB_0   SM0CAPTCTRLB = 0x00 << 6  //  Raw PWM_B input signal selected as source.
	INP_SELB_1   SM0CAPTCTRLB = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	EDGCNTB_EN   SM0CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	EDGCNTB_EN_0 SM0CAPTCTRLB = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTB_EN_1 SM0CAPTCTRLB = 0x01 << 7  //  Edge counter enabled
	CFBWM        SM0CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT       SM0CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT       SM0CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM0CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM0CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX         SM0CAPTCTRLX = 0x01 << 0  //+ Arm X
	ARMX_0       SM0CAPTCTRLX = 0x00 << 0  //  Input capture operation is disabled.
	ARMX_1       SM0CAPTCTRLX = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	ONESHOTX     SM0CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	ONESHOTX_0   SM0CAPTCTRLX = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTX_1   SM0CAPTCTRLX = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	EDGX0        SM0CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0      SM0CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1      SM0CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2      SM0CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3      SM0CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1        SM0CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0      SM0CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1      SM0CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2      SM0CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3      SM0CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX     SM0CAPTCTRLX = 0x01 << 6  //+ Input Select X
	INP_SELX_0   SM0CAPTCTRLX = 0x00 << 6  //  Raw PWM_X input signal selected as source.
	INP_SELX_1   SM0CAPTCTRLX = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	EDGCNTX_EN   SM0CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	EDGCNTX_EN_0 SM0CAPTCTRLX = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTX_EN_1 SM0CAPTCTRLX = 0x01 << 7  //  Edge counter enabled
	CFXWM        SM0CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT       SM0CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT       SM0CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM0CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM0CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM0CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM0CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM0CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM0CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM0CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM0CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM0CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM0CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM0CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM0CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM0CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM0CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM1CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM1INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL      SM1CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0    SM1CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1    SM1CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2    SM1CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL   SM1CTRL2 = 0x01 << 2  //+ Reload Source Select
	RELOAD_SEL_0 SM1CTRL2 = 0x00 << 2  //  The local RELOAD signal is used to reload registers.
	RELOAD_SEL_1 SM1CTRL2 = 0x01 << 2  //  The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	FORCE_SEL    SM1CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0  SM1CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1  SM1CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2  SM1CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3  SM1CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4  SM1CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5  SM1CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6  SM1CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7  SM1CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE        SM1CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN        SM1CTRL2 = 0x01 << 7  //+ FRCEN
	FRCEN_0      SM1CTRL2 = 0x00 << 7  //  Initialization from a FORCE_OUT is disabled.
	FRCEN_1      SM1CTRL2 = 0x01 << 7  //  Initialization from a FORCE_OUT is enabled.
	INIT_SEL     SM1CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0   SM1CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1   SM1CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2   SM1CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3   SM1CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT    SM1CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT   SM1CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT   SM1CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP        SM1CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	INDEP_0      SM1CTRL2 = 0x00 << 13 //  PWM_A and PWM_B form a complementary PWM pair.
	INDEP_1      SM1CTRL2 = 0x01 << 13 //  PWM_A and PWM_B outputs are independent PWMs.
	WAITEN       SM1CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN        SM1CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN      SM1CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLEN_0    SM1CTRL = 0x00 << 0  //  Double switching disabled.
	DBLEN_1    SM1CTRL = 0x01 << 0  //  Double switching enabled.
	DBLX       SM1CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	DBLX_0     SM1CTRL = 0x00 << 1  //  PWMX double pulse disabled.
	DBLX_1     SM1CTRL = 0x01 << 1  //  PWMX double pulse enabled.
	LDMOD      SM1CTRL = 0x01 << 2  //+ Load Mode Select
	LDMOD_0    SM1CTRL = 0x00 << 2  //  Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	LDMOD_1    SM1CTRL = 0x01 << 2  //  Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	SPLIT      SM1CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	SPLIT_0    SM1CTRL = 0x00 << 3  //  DBLPWM is not split. PWMA and PWMB each have double pulses.
	SPLIT_1    SM1CTRL = 0x01 << 3  //  DBLPWM is split to PWMA and PWMB.
	PRSC       SM1CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0     SM1CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1     SM1CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2     SM1CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3     SM1CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4     SM1CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5     SM1CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6     SM1CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7     SM1CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE   SM1CTRL = 0x01 << 7  //+ Compare Mode
	COMPMODE_0 SM1CTRL = 0x00 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	COMPMODE_1 SM1CTRL = 0x01 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	DT         SM1CTRL = 0x03 << 8  //+ Deadtime
	FULL       SM1CTRL = 0x01 << 10 //+ Full Cycle Reload
	FULL_0     SM1CTRL = 0x00 << 10 //  Full-cycle reloads disabled.
	FULL_1     SM1CTRL = 0x01 << 10 //  Full-cycle reloads enabled.
	HALF       SM1CTRL = 0x01 << 11 //+ Half Cycle Reload
	HALF_0     SM1CTRL = 0x00 << 11 //  Half-cycle reloads disabled.
	HALF_1     SM1CTRL = 0x01 << 11 //  Half-cycle reloads enabled.
	LDFQ       SM1CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0     SM1CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1     SM1CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2     SM1CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3     SM1CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4     SM1CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5     SM1CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6     SM1CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7     SM1CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8     SM1CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9     SM1CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10    SM1CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11    SM1CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12    SM1CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13    SM1CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14    SM1CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15    SM1CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM1VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM1FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM1VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM1FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM1VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM1FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM1VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM1FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM1VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM1FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM1VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN    SM1FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC1_EN_0  SM1FRCTRL = 0x00 << 1  //  Disable fractional cycle length for the PWM period.
	FRAC1_EN_1  SM1FRCTRL = 0x01 << 1  //  Enable fractional cycle length for the PWM period.
	FRAC23_EN   SM1FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC23_EN_0 SM1FRCTRL = 0x00 << 2  //  Disable fractional cycle placement for PWM_A.
	FRAC23_EN_1 SM1FRCTRL = 0x01 << 2  //  Enable fractional cycle placement for PWM_A.
	FRAC45_EN   SM1FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC45_EN_0 SM1FRCTRL = 0x00 << 4  //  Disable fractional cycle placement for PWM_B.
	FRAC45_EN_1 SM1FRCTRL = 0x01 << 4  //  Enable fractional cycle placement for PWM_B.
	FRAC_PU     SM1FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	FRAC_PU_0   SM1FRCTRL = 0x00 << 8  //  Turn off fractional delay logic.
	FRAC_PU_1   SM1FRCTRL = 0x01 << 8  //  Power up fractional delay logic.
	TEST        SM1FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM1OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM1OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM1OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM1OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM1OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM1OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM1OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM1OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM1OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM1OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM1OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM1OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM1OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM1OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM1OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM1OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLX_0   SM1OCTRL = 0x00 << 8  //  PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	POLX_1   SM1OCTRL = 0x01 << 8  //  PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	POLB     SM1OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLB_0   SM1OCTRL = 0x00 << 9  //  PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	POLB_1   SM1OCTRL = 0x01 << 9  //  PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	POLA     SM1OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	POLA_0   SM1OCTRL = 0x00 << 10 //  PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	POLA_1   SM1OCTRL = 0x01 << 10 //  PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWMX_IN  SM1OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM1OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM1OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM1STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM1STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM1STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM1STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM1STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM1STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM1STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM1STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM1STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM1STS = 0x01 << 12 //+ Reload Flag
	RF_0   SM1STS = 0x00 << 12 //  No new reload cycle since last STS[RF] clearing
	RF_1   SM1STS = 0x01 << 12 //  New reload cycle since last STS[RF] clearing
	REF    SM1STS = 0x01 << 13 //+ Reload Error Flag
	REF_0  SM1STS = 0x00 << 13 //  No reload error occurred.
	REF_1  SM1STS = 0x01 << 13 //  Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	RUF    SM1STS = 0x01 << 14 //+ Registers Updated Flag
	RUF_0  SM1STS = 0x00 << 14 //  No register update has occurred since last reload.
	RUF_1  SM1STS = 0x01 << 14 //  At least one of the double buffered registers has been updated since the last reload.
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM1INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM1INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM1INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM1INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX0IE_0 SM1INTEN = 0x00 << 6  //  Interrupt request disabled for STS[CFX0].
	CX0IE_1 SM1INTEN = 0x01 << 6  //  Interrupt request enabled for STS[CFX0].
	CX1IE   SM1INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CX1IE_0 SM1INTEN = 0x00 << 7  //  Interrupt request disabled for STS[CFX1].
	CX1IE_1 SM1INTEN = 0x01 << 7  //  Interrupt request enabled for STS[CFX1].
	CB0IE   SM1INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB0IE_0 SM1INTEN = 0x00 << 8  //  Interrupt request disabled for STS[CFB0].
	CB0IE_1 SM1INTEN = 0x01 << 8  //  Interrupt request enabled for STS[CFB0].
	CB1IE   SM1INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CB1IE_0 SM1INTEN = 0x00 << 9  //  Interrupt request disabled for STS[CFB1].
	CB1IE_1 SM1INTEN = 0x01 << 9  //  Interrupt request enabled for STS[CFB1].
	CA0IE   SM1INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA0IE_0 SM1INTEN = 0x00 << 10 //  Interrupt request disabled for STS[CFA0].
	CA0IE_1 SM1INTEN = 0x01 << 10 //  Interrupt request enabled for STS[CFA0].
	CA1IE   SM1INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	CA1IE_0 SM1INTEN = 0x00 << 11 //  Interrupt request disabled for STS[CFA1].
	CA1IE_1 SM1INTEN = 0x01 << 11 //  Interrupt request enabled for STS[CFA1].
	RIE     SM1INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	RIE_0   SM1INTEN = 0x00 << 12 //  STS[RF] CPU interrupt requests disabled
	RIE_1   SM1INTEN = 0x01 << 12 //  STS[RF] CPU interrupt requests enabled
	REIE    SM1INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
	REIE_0  SM1INTEN = 0x00 << 13 //  STS[REF] CPU interrupt requests disabled
	REIE_1  SM1INTEN = 0x01 << 13 //  STS[REF] CPU interrupt requests enabled
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM1DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM1DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM1DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM1DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM1DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM1DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM1DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM1DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM1DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM1DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM1DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM1DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	FAND_0   SM1DMAEN = 0x00 << 8 //  Selected FIFO watermarks are OR'ed together.
	FAND_1   SM1DMAEN = 0x01 << 8 //  Selected FIFO watermarks are AND'ed together.
	VALDE    SM1DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
	VALDE_0  SM1DMAEN = 0x00 << 9 //  DMA write requests disabled
	VALDE_1  SM1DMAEN = 0x01 << 9 //  DMA write requests for the VALx and FRACVALx registers enabled
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM1TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM1TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM1TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM1TCTRL = 0x01 << 12 //+ Trigger frequency
	TRGFRQ_0      SM1TCTRL = 0x00 << 12 //  Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	TRGFRQ_1      SM1TCTRL = 0x01 << 12 //  Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWBOT1        SM1TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWBOT1_0      SM1TCTRL = 0x00 << 14 //  Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWBOT1_1      SM1TCTRL = 0x01 << 14 //  Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWAOT0        SM1TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
	PWAOT0_0      SM1TCTRL = 0x00 << 15 //  Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWAOT0_1      SM1TCTRL = 0x01 << 15 //  Route the PWMA output to the PWM_OUT_TRIG0 port.
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM1DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM1DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM1DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM1DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM1DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM1DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM1DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM1DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA         SM1CAPTCTRLA = 0x01 << 0  //+ Arm A
	ARMA_0       SM1CAPTCTRLA = 0x00 << 0  //  Input capture operation is disabled.
	ARMA_1       SM1CAPTCTRLA = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	ONESHOTA     SM1CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	ONESHOTA_0   SM1CAPTCTRLA = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTA_1   SM1CAPTCTRLA = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	EDGA0        SM1CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0      SM1CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1      SM1CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2      SM1CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3      SM1CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1        SM1CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0      SM1CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1      SM1CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2      SM1CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3      SM1CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA     SM1CAPTCTRLA = 0x01 << 6  //+ Input Select A
	INP_SELA_0   SM1CAPTCTRLA = 0x00 << 6  //  Raw PWM_A input signal selected as source.
	INP_SELA_1   SM1CAPTCTRLA = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	EDGCNTA_EN   SM1CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	EDGCNTA_EN_0 SM1CAPTCTRLA = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTA_EN_1 SM1CAPTCTRLA = 0x01 << 7  //  Edge counter enabled
	CFAWM        SM1CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT       SM1CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT       SM1CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM1CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM1CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB         SM1CAPTCTRLB = 0x01 << 0  //+ Arm B
	ARMB_0       SM1CAPTCTRLB = 0x00 << 0  //  Input capture operation is disabled.
	ARMB_1       SM1CAPTCTRLB = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	ONESHOTB     SM1CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	ONESHOTB_0   SM1CAPTCTRLB = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTB_1   SM1CAPTCTRLB = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	EDGB0        SM1CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0      SM1CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1      SM1CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2      SM1CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3      SM1CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1        SM1CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0      SM1CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1      SM1CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2      SM1CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3      SM1CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB     SM1CAPTCTRLB = 0x01 << 6  //+ Input Select B
	INP_SELB_0   SM1CAPTCTRLB = 0x00 << 6  //  Raw PWM_B input signal selected as source.
	INP_SELB_1   SM1CAPTCTRLB = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	EDGCNTB_EN   SM1CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	EDGCNTB_EN_0 SM1CAPTCTRLB = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTB_EN_1 SM1CAPTCTRLB = 0x01 << 7  //  Edge counter enabled
	CFBWM        SM1CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT       SM1CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT       SM1CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM1CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM1CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX         SM1CAPTCTRLX = 0x01 << 0  //+ Arm X
	ARMX_0       SM1CAPTCTRLX = 0x00 << 0  //  Input capture operation is disabled.
	ARMX_1       SM1CAPTCTRLX = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	ONESHOTX     SM1CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	ONESHOTX_0   SM1CAPTCTRLX = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTX_1   SM1CAPTCTRLX = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	EDGX0        SM1CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0      SM1CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1      SM1CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2      SM1CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3      SM1CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1        SM1CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0      SM1CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1      SM1CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2      SM1CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3      SM1CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX     SM1CAPTCTRLX = 0x01 << 6  //+ Input Select X
	INP_SELX_0   SM1CAPTCTRLX = 0x00 << 6  //  Raw PWM_X input signal selected as source.
	INP_SELX_1   SM1CAPTCTRLX = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	EDGCNTX_EN   SM1CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	EDGCNTX_EN_0 SM1CAPTCTRLX = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTX_EN_1 SM1CAPTCTRLX = 0x01 << 7  //  Edge counter enabled
	CFXWM        SM1CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT       SM1CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT       SM1CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM1CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM1CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM1CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM1CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM1CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM1CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM1CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM1CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM1CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM1CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM1CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM1CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM1CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM1CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM2CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM2INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL      SM2CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0    SM2CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1    SM2CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2    SM2CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL   SM2CTRL2 = 0x01 << 2  //+ Reload Source Select
	RELOAD_SEL_0 SM2CTRL2 = 0x00 << 2  //  The local RELOAD signal is used to reload registers.
	RELOAD_SEL_1 SM2CTRL2 = 0x01 << 2  //  The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	FORCE_SEL    SM2CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0  SM2CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1  SM2CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2  SM2CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3  SM2CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4  SM2CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5  SM2CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6  SM2CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7  SM2CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE        SM2CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN        SM2CTRL2 = 0x01 << 7  //+ FRCEN
	FRCEN_0      SM2CTRL2 = 0x00 << 7  //  Initialization from a FORCE_OUT is disabled.
	FRCEN_1      SM2CTRL2 = 0x01 << 7  //  Initialization from a FORCE_OUT is enabled.
	INIT_SEL     SM2CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0   SM2CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1   SM2CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2   SM2CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3   SM2CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT    SM2CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT   SM2CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT   SM2CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP        SM2CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	INDEP_0      SM2CTRL2 = 0x00 << 13 //  PWM_A and PWM_B form a complementary PWM pair.
	INDEP_1      SM2CTRL2 = 0x01 << 13 //  PWM_A and PWM_B outputs are independent PWMs.
	WAITEN       SM2CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN        SM2CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN      SM2CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLEN_0    SM2CTRL = 0x00 << 0  //  Double switching disabled.
	DBLEN_1    SM2CTRL = 0x01 << 0  //  Double switching enabled.
	DBLX       SM2CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	DBLX_0     SM2CTRL = 0x00 << 1  //  PWMX double pulse disabled.
	DBLX_1     SM2CTRL = 0x01 << 1  //  PWMX double pulse enabled.
	LDMOD      SM2CTRL = 0x01 << 2  //+ Load Mode Select
	LDMOD_0    SM2CTRL = 0x00 << 2  //  Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	LDMOD_1    SM2CTRL = 0x01 << 2  //  Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	SPLIT      SM2CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	SPLIT_0    SM2CTRL = 0x00 << 3  //  DBLPWM is not split. PWMA and PWMB each have double pulses.
	SPLIT_1    SM2CTRL = 0x01 << 3  //  DBLPWM is split to PWMA and PWMB.
	PRSC       SM2CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0     SM2CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1     SM2CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2     SM2CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3     SM2CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4     SM2CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5     SM2CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6     SM2CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7     SM2CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE   SM2CTRL = 0x01 << 7  //+ Compare Mode
	COMPMODE_0 SM2CTRL = 0x00 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	COMPMODE_1 SM2CTRL = 0x01 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	DT         SM2CTRL = 0x03 << 8  //+ Deadtime
	FULL       SM2CTRL = 0x01 << 10 //+ Full Cycle Reload
	FULL_0     SM2CTRL = 0x00 << 10 //  Full-cycle reloads disabled.
	FULL_1     SM2CTRL = 0x01 << 10 //  Full-cycle reloads enabled.
	HALF       SM2CTRL = 0x01 << 11 //+ Half Cycle Reload
	HALF_0     SM2CTRL = 0x00 << 11 //  Half-cycle reloads disabled.
	HALF_1     SM2CTRL = 0x01 << 11 //  Half-cycle reloads enabled.
	LDFQ       SM2CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0     SM2CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1     SM2CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2     SM2CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3     SM2CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4     SM2CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5     SM2CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6     SM2CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7     SM2CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8     SM2CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9     SM2CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10    SM2CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11    SM2CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12    SM2CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13    SM2CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14    SM2CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15    SM2CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM2VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM2FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM2VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM2FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM2VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM2FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM2VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM2FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM2VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM2FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM2VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN    SM2FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC1_EN_0  SM2FRCTRL = 0x00 << 1  //  Disable fractional cycle length for the PWM period.
	FRAC1_EN_1  SM2FRCTRL = 0x01 << 1  //  Enable fractional cycle length for the PWM period.
	FRAC23_EN   SM2FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC23_EN_0 SM2FRCTRL = 0x00 << 2  //  Disable fractional cycle placement for PWM_A.
	FRAC23_EN_1 SM2FRCTRL = 0x01 << 2  //  Enable fractional cycle placement for PWM_A.
	FRAC45_EN   SM2FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC45_EN_0 SM2FRCTRL = 0x00 << 4  //  Disable fractional cycle placement for PWM_B.
	FRAC45_EN_1 SM2FRCTRL = 0x01 << 4  //  Enable fractional cycle placement for PWM_B.
	FRAC_PU     SM2FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	FRAC_PU_0   SM2FRCTRL = 0x00 << 8  //  Turn off fractional delay logic.
	FRAC_PU_1   SM2FRCTRL = 0x01 << 8  //  Power up fractional delay logic.
	TEST        SM2FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM2OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM2OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM2OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM2OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM2OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM2OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM2OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM2OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM2OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM2OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM2OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM2OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM2OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM2OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM2OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM2OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLX_0   SM2OCTRL = 0x00 << 8  //  PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	POLX_1   SM2OCTRL = 0x01 << 8  //  PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	POLB     SM2OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLB_0   SM2OCTRL = 0x00 << 9  //  PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	POLB_1   SM2OCTRL = 0x01 << 9  //  PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	POLA     SM2OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	POLA_0   SM2OCTRL = 0x00 << 10 //  PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	POLA_1   SM2OCTRL = 0x01 << 10 //  PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWMX_IN  SM2OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM2OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM2OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM2STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM2STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM2STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM2STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM2STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM2STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM2STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM2STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM2STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM2STS = 0x01 << 12 //+ Reload Flag
	RF_0   SM2STS = 0x00 << 12 //  No new reload cycle since last STS[RF] clearing
	RF_1   SM2STS = 0x01 << 12 //  New reload cycle since last STS[RF] clearing
	REF    SM2STS = 0x01 << 13 //+ Reload Error Flag
	REF_0  SM2STS = 0x00 << 13 //  No reload error occurred.
	REF_1  SM2STS = 0x01 << 13 //  Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	RUF    SM2STS = 0x01 << 14 //+ Registers Updated Flag
	RUF_0  SM2STS = 0x00 << 14 //  No register update has occurred since last reload.
	RUF_1  SM2STS = 0x01 << 14 //  At least one of the double buffered registers has been updated since the last reload.
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM2INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM2INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM2INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM2INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX0IE_0 SM2INTEN = 0x00 << 6  //  Interrupt request disabled for STS[CFX0].
	CX0IE_1 SM2INTEN = 0x01 << 6  //  Interrupt request enabled for STS[CFX0].
	CX1IE   SM2INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CX1IE_0 SM2INTEN = 0x00 << 7  //  Interrupt request disabled for STS[CFX1].
	CX1IE_1 SM2INTEN = 0x01 << 7  //  Interrupt request enabled for STS[CFX1].
	CB0IE   SM2INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB0IE_0 SM2INTEN = 0x00 << 8  //  Interrupt request disabled for STS[CFB0].
	CB0IE_1 SM2INTEN = 0x01 << 8  //  Interrupt request enabled for STS[CFB0].
	CB1IE   SM2INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CB1IE_0 SM2INTEN = 0x00 << 9  //  Interrupt request disabled for STS[CFB1].
	CB1IE_1 SM2INTEN = 0x01 << 9  //  Interrupt request enabled for STS[CFB1].
	CA0IE   SM2INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA0IE_0 SM2INTEN = 0x00 << 10 //  Interrupt request disabled for STS[CFA0].
	CA0IE_1 SM2INTEN = 0x01 << 10 //  Interrupt request enabled for STS[CFA0].
	CA1IE   SM2INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	CA1IE_0 SM2INTEN = 0x00 << 11 //  Interrupt request disabled for STS[CFA1].
	CA1IE_1 SM2INTEN = 0x01 << 11 //  Interrupt request enabled for STS[CFA1].
	RIE     SM2INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	RIE_0   SM2INTEN = 0x00 << 12 //  STS[RF] CPU interrupt requests disabled
	RIE_1   SM2INTEN = 0x01 << 12 //  STS[RF] CPU interrupt requests enabled
	REIE    SM2INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
	REIE_0  SM2INTEN = 0x00 << 13 //  STS[REF] CPU interrupt requests disabled
	REIE_1  SM2INTEN = 0x01 << 13 //  STS[REF] CPU interrupt requests enabled
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM2DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM2DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM2DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM2DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM2DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM2DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM2DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM2DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM2DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM2DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM2DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM2DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	FAND_0   SM2DMAEN = 0x00 << 8 //  Selected FIFO watermarks are OR'ed together.
	FAND_1   SM2DMAEN = 0x01 << 8 //  Selected FIFO watermarks are AND'ed together.
	VALDE    SM2DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
	VALDE_0  SM2DMAEN = 0x00 << 9 //  DMA write requests disabled
	VALDE_1  SM2DMAEN = 0x01 << 9 //  DMA write requests for the VALx and FRACVALx registers enabled
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM2TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM2TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM2TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM2TCTRL = 0x01 << 12 //+ Trigger frequency
	TRGFRQ_0      SM2TCTRL = 0x00 << 12 //  Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	TRGFRQ_1      SM2TCTRL = 0x01 << 12 //  Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWBOT1        SM2TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWBOT1_0      SM2TCTRL = 0x00 << 14 //  Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWBOT1_1      SM2TCTRL = 0x01 << 14 //  Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWAOT0        SM2TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
	PWAOT0_0      SM2TCTRL = 0x00 << 15 //  Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWAOT0_1      SM2TCTRL = 0x01 << 15 //  Route the PWMA output to the PWM_OUT_TRIG0 port.
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM2DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM2DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM2DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM2DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM2DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM2DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM2DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM2DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA         SM2CAPTCTRLA = 0x01 << 0  //+ Arm A
	ARMA_0       SM2CAPTCTRLA = 0x00 << 0  //  Input capture operation is disabled.
	ARMA_1       SM2CAPTCTRLA = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	ONESHOTA     SM2CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	ONESHOTA_0   SM2CAPTCTRLA = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTA_1   SM2CAPTCTRLA = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	EDGA0        SM2CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0      SM2CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1      SM2CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2      SM2CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3      SM2CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1        SM2CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0      SM2CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1      SM2CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2      SM2CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3      SM2CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA     SM2CAPTCTRLA = 0x01 << 6  //+ Input Select A
	INP_SELA_0   SM2CAPTCTRLA = 0x00 << 6  //  Raw PWM_A input signal selected as source.
	INP_SELA_1   SM2CAPTCTRLA = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	EDGCNTA_EN   SM2CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	EDGCNTA_EN_0 SM2CAPTCTRLA = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTA_EN_1 SM2CAPTCTRLA = 0x01 << 7  //  Edge counter enabled
	CFAWM        SM2CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT       SM2CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT       SM2CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM2CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM2CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB         SM2CAPTCTRLB = 0x01 << 0  //+ Arm B
	ARMB_0       SM2CAPTCTRLB = 0x00 << 0  //  Input capture operation is disabled.
	ARMB_1       SM2CAPTCTRLB = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	ONESHOTB     SM2CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	ONESHOTB_0   SM2CAPTCTRLB = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTB_1   SM2CAPTCTRLB = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	EDGB0        SM2CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0      SM2CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1      SM2CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2      SM2CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3      SM2CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1        SM2CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0      SM2CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1      SM2CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2      SM2CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3      SM2CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB     SM2CAPTCTRLB = 0x01 << 6  //+ Input Select B
	INP_SELB_0   SM2CAPTCTRLB = 0x00 << 6  //  Raw PWM_B input signal selected as source.
	INP_SELB_1   SM2CAPTCTRLB = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	EDGCNTB_EN   SM2CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	EDGCNTB_EN_0 SM2CAPTCTRLB = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTB_EN_1 SM2CAPTCTRLB = 0x01 << 7  //  Edge counter enabled
	CFBWM        SM2CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT       SM2CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT       SM2CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM2CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM2CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX         SM2CAPTCTRLX = 0x01 << 0  //+ Arm X
	ARMX_0       SM2CAPTCTRLX = 0x00 << 0  //  Input capture operation is disabled.
	ARMX_1       SM2CAPTCTRLX = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	ONESHOTX     SM2CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	ONESHOTX_0   SM2CAPTCTRLX = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTX_1   SM2CAPTCTRLX = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	EDGX0        SM2CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0      SM2CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1      SM2CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2      SM2CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3      SM2CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1        SM2CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0      SM2CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1      SM2CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2      SM2CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3      SM2CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX     SM2CAPTCTRLX = 0x01 << 6  //+ Input Select X
	INP_SELX_0   SM2CAPTCTRLX = 0x00 << 6  //  Raw PWM_X input signal selected as source.
	INP_SELX_1   SM2CAPTCTRLX = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	EDGCNTX_EN   SM2CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	EDGCNTX_EN_0 SM2CAPTCTRLX = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTX_EN_1 SM2CAPTCTRLX = 0x01 << 7  //  Edge counter enabled
	CFXWM        SM2CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT       SM2CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT       SM2CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM2CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM2CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM2CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM2CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM2CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM2CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM2CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM2CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM2CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM2CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM2CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM2CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM2CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM2CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM3CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM3INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL      SM3CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0    SM3CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1    SM3CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2    SM3CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL   SM3CTRL2 = 0x01 << 2  //+ Reload Source Select
	RELOAD_SEL_0 SM3CTRL2 = 0x00 << 2  //  The local RELOAD signal is used to reload registers.
	RELOAD_SEL_1 SM3CTRL2 = 0x01 << 2  //  The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	FORCE_SEL    SM3CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0  SM3CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1  SM3CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2  SM3CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3  SM3CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4  SM3CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5  SM3CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6  SM3CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7  SM3CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE        SM3CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN        SM3CTRL2 = 0x01 << 7  //+ FRCEN
	FRCEN_0      SM3CTRL2 = 0x00 << 7  //  Initialization from a FORCE_OUT is disabled.
	FRCEN_1      SM3CTRL2 = 0x01 << 7  //  Initialization from a FORCE_OUT is enabled.
	INIT_SEL     SM3CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0   SM3CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1   SM3CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2   SM3CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3   SM3CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT    SM3CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT   SM3CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT   SM3CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP        SM3CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	INDEP_0      SM3CTRL2 = 0x00 << 13 //  PWM_A and PWM_B form a complementary PWM pair.
	INDEP_1      SM3CTRL2 = 0x01 << 13 //  PWM_A and PWM_B outputs are independent PWMs.
	WAITEN       SM3CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN        SM3CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN      SM3CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLEN_0    SM3CTRL = 0x00 << 0  //  Double switching disabled.
	DBLEN_1    SM3CTRL = 0x01 << 0  //  Double switching enabled.
	DBLX       SM3CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	DBLX_0     SM3CTRL = 0x00 << 1  //  PWMX double pulse disabled.
	DBLX_1     SM3CTRL = 0x01 << 1  //  PWMX double pulse enabled.
	LDMOD      SM3CTRL = 0x01 << 2  //+ Load Mode Select
	LDMOD_0    SM3CTRL = 0x00 << 2  //  Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	LDMOD_1    SM3CTRL = 0x01 << 2  //  Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	SPLIT      SM3CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	SPLIT_0    SM3CTRL = 0x00 << 3  //  DBLPWM is not split. PWMA and PWMB each have double pulses.
	SPLIT_1    SM3CTRL = 0x01 << 3  //  DBLPWM is split to PWMA and PWMB.
	PRSC       SM3CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0     SM3CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1     SM3CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2     SM3CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3     SM3CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4     SM3CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5     SM3CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6     SM3CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7     SM3CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE   SM3CTRL = 0x01 << 7  //+ Compare Mode
	COMPMODE_0 SM3CTRL = 0x00 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	COMPMODE_1 SM3CTRL = 0x01 << 7  //  The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	DT         SM3CTRL = 0x03 << 8  //+ Deadtime
	FULL       SM3CTRL = 0x01 << 10 //+ Full Cycle Reload
	FULL_0     SM3CTRL = 0x00 << 10 //  Full-cycle reloads disabled.
	FULL_1     SM3CTRL = 0x01 << 10 //  Full-cycle reloads enabled.
	HALF       SM3CTRL = 0x01 << 11 //+ Half Cycle Reload
	HALF_0     SM3CTRL = 0x00 << 11 //  Half-cycle reloads disabled.
	HALF_1     SM3CTRL = 0x01 << 11 //  Half-cycle reloads enabled.
	LDFQ       SM3CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0     SM3CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1     SM3CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2     SM3CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3     SM3CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4     SM3CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5     SM3CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6     SM3CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7     SM3CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8     SM3CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9     SM3CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10    SM3CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11    SM3CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12    SM3CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13    SM3CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14    SM3CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15    SM3CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM3VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM3FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM3VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM3FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM3VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM3FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM3VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM3FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM3VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM3FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM3VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN    SM3FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC1_EN_0  SM3FRCTRL = 0x00 << 1  //  Disable fractional cycle length for the PWM period.
	FRAC1_EN_1  SM3FRCTRL = 0x01 << 1  //  Enable fractional cycle length for the PWM period.
	FRAC23_EN   SM3FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC23_EN_0 SM3FRCTRL = 0x00 << 2  //  Disable fractional cycle placement for PWM_A.
	FRAC23_EN_1 SM3FRCTRL = 0x01 << 2  //  Enable fractional cycle placement for PWM_A.
	FRAC45_EN   SM3FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC45_EN_0 SM3FRCTRL = 0x00 << 4  //  Disable fractional cycle placement for PWM_B.
	FRAC45_EN_1 SM3FRCTRL = 0x01 << 4  //  Enable fractional cycle placement for PWM_B.
	FRAC_PU     SM3FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	FRAC_PU_0   SM3FRCTRL = 0x00 << 8  //  Turn off fractional delay logic.
	FRAC_PU_1   SM3FRCTRL = 0x01 << 8  //  Power up fractional delay logic.
	TEST        SM3FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM3OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM3OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM3OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM3OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM3OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM3OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM3OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM3OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM3OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM3OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM3OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM3OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM3OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM3OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM3OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM3OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLX_0   SM3OCTRL = 0x00 << 8  //  PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	POLX_1   SM3OCTRL = 0x01 << 8  //  PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	POLB     SM3OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLB_0   SM3OCTRL = 0x00 << 9  //  PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	POLB_1   SM3OCTRL = 0x01 << 9  //  PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	POLA     SM3OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	POLA_0   SM3OCTRL = 0x00 << 10 //  PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	POLA_1   SM3OCTRL = 0x01 << 10 //  PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWMX_IN  SM3OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM3OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM3OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM3STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM3STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM3STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM3STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM3STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM3STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM3STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM3STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM3STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM3STS = 0x01 << 12 //+ Reload Flag
	RF_0   SM3STS = 0x00 << 12 //  No new reload cycle since last STS[RF] clearing
	RF_1   SM3STS = 0x01 << 12 //  New reload cycle since last STS[RF] clearing
	REF    SM3STS = 0x01 << 13 //+ Reload Error Flag
	REF_0  SM3STS = 0x00 << 13 //  No reload error occurred.
	REF_1  SM3STS = 0x01 << 13 //  Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	RUF    SM3STS = 0x01 << 14 //+ Registers Updated Flag
	RUF_0  SM3STS = 0x00 << 14 //  No register update has occurred since last reload.
	RUF_1  SM3STS = 0x01 << 14 //  At least one of the double buffered registers has been updated since the last reload.
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM3INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM3INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM3INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM3INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX0IE_0 SM3INTEN = 0x00 << 6  //  Interrupt request disabled for STS[CFX0].
	CX0IE_1 SM3INTEN = 0x01 << 6  //  Interrupt request enabled for STS[CFX0].
	CX1IE   SM3INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CX1IE_0 SM3INTEN = 0x00 << 7  //  Interrupt request disabled for STS[CFX1].
	CX1IE_1 SM3INTEN = 0x01 << 7  //  Interrupt request enabled for STS[CFX1].
	CB0IE   SM3INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB0IE_0 SM3INTEN = 0x00 << 8  //  Interrupt request disabled for STS[CFB0].
	CB0IE_1 SM3INTEN = 0x01 << 8  //  Interrupt request enabled for STS[CFB0].
	CB1IE   SM3INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CB1IE_0 SM3INTEN = 0x00 << 9  //  Interrupt request disabled for STS[CFB1].
	CB1IE_1 SM3INTEN = 0x01 << 9  //  Interrupt request enabled for STS[CFB1].
	CA0IE   SM3INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA0IE_0 SM3INTEN = 0x00 << 10 //  Interrupt request disabled for STS[CFA0].
	CA0IE_1 SM3INTEN = 0x01 << 10 //  Interrupt request enabled for STS[CFA0].
	CA1IE   SM3INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	CA1IE_0 SM3INTEN = 0x00 << 11 //  Interrupt request disabled for STS[CFA1].
	CA1IE_1 SM3INTEN = 0x01 << 11 //  Interrupt request enabled for STS[CFA1].
	RIE     SM3INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	RIE_0   SM3INTEN = 0x00 << 12 //  STS[RF] CPU interrupt requests disabled
	RIE_1   SM3INTEN = 0x01 << 12 //  STS[RF] CPU interrupt requests enabled
	REIE    SM3INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
	REIE_0  SM3INTEN = 0x00 << 13 //  STS[REF] CPU interrupt requests disabled
	REIE_1  SM3INTEN = 0x01 << 13 //  STS[REF] CPU interrupt requests enabled
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM3DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM3DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM3DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM3DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM3DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM3DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM3DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM3DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM3DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM3DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM3DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM3DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	FAND_0   SM3DMAEN = 0x00 << 8 //  Selected FIFO watermarks are OR'ed together.
	FAND_1   SM3DMAEN = 0x01 << 8 //  Selected FIFO watermarks are AND'ed together.
	VALDE    SM3DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
	VALDE_0  SM3DMAEN = 0x00 << 9 //  DMA write requests disabled
	VALDE_1  SM3DMAEN = 0x01 << 9 //  DMA write requests for the VALx and FRACVALx registers enabled
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM3TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM3TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM3TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM3TCTRL = 0x01 << 12 //+ Trigger frequency
	TRGFRQ_0      SM3TCTRL = 0x00 << 12 //  Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	TRGFRQ_1      SM3TCTRL = 0x01 << 12 //  Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWBOT1        SM3TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWBOT1_0      SM3TCTRL = 0x00 << 14 //  Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWBOT1_1      SM3TCTRL = 0x01 << 14 //  Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWAOT0        SM3TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
	PWAOT0_0      SM3TCTRL = 0x00 << 15 //  Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWAOT0_1      SM3TCTRL = 0x01 << 15 //  Route the PWMA output to the PWM_OUT_TRIG0 port.
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM3DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM3DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM3DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM3DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM3DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM3DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM3DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM3DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA         SM3CAPTCTRLA = 0x01 << 0  //+ Arm A
	ARMA_0       SM3CAPTCTRLA = 0x00 << 0  //  Input capture operation is disabled.
	ARMA_1       SM3CAPTCTRLA = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	ONESHOTA     SM3CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	ONESHOTA_0   SM3CAPTCTRLA = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTA_1   SM3CAPTCTRLA = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	EDGA0        SM3CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0      SM3CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1      SM3CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2      SM3CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3      SM3CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1        SM3CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0      SM3CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1      SM3CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2      SM3CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3      SM3CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA     SM3CAPTCTRLA = 0x01 << 6  //+ Input Select A
	INP_SELA_0   SM3CAPTCTRLA = 0x00 << 6  //  Raw PWM_A input signal selected as source.
	INP_SELA_1   SM3CAPTCTRLA = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	EDGCNTA_EN   SM3CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	EDGCNTA_EN_0 SM3CAPTCTRLA = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTA_EN_1 SM3CAPTCTRLA = 0x01 << 7  //  Edge counter enabled
	CFAWM        SM3CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT       SM3CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT       SM3CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM3CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM3CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB         SM3CAPTCTRLB = 0x01 << 0  //+ Arm B
	ARMB_0       SM3CAPTCTRLB = 0x00 << 0  //  Input capture operation is disabled.
	ARMB_1       SM3CAPTCTRLB = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	ONESHOTB     SM3CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	ONESHOTB_0   SM3CAPTCTRLB = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTB_1   SM3CAPTCTRLB = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	EDGB0        SM3CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0      SM3CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1      SM3CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2      SM3CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3      SM3CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1        SM3CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0      SM3CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1      SM3CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2      SM3CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3      SM3CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB     SM3CAPTCTRLB = 0x01 << 6  //+ Input Select B
	INP_SELB_0   SM3CAPTCTRLB = 0x00 << 6  //  Raw PWM_B input signal selected as source.
	INP_SELB_1   SM3CAPTCTRLB = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	EDGCNTB_EN   SM3CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	EDGCNTB_EN_0 SM3CAPTCTRLB = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTB_EN_1 SM3CAPTCTRLB = 0x01 << 7  //  Edge counter enabled
	CFBWM        SM3CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT       SM3CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT       SM3CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM3CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM3CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX         SM3CAPTCTRLX = 0x01 << 0  //+ Arm X
	ARMX_0       SM3CAPTCTRLX = 0x00 << 0  //  Input capture operation is disabled.
	ARMX_1       SM3CAPTCTRLX = 0x01 << 0  //  Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	ONESHOTX     SM3CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	ONESHOTX_0   SM3CAPTCTRLX = 0x00 << 1  //  Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	ONESHOTX_1   SM3CAPTCTRLX = 0x01 << 1  //  One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	EDGX0        SM3CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0      SM3CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1      SM3CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2      SM3CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3      SM3CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1        SM3CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0      SM3CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1      SM3CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2      SM3CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3      SM3CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX     SM3CAPTCTRLX = 0x01 << 6  //+ Input Select X
	INP_SELX_0   SM3CAPTCTRLX = 0x00 << 6  //  Raw PWM_X input signal selected as source.
	INP_SELX_1   SM3CAPTCTRLX = 0x01 << 6  //  Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	EDGCNTX_EN   SM3CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	EDGCNTX_EN_0 SM3CAPTCTRLX = 0x00 << 7  //  Edge counter disabled and held in reset
	EDGCNTX_EN_1 SM3CAPTCTRLX = 0x01 << 7  //  Edge counter enabled
	CFXWM        SM3CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT       SM3CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT       SM3CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM3CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM3CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM3CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM3CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM3CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM3CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM3CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM3CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM3CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM3CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM3CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM3CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM3CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM3CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	PWMX_EN   OUTEN = 0x0F << 0 //+ PWM_X Output Enables
	PWMX_EN_0 OUTEN = 0x00 << 0 //  PWM_X output disabled.
	PWMX_EN_1 OUTEN = 0x01 << 0 //  PWM_X output enabled.
	PWMB_EN   OUTEN = 0x0F << 4 //+ PWM_B Output Enables
	PWMB_EN_0 OUTEN = 0x00 << 4 //  PWM_B output disabled.
	PWMB_EN_1 OUTEN = 0x01 << 4 //  PWM_B output enabled.
	PWMA_EN   OUTEN = 0x0F << 8 //+ PWM_A Output Enables
	PWMA_EN_0 OUTEN = 0x00 << 8 //  PWM_A output disabled.
	PWMA_EN_1 OUTEN = 0x01 << 8 //  PWM_A output enabled.
)

const (
	PWMX_ENn = 0
	PWMB_ENn = 4
	PWMA_ENn = 8
)

const (
	MASKX         MASK = 0x0F << 0  //+ PWM_X Masks
	MASKX_0       MASK = 0x00 << 0  //  PWM_X output normal.
	MASKX_1       MASK = 0x01 << 0  //  PWM_X output masked.
	MASKB         MASK = 0x0F << 4  //+ PWM_B Masks
	MASKB_0       MASK = 0x00 << 4  //  PWM_B output normal.
	MASKB_1       MASK = 0x01 << 4  //  PWM_B output masked.
	MASKA         MASK = 0x0F << 8  //+ PWM_A Masks
	MASKA_0       MASK = 0x00 << 8  //  PWM_A output normal.
	MASKA_1       MASK = 0x01 << 8  //  PWM_A output masked.
	UPDATE_MASK   MASK = 0x0F << 12 //+ Update Mask Bits Immediately
	UPDATE_MASK_0 MASK = 0x00 << 12 //  Normal operation. MASK* bits within the corresponding submodule are not updated until a FORCE_OUT event occurs within the submodule.
	UPDATE_MASK_1 MASK = 0x01 << 12 //  Immediate operation. MASK* bits within the corresponding submodule are updated on the following clock edge after setting this bit.
)

const (
	MASKXn       = 0
	MASKBn       = 4
	MASKAn       = 8
	UPDATE_MASKn = 12
)

const (
	SM0OUT45   SWCOUT = 0x01 << 0 //+ Submodule 0 Software Controlled Output 45
	SM0OUT45_0 SWCOUT = 0x00 << 0 //  A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	SM0OUT45_1 SWCOUT = 0x01 << 0 //  A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	SM0OUT23   SWCOUT = 0x01 << 1 //+ Submodule 0 Software Controlled Output 23
	SM0OUT23_0 SWCOUT = 0x00 << 1 //  A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	SM0OUT23_1 SWCOUT = 0x01 << 1 //  A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	SM1OUT45   SWCOUT = 0x01 << 2 //+ Submodule 1 Software Controlled Output 45
	SM1OUT45_0 SWCOUT = 0x00 << 2 //  A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	SM1OUT45_1 SWCOUT = 0x01 << 2 //  A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	SM1OUT23   SWCOUT = 0x01 << 3 //+ Submodule 1 Software Controlled Output 23
	SM1OUT23_0 SWCOUT = 0x00 << 3 //  A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	SM1OUT23_1 SWCOUT = 0x01 << 3 //  A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	SM2OUT45   SWCOUT = 0x01 << 4 //+ Submodule 2 Software Controlled Output 45
	SM2OUT45_0 SWCOUT = 0x00 << 4 //  A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	SM2OUT45_1 SWCOUT = 0x01 << 4 //  A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	SM2OUT23   SWCOUT = 0x01 << 5 //+ Submodule 2 Software Controlled Output 23
	SM2OUT23_0 SWCOUT = 0x00 << 5 //  A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	SM2OUT23_1 SWCOUT = 0x01 << 5 //  A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	SM3OUT45   SWCOUT = 0x01 << 6 //+ Submodule 3 Software Controlled Output 45
	SM3OUT45_0 SWCOUT = 0x00 << 6 //  A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	SM3OUT45_1 SWCOUT = 0x01 << 6 //  A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	SM3OUT23   SWCOUT = 0x01 << 7 //+ Submodule 3 Software Controlled Output 23
	SM3OUT23_0 SWCOUT = 0x00 << 7 //  A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM23.
	SM3OUT23_1 SWCOUT = 0x01 << 7 //  A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM23.
)

const (
	SM0OUT45n = 0
	SM0OUT23n = 1
	SM1OUT45n = 2
	SM1OUT23n = 3
	SM2OUT45n = 4
	SM2OUT23n = 5
	SM3OUT45n = 6
	SM3OUT23n = 7
)

const (
	SM0SEL45   DTSRCSEL = 0x03 << 0  //+ Submodule 0 PWM45 Control Select
	SM0SEL45_0 DTSRCSEL = 0x00 << 0  //  Generated SM0PWM45 signal is used by the deadtime logic.
	SM0SEL45_1 DTSRCSEL = 0x01 << 0  //  Inverted generated SM0PWM45 signal is used by the deadtime logic.
	SM0SEL45_2 DTSRCSEL = 0x02 << 0  //  SWCOUT[SM0OUT45] is used by the deadtime logic.
	SM0SEL45_3 DTSRCSEL = 0x03 << 0  //  PWM0_EXTB signal is used by the deadtime logic.
	SM0SEL23   DTSRCSEL = 0x03 << 2  //+ Submodule 0 PWM23 Control Select
	SM0SEL23_0 DTSRCSEL = 0x00 << 2  //  Generated SM0PWM23 signal is used by the deadtime logic.
	SM0SEL23_1 DTSRCSEL = 0x01 << 2  //  Inverted generated SM0PWM23 signal is used by the deadtime logic.
	SM0SEL23_2 DTSRCSEL = 0x02 << 2  //  SWCOUT[SM0OUT23] is used by the deadtime logic.
	SM0SEL23_3 DTSRCSEL = 0x03 << 2  //  PWM0_EXTA signal is used by the deadtime logic.
	SM1SEL45   DTSRCSEL = 0x03 << 4  //+ Submodule 1 PWM45 Control Select
	SM1SEL45_0 DTSRCSEL = 0x00 << 4  //  Generated SM1PWM45 signal is used by the deadtime logic.
	SM1SEL45_1 DTSRCSEL = 0x01 << 4  //  Inverted generated SM1PWM45 signal is used by the deadtime logic.
	SM1SEL45_2 DTSRCSEL = 0x02 << 4  //  SWCOUT[SM1OUT45] is used by the deadtime logic.
	SM1SEL45_3 DTSRCSEL = 0x03 << 4  //  PWM1_EXTB signal is used by the deadtime logic.
	SM1SEL23   DTSRCSEL = 0x03 << 6  //+ Submodule 1 PWM23 Control Select
	SM1SEL23_0 DTSRCSEL = 0x00 << 6  //  Generated SM1PWM23 signal is used by the deadtime logic.
	SM1SEL23_1 DTSRCSEL = 0x01 << 6  //  Inverted generated SM1PWM23 signal is used by the deadtime logic.
	SM1SEL23_2 DTSRCSEL = 0x02 << 6  //  SWCOUT[SM1OUT23] is used by the deadtime logic.
	SM1SEL23_3 DTSRCSEL = 0x03 << 6  //  PWM1_EXTA signal is used by the deadtime logic.
	SM2SEL45   DTSRCSEL = 0x03 << 8  //+ Submodule 2 PWM45 Control Select
	SM2SEL45_0 DTSRCSEL = 0x00 << 8  //  Generated SM2PWM45 signal is used by the deadtime logic.
	SM2SEL45_1 DTSRCSEL = 0x01 << 8  //  Inverted generated SM2PWM45 signal is used by the deadtime logic.
	SM2SEL45_2 DTSRCSEL = 0x02 << 8  //  SWCOUT[SM2OUT45] is used by the deadtime logic.
	SM2SEL45_3 DTSRCSEL = 0x03 << 8  //  PWM2_EXTB signal is used by the deadtime logic.
	SM2SEL23   DTSRCSEL = 0x03 << 10 //+ Submodule 2 PWM23 Control Select
	SM2SEL23_0 DTSRCSEL = 0x00 << 10 //  Generated SM2PWM23 signal is used by the deadtime logic.
	SM2SEL23_1 DTSRCSEL = 0x01 << 10 //  Inverted generated SM2PWM23 signal is used by the deadtime logic.
	SM2SEL23_2 DTSRCSEL = 0x02 << 10 //  SWCOUT[SM2OUT23] is used by the deadtime logic.
	SM2SEL23_3 DTSRCSEL = 0x03 << 10 //  PWM2_EXTA signal is used by the deadtime logic.
	SM3SEL45   DTSRCSEL = 0x03 << 12 //+ Submodule 3 PWM45 Control Select
	SM3SEL45_0 DTSRCSEL = 0x00 << 12 //  Generated SM3PWM45 signal is used by the deadtime logic.
	SM3SEL45_1 DTSRCSEL = 0x01 << 12 //  Inverted generated SM3PWM45 signal is used by the deadtime logic.
	SM3SEL45_2 DTSRCSEL = 0x02 << 12 //  SWCOUT[SM3OUT45] is used by the deadtime logic.
	SM3SEL45_3 DTSRCSEL = 0x03 << 12 //  PWM3_EXTB signal is used by the deadtime logic.
	SM3SEL23   DTSRCSEL = 0x03 << 14 //+ Submodule 3 PWM23 Control Select
	SM3SEL23_0 DTSRCSEL = 0x00 << 14 //  Generated SM3PWM23 signal is used by the deadtime logic.
	SM3SEL23_1 DTSRCSEL = 0x01 << 14 //  Inverted generated SM3PWM23 signal is used by the deadtime logic.
	SM3SEL23_2 DTSRCSEL = 0x02 << 14 //  SWCOUT[SM3OUT23] is used by the deadtime logic.
	SM3SEL23_3 DTSRCSEL = 0x03 << 14 //  PWM3_EXTA signal is used by the deadtime logic.
)

const (
	SM0SEL45n = 0
	SM0SEL23n = 2
	SM1SEL45n = 4
	SM1SEL23n = 6
	SM2SEL45n = 8
	SM2SEL23n = 10
	SM3SEL45n = 12
	SM3SEL23n = 14
)

const (
	LDOK   MCTRL = 0x0F << 0  //+ Load Okay
	LDOK_0 MCTRL = 0x00 << 0  //  Do not load new values.
	LDOK_1 MCTRL = 0x01 << 0  //  Load prescaler, modulus, and PWM values of the corresponding submodule.
	CLDOK  MCTRL = 0x0F << 4  //+ Clear Load Okay
	RUN    MCTRL = 0x0F << 8  //+ Run
	RUN_0  MCTRL = 0x00 << 8  //  PWM generator is disabled in the corresponding submodule.
	RUN_1  MCTRL = 0x01 << 8  //  PWM generator is enabled in the corresponding submodule.
	IPOL   MCTRL = 0x0F << 12 //+ Current Polarity
	IPOL_0 MCTRL = 0x00 << 12 //  PWM23 is used to generate complementary PWM pair in the corresponding submodule.
	IPOL_1 MCTRL = 0x01 << 12 //  PWM45 is used to generate complementary PWM pair in the corresponding submodule.
)

const (
	LDOKn  = 0
	CLDOKn = 4
	RUNn   = 8
	IPOLn  = 12
)

const (
	MONPLL   MCTRL2 = 0x03 << 0 //+ Monitor PLL State
	MONPLL_0 MCTRL2 = 0x00 << 0 //  Not locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software.
	MONPLL_1 MCTRL2 = 0x01 << 0 //  Not locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems.
	MONPLL_2 MCTRL2 = 0x02 << 0 //  Locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software. These bits are write protected until the next reset.
	MONPLL_3 MCTRL2 = 0x03 << 0 //  Locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems. These bits are write protected until the next reset.
)

const (
	MONPLLn = 0
)

const (
	FIE     FCTRL0 = 0x0F << 0  //+ Fault Interrupt Enables
	FIE_0   FCTRL0 = 0x00 << 0  //  FAULTx CPU interrupt requests disabled.
	FIE_1   FCTRL0 = 0x01 << 0  //  FAULTx CPU interrupt requests enabled.
	FSAFE   FCTRL0 = 0x0F << 4  //+ Fault Safety Mode
	FSAFE_0 FCTRL0 = 0x00 << 4  //  Normal mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFPINx]. The PWM outputs disabled by this fault input will not be re-enabled until the actual FAULTx input signal de-asserts since the fault input will combinationally disable the PWM outputs (as programmed in DISMAPn).
	FSAFE_1 FCTRL0 = 0x01 << 4  //  Safe mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL].
	FAUTO   FCTRL0 = 0x0F << 8  //+ Automatic Fault Clearing
	FAUTO_0 FCTRL0 = 0x00 << 8  //  Manual fault clearing. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending the state of FSTS[FFULL]. This is further controlled by FCTRL[FSAFE].
	FAUTO_1 FCTRL0 = 0x01 << 8  //  Automatic fault clearing. PWM outputs disabled by this fault are enabled when FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFLAGx].
	FLVL    FCTRL0 = 0x0F << 12 //+ Fault Level
	FLVL_0  FCTRL0 = 0x00 << 12 //  A logic 0 on the fault input indicates a fault condition.
	FLVL_1  FCTRL0 = 0x01 << 12 //  A logic 1 on the fault input indicates a fault condition.
)

const (
	FIEn   = 0
	FSAFEn = 4
	FAUTOn = 8
	FLVLn  = 12
)

const (
	FFLAG   FSTS0 = 0x0F << 0  //+ Fault Flags
	FFLAG_0 FSTS0 = 0x00 << 0  //  No fault on the FAULTx pin.
	FFLAG_1 FSTS0 = 0x01 << 0  //  Fault on the FAULTx pin.
	FFULL   FSTS0 = 0x0F << 4  //+ Full Cycle
	FFULL_0 FSTS0 = 0x00 << 4  //  PWM outputs are not re-enabled at the start of a full cycle
	FFULL_1 FSTS0 = 0x01 << 4  //  PWM outputs are re-enabled at the start of a full cycle
	FFPIN   FSTS0 = 0x0F << 8  //+ Filtered Fault Pins
	FHALF   FSTS0 = 0x0F << 12 //+ Half Cycle Fault Recovery
	FHALF_0 FSTS0 = 0x00 << 12 //  PWM outputs are not re-enabled at the start of a half cycle.
	FHALF_1 FSTS0 = 0x01 << 12 //  PWM outputs are re-enabled at the start of a half cycle (as defined by VAL0).
)

const (
	FFLAGn = 0
	FFULLn = 4
	FFPINn = 8
	FHALFn = 12
)

const (
	FILT_PER FFILT0 = 0xFF << 0  //+ Fault Filter Period
	FILT_CNT FFILT0 = 0x07 << 8  //+ Fault Filter Count
	GSTR     FFILT0 = 0x01 << 15 //+ Fault Glitch Stretch Enable
	GSTR_0   FFILT0 = 0x00 << 15 //  Fault input glitch stretching is disabled.
	GSTR_1   FFILT0 = 0x01 << 15 //  Input fault signals will be stretched to at least 2 IPBus clock cycles.
)

const (
	FILT_PERn = 0
	FILT_CNTn = 8
	GSTRn     = 15
)

const (
	FTEST   FTST0 = 0x01 << 0 //+ Fault Test
	FTEST_0 FTST0 = 0x00 << 0 //  No fault
	FTEST_1 FTST0 = 0x01 << 0 //  Cause a simulated fault
)

const (
	FTESTn = 0
)

const (
	NOCOMB   FCTRL20 = 0x0F << 0 //+ No Combinational Path From Fault Input To PWM Output
	NOCOMB_0 FCTRL20 = 0x00 << 0 //  There is a combinational link from the fault inputs to the PWM outputs. The fault inputs are combined with the filtered and latched fault signals to disable the PWM outputs.
	NOCOMB_1 FCTRL20 = 0x01 << 0 //  The direct combinational path from the fault inputs to the PWM outputs is disabled and the filtered and latched fault signals are used to disable the PWM outputs.
)

const (
	NOCOMBn = 0
)
