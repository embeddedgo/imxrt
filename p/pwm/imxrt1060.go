// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package pwm provides access to the registers of the PWM peripheral.
//
// Instances:
//
//	PWM1  PWM1_BASE  -  PWM1_0*,PWM1_1*,PWM1_2*,PWM1_3*,PWM1_FAULT*
//	PWM2  PWM2_BASE  -  PWM2_0*,PWM2_1*,PWM2_2*,PWM2_3*,PWM2_FAULT*
//	PWM3  PWM3_BASE  -  PWM3_0*,PWM3_1*,PWM3_2*,PWM3_3*,PWM3_FAULT*
//	PWM4  PWM4_BASE  -  PWM4_0*,PWM4_1*,PWM4_2*,PWM4_3*,PWM4_FAULT*
//
// Registers:
//
//	0x000 16  SM0CNT        Counter Register
//	0x002 16  SM0INIT       Initial Count Register
//	0x004 16  SM0CTRL2      Control 2 Register
//	0x006 16  SM0CTRL       Control Register
//	0x00A 16  SM0VAL0       Value Register 0
//	0x00C 16  SM0FRACVAL1   Fractional Value Register 1
//	0x00E 16  SM0VAL1       Value Register 1
//	0x010 16  SM0FRACVAL2   Fractional Value Register 2
//	0x012 16  SM0VAL2       Value Register 2
//	0x014 16  SM0FRACVAL3   Fractional Value Register 3
//	0x016 16  SM0VAL3       Value Register 3
//	0x018 16  SM0FRACVAL4   Fractional Value Register 4
//	0x01A 16  SM0VAL4       Value Register 4
//	0x01C 16  SM0FRACVAL5   Fractional Value Register 5
//	0x01E 16  SM0VAL5       Value Register 5
//	0x020 16  SM0FRCTRL     Fractional Control Register
//	0x022 16  SM0OCTRL      Output Control Register
//	0x024 16  SM0STS        Status Register
//	0x026 16  SM0INTEN      Interrupt Enable Register
//	0x028 16  SM0DMAEN      DMA Enable Register
//	0x02A 16  SM0TCTRL      Output Trigger Control Register
//	0x02C 16  SM0DISMAP0    Fault Disable Mapping Register 0
//	0x02E 16  SM0DISMAP1    Fault Disable Mapping Register 1
//	0x030 16  SM0DTCNT0     Deadtime Count Register 0
//	0x032 16  SM0DTCNT1     Deadtime Count Register 1
//	0x034 16  SM0CAPTCTRLA  Capture Control A Register
//	0x036 16  SM0CAPTCOMPA  Capture Compare A Register
//	0x038 16  SM0CAPTCTRLB  Capture Control B Register
//	0x03A 16  SM0CAPTCOMPB  Capture Compare B Register
//	0x03C 16  SM0CAPTCTRLX  Capture Control X Register
//	0x03E 16  SM0CAPTCOMPX  Capture Compare X Register
//	0x040 16  SM0CVAL0      Capture Value 0 Register
//	0x042 16  SM0CVAL0CYC   Capture Value 0 Cycle Register
//	0x044 16  SM0CVAL1      Capture Value 1 Register
//	0x046 16  SM0CVAL1CYC   Capture Value 1 Cycle Register
//	0x048 16  SM0CVAL2      Capture Value 2 Register
//	0x04A 16  SM0CVAL2CYC   Capture Value 2 Cycle Register
//	0x04C 16  SM0CVAL3      Capture Value 3 Register
//	0x04E 16  SM0CVAL3CYC   Capture Value 3 Cycle Register
//	0x050 16  SM0CVAL4      Capture Value 4 Register
//	0x052 16  SM0CVAL4CYC   Capture Value 4 Cycle Register
//	0x054 16  SM0CVAL5      Capture Value 5 Register
//	0x056 16  SM0CVAL5CYC   Capture Value 5 Cycle Register
//	0x060 16  SM1CNT        Counter Register
//	0x062 16  SM1INIT       Initial Count Register
//	0x064 16  SM1CTRL2      Control 2 Register
//	0x066 16  SM1CTRL       Control Register
//	0x06A 16  SM1VAL0       Value Register 0
//	0x06C 16  SM1FRACVAL1   Fractional Value Register 1
//	0x06E 16  SM1VAL1       Value Register 1
//	0x070 16  SM1FRACVAL2   Fractional Value Register 2
//	0x072 16  SM1VAL2       Value Register 2
//	0x074 16  SM1FRACVAL3   Fractional Value Register 3
//	0x076 16  SM1VAL3       Value Register 3
//	0x078 16  SM1FRACVAL4   Fractional Value Register 4
//	0x07A 16  SM1VAL4       Value Register 4
//	0x07C 16  SM1FRACVAL5   Fractional Value Register 5
//	0x07E 16  SM1VAL5       Value Register 5
//	0x080 16  SM1FRCTRL     Fractional Control Register
//	0x082 16  SM1OCTRL      Output Control Register
//	0x084 16  SM1STS        Status Register
//	0x086 16  SM1INTEN      Interrupt Enable Register
//	0x088 16  SM1DMAEN      DMA Enable Register
//	0x08A 16  SM1TCTRL      Output Trigger Control Register
//	0x08C 16  SM1DISMAP0    Fault Disable Mapping Register 0
//	0x08E 16  SM1DISMAP1    Fault Disable Mapping Register 1
//	0x090 16  SM1DTCNT0     Deadtime Count Register 0
//	0x092 16  SM1DTCNT1     Deadtime Count Register 1
//	0x094 16  SM1CAPTCTRLA  Capture Control A Register
//	0x096 16  SM1CAPTCOMPA  Capture Compare A Register
//	0x098 16  SM1CAPTCTRLB  Capture Control B Register
//	0x09A 16  SM1CAPTCOMPB  Capture Compare B Register
//	0x09C 16  SM1CAPTCTRLX  Capture Control X Register
//	0x09E 16  SM1CAPTCOMPX  Capture Compare X Register
//	0x0A0 16  SM1CVAL0      Capture Value 0 Register
//	0x0A2 16  SM1CVAL0CYC   Capture Value 0 Cycle Register
//	0x0A4 16  SM1CVAL1      Capture Value 1 Register
//	0x0A6 16  SM1CVAL1CYC   Capture Value 1 Cycle Register
//	0x0A8 16  SM1CVAL2      Capture Value 2 Register
//	0x0AA 16  SM1CVAL2CYC   Capture Value 2 Cycle Register
//	0x0AC 16  SM1CVAL3      Capture Value 3 Register
//	0x0AE 16  SM1CVAL3CYC   Capture Value 3 Cycle Register
//	0x0B0 16  SM1CVAL4      Capture Value 4 Register
//	0x0B2 16  SM1CVAL4CYC   Capture Value 4 Cycle Register
//	0x0B4 16  SM1CVAL5      Capture Value 5 Register
//	0x0B6 16  SM1CVAL5CYC   Capture Value 5 Cycle Register
//	0x0C0 16  SM2CNT        Counter Register
//	0x0C2 16  SM2INIT       Initial Count Register
//	0x0C4 16  SM2CTRL2      Control 2 Register
//	0x0C6 16  SM2CTRL       Control Register
//	0x0CA 16  SM2VAL0       Value Register 0
//	0x0CC 16  SM2FRACVAL1   Fractional Value Register 1
//	0x0CE 16  SM2VAL1       Value Register 1
//	0x0D0 16  SM2FRACVAL2   Fractional Value Register 2
//	0x0D2 16  SM2VAL2       Value Register 2
//	0x0D4 16  SM2FRACVAL3   Fractional Value Register 3
//	0x0D6 16  SM2VAL3       Value Register 3
//	0x0D8 16  SM2FRACVAL4   Fractional Value Register 4
//	0x0DA 16  SM2VAL4       Value Register 4
//	0x0DC 16  SM2FRACVAL5   Fractional Value Register 5
//	0x0DE 16  SM2VAL5       Value Register 5
//	0x0E0 16  SM2FRCTRL     Fractional Control Register
//	0x0E2 16  SM2OCTRL      Output Control Register
//	0x0E4 16  SM2STS        Status Register
//	0x0E6 16  SM2INTEN      Interrupt Enable Register
//	0x0E8 16  SM2DMAEN      DMA Enable Register
//	0x0EA 16  SM2TCTRL      Output Trigger Control Register
//	0x0EC 16  SM2DISMAP0    Fault Disable Mapping Register 0
//	0x0EE 16  SM2DISMAP1    Fault Disable Mapping Register 1
//	0x0F0 16  SM2DTCNT0     Deadtime Count Register 0
//	0x0F2 16  SM2DTCNT1     Deadtime Count Register 1
//	0x0F4 16  SM2CAPTCTRLA  Capture Control A Register
//	0x0F6 16  SM2CAPTCOMPA  Capture Compare A Register
//	0x0F8 16  SM2CAPTCTRLB  Capture Control B Register
//	0x0FA 16  SM2CAPTCOMPB  Capture Compare B Register
//	0x0FC 16  SM2CAPTCTRLX  Capture Control X Register
//	0x0FE 16  SM2CAPTCOMPX  Capture Compare X Register
//	0x100 16  SM2CVAL0      Capture Value 0 Register
//	0x102 16  SM2CVAL0CYC   Capture Value 0 Cycle Register
//	0x104 16  SM2CVAL1      Capture Value 1 Register
//	0x106 16  SM2CVAL1CYC   Capture Value 1 Cycle Register
//	0x108 16  SM2CVAL2      Capture Value 2 Register
//	0x10A 16  SM2CVAL2CYC   Capture Value 2 Cycle Register
//	0x10C 16  SM2CVAL3      Capture Value 3 Register
//	0x10E 16  SM2CVAL3CYC   Capture Value 3 Cycle Register
//	0x110 16  SM2CVAL4      Capture Value 4 Register
//	0x112 16  SM2CVAL4CYC   Capture Value 4 Cycle Register
//	0x114 16  SM2CVAL5      Capture Value 5 Register
//	0x116 16  SM2CVAL5CYC   Capture Value 5 Cycle Register
//	0x120 16  SM3CNT        Counter Register
//	0x122 16  SM3INIT       Initial Count Register
//	0x124 16  SM3CTRL2      Control 2 Register
//	0x126 16  SM3CTRL       Control Register
//	0x12A 16  SM3VAL0       Value Register 0
//	0x12C 16  SM3FRACVAL1   Fractional Value Register 1
//	0x12E 16  SM3VAL1       Value Register 1
//	0x130 16  SM3FRACVAL2   Fractional Value Register 2
//	0x132 16  SM3VAL2       Value Register 2
//	0x134 16  SM3FRACVAL3   Fractional Value Register 3
//	0x136 16  SM3VAL3       Value Register 3
//	0x138 16  SM3FRACVAL4   Fractional Value Register 4
//	0x13A 16  SM3VAL4       Value Register 4
//	0x13C 16  SM3FRACVAL5   Fractional Value Register 5
//	0x13E 16  SM3VAL5       Value Register 5
//	0x140 16  SM3FRCTRL     Fractional Control Register
//	0x142 16  SM3OCTRL      Output Control Register
//	0x144 16  SM3STS        Status Register
//	0x146 16  SM3INTEN      Interrupt Enable Register
//	0x148 16  SM3DMAEN      DMA Enable Register
//	0x14A 16  SM3TCTRL      Output Trigger Control Register
//	0x14C 16  SM3DISMAP0    Fault Disable Mapping Register 0
//	0x14E 16  SM3DISMAP1    Fault Disable Mapping Register 1
//	0x150 16  SM3DTCNT0     Deadtime Count Register 0
//	0x152 16  SM3DTCNT1     Deadtime Count Register 1
//	0x154 16  SM3CAPTCTRLA  Capture Control A Register
//	0x156 16  SM3CAPTCOMPA  Capture Compare A Register
//	0x158 16  SM3CAPTCTRLB  Capture Control B Register
//	0x15A 16  SM3CAPTCOMPB  Capture Compare B Register
//	0x15C 16  SM3CAPTCTRLX  Capture Control X Register
//	0x15E 16  SM3CAPTCOMPX  Capture Compare X Register
//	0x160 16  SM3CVAL0      Capture Value 0 Register
//	0x162 16  SM3CVAL0CYC   Capture Value 0 Cycle Register
//	0x164 16  SM3CVAL1      Capture Value 1 Register
//	0x166 16  SM3CVAL1CYC   Capture Value 1 Cycle Register
//	0x168 16  SM3CVAL2      Capture Value 2 Register
//	0x16A 16  SM3CVAL2CYC   Capture Value 2 Cycle Register
//	0x16C 16  SM3CVAL3      Capture Value 3 Register
//	0x16E 16  SM3CVAL3CYC   Capture Value 3 Cycle Register
//	0x170 16  SM3CVAL4      Capture Value 4 Register
//	0x172 16  SM3CVAL4CYC   Capture Value 4 Cycle Register
//	0x174 16  SM3CVAL5      Capture Value 5 Register
//	0x176 16  SM3CVAL5CYC   Capture Value 5 Cycle Register
//	0x180 16  OUTEN         Output Enable Register
//	0x182 16  MASK          Mask Register
//	0x184 16  SWCOUT        Software Controlled Output Register
//	0x186 16  DTSRCSEL      PWM Source Select Register
//	0x188 16  MCTRL         Master Control Register
//	0x18A 16  MCTRL2        Master Control 2 Register
//	0x18C 16  FCTRL0        Fault Control Register
//	0x18E 16  FSTS0         Fault Status Register
//	0x190 16  FFILT0        Fault Filter Register
//	0x192 16  FTST0         Fault Test Register
//	0x194 16  FCTRL20       Fault Control 2 Register
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package pwm

const (
	CNT SM0CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM0INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL     SM0CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0   SM0CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1   SM0CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2   SM0CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL  SM0CTRL2 = 0x01 << 2  //+ Reload Source Select
	FORCE_SEL   SM0CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0 SM0CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1 SM0CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2 SM0CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3 SM0CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4 SM0CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5 SM0CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6 SM0CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7 SM0CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE       SM0CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN       SM0CTRL2 = 0x01 << 7  //+ FRCEN
	INIT_SEL    SM0CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0  SM0CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1  SM0CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2  SM0CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3  SM0CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT   SM0CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT  SM0CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT  SM0CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP       SM0CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	WAITEN      SM0CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN       SM0CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN    SM0CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLX     SM0CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	LDMOD    SM0CTRL = 0x01 << 2  //+ Load Mode Select
	SPLIT    SM0CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	PRSC     SM0CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0   SM0CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1   SM0CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2   SM0CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3   SM0CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4   SM0CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5   SM0CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6   SM0CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7   SM0CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE SM0CTRL = 0x01 << 7  //+ Compare Mode
	DT       SM0CTRL = 0x03 << 8  //+ Deadtime
	FULL     SM0CTRL = 0x01 << 10 //+ Full Cycle Reload
	HALF     SM0CTRL = 0x01 << 11 //+ Half Cycle Reload
	LDFQ     SM0CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0   SM0CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1   SM0CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2   SM0CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3   SM0CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4   SM0CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5   SM0CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6   SM0CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7   SM0CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8   SM0CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9   SM0CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10  SM0CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11  SM0CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12  SM0CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13  SM0CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14  SM0CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15  SM0CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM0VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM0FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM0VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM0FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM0VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM0FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM0VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM0FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM0VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM0FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM0VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN  SM0FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC23_EN SM0FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC45_EN SM0FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC_PU   SM0FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	TEST      SM0FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM0OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM0OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM0OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM0OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM0OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM0OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM0OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM0OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM0OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM0OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM0OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM0OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM0OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM0OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM0OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM0OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLB     SM0OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLA     SM0OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	PWMX_IN  SM0OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM0OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM0OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM0STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM0STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM0STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM0STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM0STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM0STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM0STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM0STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM0STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM0STS = 0x01 << 12 //+ Reload Flag
	REF    SM0STS = 0x01 << 13 //+ Reload Error Flag
	RUF    SM0STS = 0x01 << 14 //+ Registers Updated Flag
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM0INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM0INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM0INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM0INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX1IE   SM0INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CB0IE   SM0INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB1IE   SM0INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CA0IE   SM0INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA1IE   SM0INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	RIE     SM0INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	REIE    SM0INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM0DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM0DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM0DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM0DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM0DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM0DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM0DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM0DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM0DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM0DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM0DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM0DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	VALDE    SM0DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM0TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM0TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM0TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM0TCTRL = 0x01 << 12 //+ Trigger frequency
	PWBOT1        SM0TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWAOT0        SM0TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM0DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM0DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM0DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM0DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM0DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM0DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM0DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM0DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA       SM0CAPTCTRLA = 0x01 << 0  //+ Arm A
	ONESHOTA   SM0CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	EDGA0      SM0CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0    SM0CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1    SM0CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2    SM0CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3    SM0CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1      SM0CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0    SM0CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1    SM0CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2    SM0CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3    SM0CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA   SM0CAPTCTRLA = 0x01 << 6  //+ Input Select A
	EDGCNTA_EN SM0CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	CFAWM      SM0CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT     SM0CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT     SM0CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM0CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM0CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB       SM0CAPTCTRLB = 0x01 << 0  //+ Arm B
	ONESHOTB   SM0CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	EDGB0      SM0CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0    SM0CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1    SM0CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2    SM0CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3    SM0CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1      SM0CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0    SM0CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1    SM0CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2    SM0CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3    SM0CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB   SM0CAPTCTRLB = 0x01 << 6  //+ Input Select B
	EDGCNTB_EN SM0CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	CFBWM      SM0CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT     SM0CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT     SM0CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM0CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM0CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX       SM0CAPTCTRLX = 0x01 << 0  //+ Arm X
	ONESHOTX   SM0CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	EDGX0      SM0CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0    SM0CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1    SM0CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2    SM0CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3    SM0CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1      SM0CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0    SM0CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1    SM0CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2    SM0CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3    SM0CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX   SM0CAPTCTRLX = 0x01 << 6  //+ Input Select X
	EDGCNTX_EN SM0CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	CFXWM      SM0CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT     SM0CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT     SM0CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM0CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM0CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM0CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM0CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM0CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM0CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM0CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM0CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM0CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM0CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM0CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM0CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM0CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM0CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM1CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM1INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL     SM1CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0   SM1CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1   SM1CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2   SM1CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL  SM1CTRL2 = 0x01 << 2  //+ Reload Source Select
	FORCE_SEL   SM1CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0 SM1CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1 SM1CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2 SM1CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3 SM1CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4 SM1CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5 SM1CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6 SM1CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7 SM1CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE       SM1CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN       SM1CTRL2 = 0x01 << 7  //+ FRCEN
	INIT_SEL    SM1CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0  SM1CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1  SM1CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2  SM1CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3  SM1CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT   SM1CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT  SM1CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT  SM1CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP       SM1CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	WAITEN      SM1CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN       SM1CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN    SM1CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLX     SM1CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	LDMOD    SM1CTRL = 0x01 << 2  //+ Load Mode Select
	SPLIT    SM1CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	PRSC     SM1CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0   SM1CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1   SM1CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2   SM1CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3   SM1CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4   SM1CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5   SM1CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6   SM1CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7   SM1CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE SM1CTRL = 0x01 << 7  //+ Compare Mode
	DT       SM1CTRL = 0x03 << 8  //+ Deadtime
	FULL     SM1CTRL = 0x01 << 10 //+ Full Cycle Reload
	HALF     SM1CTRL = 0x01 << 11 //+ Half Cycle Reload
	LDFQ     SM1CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0   SM1CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1   SM1CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2   SM1CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3   SM1CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4   SM1CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5   SM1CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6   SM1CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7   SM1CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8   SM1CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9   SM1CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10  SM1CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11  SM1CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12  SM1CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13  SM1CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14  SM1CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15  SM1CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM1VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM1FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM1VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM1FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM1VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM1FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM1VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM1FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM1VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM1FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM1VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN  SM1FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC23_EN SM1FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC45_EN SM1FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC_PU   SM1FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	TEST      SM1FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM1OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM1OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM1OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM1OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM1OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM1OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM1OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM1OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM1OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM1OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM1OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM1OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM1OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM1OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM1OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM1OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLB     SM1OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLA     SM1OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	PWMX_IN  SM1OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM1OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM1OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM1STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM1STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM1STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM1STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM1STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM1STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM1STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM1STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM1STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM1STS = 0x01 << 12 //+ Reload Flag
	REF    SM1STS = 0x01 << 13 //+ Reload Error Flag
	RUF    SM1STS = 0x01 << 14 //+ Registers Updated Flag
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM1INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM1INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM1INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM1INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX1IE   SM1INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CB0IE   SM1INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB1IE   SM1INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CA0IE   SM1INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA1IE   SM1INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	RIE     SM1INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	REIE    SM1INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM1DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM1DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM1DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM1DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM1DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM1DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM1DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM1DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM1DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM1DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM1DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM1DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	VALDE    SM1DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM1TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM1TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM1TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM1TCTRL = 0x01 << 12 //+ Trigger frequency
	PWBOT1        SM1TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWAOT0        SM1TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM1DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM1DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM1DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM1DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM1DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM1DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM1DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM1DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA       SM1CAPTCTRLA = 0x01 << 0  //+ Arm A
	ONESHOTA   SM1CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	EDGA0      SM1CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0    SM1CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1    SM1CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2    SM1CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3    SM1CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1      SM1CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0    SM1CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1    SM1CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2    SM1CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3    SM1CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA   SM1CAPTCTRLA = 0x01 << 6  //+ Input Select A
	EDGCNTA_EN SM1CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	CFAWM      SM1CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT     SM1CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT     SM1CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM1CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM1CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB       SM1CAPTCTRLB = 0x01 << 0  //+ Arm B
	ONESHOTB   SM1CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	EDGB0      SM1CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0    SM1CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1    SM1CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2    SM1CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3    SM1CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1      SM1CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0    SM1CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1    SM1CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2    SM1CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3    SM1CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB   SM1CAPTCTRLB = 0x01 << 6  //+ Input Select B
	EDGCNTB_EN SM1CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	CFBWM      SM1CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT     SM1CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT     SM1CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM1CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM1CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX       SM1CAPTCTRLX = 0x01 << 0  //+ Arm X
	ONESHOTX   SM1CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	EDGX0      SM1CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0    SM1CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1    SM1CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2    SM1CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3    SM1CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1      SM1CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0    SM1CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1    SM1CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2    SM1CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3    SM1CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX   SM1CAPTCTRLX = 0x01 << 6  //+ Input Select X
	EDGCNTX_EN SM1CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	CFXWM      SM1CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT     SM1CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT     SM1CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM1CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM1CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM1CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM1CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM1CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM1CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM1CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM1CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM1CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM1CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM1CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM1CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM1CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM1CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM2CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM2INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL     SM2CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0   SM2CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1   SM2CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2   SM2CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL  SM2CTRL2 = 0x01 << 2  //+ Reload Source Select
	FORCE_SEL   SM2CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0 SM2CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1 SM2CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2 SM2CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3 SM2CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4 SM2CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5 SM2CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6 SM2CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7 SM2CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE       SM2CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN       SM2CTRL2 = 0x01 << 7  //+ FRCEN
	INIT_SEL    SM2CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0  SM2CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1  SM2CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2  SM2CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3  SM2CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT   SM2CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT  SM2CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT  SM2CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP       SM2CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	WAITEN      SM2CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN       SM2CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN    SM2CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLX     SM2CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	LDMOD    SM2CTRL = 0x01 << 2  //+ Load Mode Select
	SPLIT    SM2CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	PRSC     SM2CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0   SM2CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1   SM2CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2   SM2CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3   SM2CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4   SM2CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5   SM2CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6   SM2CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7   SM2CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE SM2CTRL = 0x01 << 7  //+ Compare Mode
	DT       SM2CTRL = 0x03 << 8  //+ Deadtime
	FULL     SM2CTRL = 0x01 << 10 //+ Full Cycle Reload
	HALF     SM2CTRL = 0x01 << 11 //+ Half Cycle Reload
	LDFQ     SM2CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0   SM2CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1   SM2CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2   SM2CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3   SM2CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4   SM2CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5   SM2CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6   SM2CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7   SM2CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8   SM2CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9   SM2CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10  SM2CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11  SM2CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12  SM2CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13  SM2CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14  SM2CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15  SM2CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM2VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM2FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM2VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM2FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM2VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM2FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM2VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM2FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM2VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM2FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM2VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN  SM2FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC23_EN SM2FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC45_EN SM2FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC_PU   SM2FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	TEST      SM2FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM2OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM2OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM2OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM2OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM2OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM2OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM2OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM2OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM2OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM2OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM2OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM2OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM2OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM2OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM2OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM2OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLB     SM2OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLA     SM2OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	PWMX_IN  SM2OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM2OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM2OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM2STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM2STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM2STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM2STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM2STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM2STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM2STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM2STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM2STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM2STS = 0x01 << 12 //+ Reload Flag
	REF    SM2STS = 0x01 << 13 //+ Reload Error Flag
	RUF    SM2STS = 0x01 << 14 //+ Registers Updated Flag
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM2INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM2INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM2INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM2INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX1IE   SM2INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CB0IE   SM2INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB1IE   SM2INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CA0IE   SM2INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA1IE   SM2INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	RIE     SM2INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	REIE    SM2INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM2DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM2DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM2DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM2DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM2DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM2DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM2DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM2DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM2DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM2DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM2DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM2DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	VALDE    SM2DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM2TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM2TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM2TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM2TCTRL = 0x01 << 12 //+ Trigger frequency
	PWBOT1        SM2TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWAOT0        SM2TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM2DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM2DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM2DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM2DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM2DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM2DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM2DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM2DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA       SM2CAPTCTRLA = 0x01 << 0  //+ Arm A
	ONESHOTA   SM2CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	EDGA0      SM2CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0    SM2CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1    SM2CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2    SM2CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3    SM2CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1      SM2CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0    SM2CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1    SM2CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2    SM2CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3    SM2CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA   SM2CAPTCTRLA = 0x01 << 6  //+ Input Select A
	EDGCNTA_EN SM2CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	CFAWM      SM2CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT     SM2CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT     SM2CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM2CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM2CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB       SM2CAPTCTRLB = 0x01 << 0  //+ Arm B
	ONESHOTB   SM2CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	EDGB0      SM2CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0    SM2CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1    SM2CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2    SM2CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3    SM2CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1      SM2CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0    SM2CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1    SM2CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2    SM2CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3    SM2CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB   SM2CAPTCTRLB = 0x01 << 6  //+ Input Select B
	EDGCNTB_EN SM2CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	CFBWM      SM2CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT     SM2CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT     SM2CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM2CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM2CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX       SM2CAPTCTRLX = 0x01 << 0  //+ Arm X
	ONESHOTX   SM2CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	EDGX0      SM2CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0    SM2CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1    SM2CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2    SM2CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3    SM2CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1      SM2CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0    SM2CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1    SM2CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2    SM2CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3    SM2CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX   SM2CAPTCTRLX = 0x01 << 6  //+ Input Select X
	EDGCNTX_EN SM2CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	CFXWM      SM2CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT     SM2CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT     SM2CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM2CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM2CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM2CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM2CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM2CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM2CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM2CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM2CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM2CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM2CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM2CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM2CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM2CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM2CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	CNT SM3CNT = 0xFFFF << 0 //+ Counter Register Bits
)

const (
	CNTn = 0
)

const (
	INIT SM3INIT = 0xFFFF << 0 //+ Initial Count Register Bits
)

const (
	INITn = 0
)

const (
	CLK_SEL     SM3CTRL2 = 0x03 << 0  //+ Clock Source Select
	CLK_SEL_0   SM3CTRL2 = 0x00 << 0  //  The IPBus clock is used as the clock for the local prescaler and counter.
	CLK_SEL_1   SM3CTRL2 = 0x01 << 0  //  EXT_CLK is used as the clock for the local prescaler and counter.
	CLK_SEL_2   SM3CTRL2 = 0x02 << 0  //  Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	RELOAD_SEL  SM3CTRL2 = 0x01 << 2  //+ Reload Source Select
	FORCE_SEL   SM3CTRL2 = 0x07 << 3  //+ This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
	FORCE_SEL_0 SM3CTRL2 = 0x00 << 3  //  The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	FORCE_SEL_1 SM3CTRL2 = 0x01 << 3  //  The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_2 SM3CTRL2 = 0x02 << 3  //  The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	FORCE_SEL_3 SM3CTRL2 = 0x03 << 3  //  The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_4 SM3CTRL2 = 0x04 << 3  //  The local sync signal from this submodule is used to force updates.
	FORCE_SEL_5 SM3CTRL2 = 0x05 << 3  //  The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	FORCE_SEL_6 SM3CTRL2 = 0x06 << 3  //  The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	FORCE_SEL_7 SM3CTRL2 = 0x07 << 3  //  The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	FORCE       SM3CTRL2 = 0x01 << 6  //+ Force Initialization
	FRCEN       SM3CTRL2 = 0x01 << 7  //+ FRCEN
	INIT_SEL    SM3CTRL2 = 0x03 << 8  //+ Initialization Control Select
	INIT_SEL_0  SM3CTRL2 = 0x00 << 8  //  Local sync (PWM_X) causes initialization.
	INIT_SEL_1  SM3CTRL2 = 0x01 << 8  //  Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	INIT_SEL_2  SM3CTRL2 = 0x02 << 8  //  Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	INIT_SEL_3  SM3CTRL2 = 0x03 << 8  //  EXT_SYNC causes initialization.
	PWMX_INIT   SM3CTRL2 = 0x01 << 10 //+ PWM_X Initial Value
	PWM45_INIT  SM3CTRL2 = 0x01 << 11 //+ PWM45 Initial Value
	PWM23_INIT  SM3CTRL2 = 0x01 << 12 //+ PWM23 Initial Value
	INDEP       SM3CTRL2 = 0x01 << 13 //+ Independent or Complementary Pair Operation
	WAITEN      SM3CTRL2 = 0x01 << 14 //+ WAIT Enable
	DBGEN       SM3CTRL2 = 0x01 << 15 //+ Debug Enable
)

const (
	CLK_SELn    = 0
	RELOAD_SELn = 2
	FORCE_SELn  = 3
	FORCEn      = 6
	FRCENn      = 7
	INIT_SELn   = 8
	PWMX_INITn  = 10
	PWM45_INITn = 11
	PWM23_INITn = 12
	INDEPn      = 13
	WAITENn     = 14
	DBGENn      = 15
)

const (
	DBLEN    SM3CTRL = 0x01 << 0  //+ Double Switching Enable
	DBLX     SM3CTRL = 0x01 << 1  //+ PWMX Double Switching Enable
	LDMOD    SM3CTRL = 0x01 << 2  //+ Load Mode Select
	SPLIT    SM3CTRL = 0x01 << 3  //+ Split the DBLPWM signal to PWMA and PWMB
	PRSC     SM3CTRL = 0x07 << 4  //+ Prescaler
	PRSC_0   SM3CTRL = 0x00 << 4  //  PWM clock frequency = fclk
	PRSC_1   SM3CTRL = 0x01 << 4  //  PWM clock frequency = fclk/2
	PRSC_2   SM3CTRL = 0x02 << 4  //  PWM clock frequency = fclk/4
	PRSC_3   SM3CTRL = 0x03 << 4  //  PWM clock frequency = fclk/8
	PRSC_4   SM3CTRL = 0x04 << 4  //  PWM clock frequency = fclk/16
	PRSC_5   SM3CTRL = 0x05 << 4  //  PWM clock frequency = fclk/32
	PRSC_6   SM3CTRL = 0x06 << 4  //  PWM clock frequency = fclk/64
	PRSC_7   SM3CTRL = 0x07 << 4  //  PWM clock frequency = fclk/128
	COMPMODE SM3CTRL = 0x01 << 7  //+ Compare Mode
	DT       SM3CTRL = 0x03 << 8  //+ Deadtime
	FULL     SM3CTRL = 0x01 << 10 //+ Full Cycle Reload
	HALF     SM3CTRL = 0x01 << 11 //+ Half Cycle Reload
	LDFQ     SM3CTRL = 0x0F << 12 //+ Load Frequency
	LDFQ_0   SM3CTRL = 0x00 << 12 //  Every PWM opportunity
	LDFQ_1   SM3CTRL = 0x01 << 12 //  Every 2 PWM opportunities
	LDFQ_2   SM3CTRL = 0x02 << 12 //  Every 3 PWM opportunities
	LDFQ_3   SM3CTRL = 0x03 << 12 //  Every 4 PWM opportunities
	LDFQ_4   SM3CTRL = 0x04 << 12 //  Every 5 PWM opportunities
	LDFQ_5   SM3CTRL = 0x05 << 12 //  Every 6 PWM opportunities
	LDFQ_6   SM3CTRL = 0x06 << 12 //  Every 7 PWM opportunities
	LDFQ_7   SM3CTRL = 0x07 << 12 //  Every 8 PWM opportunities
	LDFQ_8   SM3CTRL = 0x08 << 12 //  Every 9 PWM opportunities
	LDFQ_9   SM3CTRL = 0x09 << 12 //  Every 10 PWM opportunities
	LDFQ_10  SM3CTRL = 0x0A << 12 //  Every 11 PWM opportunities
	LDFQ_11  SM3CTRL = 0x0B << 12 //  Every 12 PWM opportunities
	LDFQ_12  SM3CTRL = 0x0C << 12 //  Every 13 PWM opportunities
	LDFQ_13  SM3CTRL = 0x0D << 12 //  Every 14 PWM opportunities
	LDFQ_14  SM3CTRL = 0x0E << 12 //  Every 15 PWM opportunities
	LDFQ_15  SM3CTRL = 0x0F << 12 //  Every 16 PWM opportunities
)

const (
	DBLENn    = 0
	DBLXn     = 1
	LDMODn    = 2
	SPLITn    = 3
	PRSCn     = 4
	COMPMODEn = 7
	DTn       = 8
	FULLn     = 10
	HALFn     = 11
	LDFQn     = 12
)

const (
	VAL0 SM3VAL0 = 0xFFFF << 0 //+ Value Register 0
)

const (
	VAL0n = 0
)

const (
	FRACVAL1 SM3FRACVAL1 = 0x1F << 11 //+ Fractional Value 1 Register
)

const (
	FRACVAL1n = 11
)

const (
	VAL1 SM3VAL1 = 0xFFFF << 0 //+ Value Register 1
)

const (
	VAL1n = 0
)

const (
	FRACVAL2 SM3FRACVAL2 = 0x1F << 11 //+ Fractional Value 2
)

const (
	FRACVAL2n = 11
)

const (
	VAL2 SM3VAL2 = 0xFFFF << 0 //+ Value Register 2
)

const (
	VAL2n = 0
)

const (
	FRACVAL3 SM3FRACVAL3 = 0x1F << 11 //+ Fractional Value 3
)

const (
	FRACVAL3n = 11
)

const (
	VAL3 SM3VAL3 = 0xFFFF << 0 //+ Value Register 3
)

const (
	VAL3n = 0
)

const (
	FRACVAL4 SM3FRACVAL4 = 0x1F << 11 //+ Fractional Value 4
)

const (
	FRACVAL4n = 11
)

const (
	VAL4 SM3VAL4 = 0xFFFF << 0 //+ Value Register 4
)

const (
	VAL4n = 0
)

const (
	FRACVAL5 SM3FRACVAL5 = 0x1F << 11 //+ Fractional Value 5
)

const (
	FRACVAL5n = 11
)

const (
	VAL5 SM3VAL5 = 0xFFFF << 0 //+ Value Register 5
)

const (
	VAL5n = 0
)

const (
	FRAC1_EN  SM3FRCTRL = 0x01 << 1  //+ Fractional Cycle PWM Period Enable
	FRAC23_EN SM3FRCTRL = 0x01 << 2  //+ Fractional Cycle Placement Enable for PWM_A
	FRAC45_EN SM3FRCTRL = 0x01 << 4  //+ Fractional Cycle Placement Enable for PWM_B
	FRAC_PU   SM3FRCTRL = 0x01 << 8  //+ Fractional Delay Circuit Power Up
	TEST      SM3FRCTRL = 0x01 << 15 //+ Test Status Bit
)

const (
	FRAC1_ENn  = 1
	FRAC23_ENn = 2
	FRAC45_ENn = 4
	FRAC_PUn   = 8
	TESTn      = 15
)

const (
	PWMXFS   SM3OCTRL = 0x03 << 0  //+ PWM_X Fault State
	PWMXFS_0 SM3OCTRL = 0x00 << 0  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMXFS_1 SM3OCTRL = 0x01 << 0  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMXFS_2 SM3OCTRL = 0x02 << 0  //  Output is tristated.
	PWMXFS_3 SM3OCTRL = 0x03 << 0  //  Output is tristated.
	PWMBFS   SM3OCTRL = 0x03 << 2  //+ PWM_B Fault State
	PWMBFS_0 SM3OCTRL = 0x00 << 2  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMBFS_1 SM3OCTRL = 0x01 << 2  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMBFS_2 SM3OCTRL = 0x02 << 2  //  Output is tristated.
	PWMBFS_3 SM3OCTRL = 0x03 << 2  //  Output is tristated.
	PWMAFS   SM3OCTRL = 0x03 << 4  //+ PWM_A Fault State
	PWMAFS_0 SM3OCTRL = 0x00 << 4  //  Output is forced to logic 0 state prior to consideration of output polarity control.
	PWMAFS_1 SM3OCTRL = 0x01 << 4  //  Output is forced to logic 1 state prior to consideration of output polarity control.
	PWMAFS_2 SM3OCTRL = 0x02 << 4  //  Output is tristated.
	PWMAFS_3 SM3OCTRL = 0x03 << 4  //  Output is tristated.
	POLX     SM3OCTRL = 0x01 << 8  //+ PWM_X Output Polarity
	POLB     SM3OCTRL = 0x01 << 9  //+ PWM_B Output Polarity
	POLA     SM3OCTRL = 0x01 << 10 //+ PWM_A Output Polarity
	PWMX_IN  SM3OCTRL = 0x01 << 13 //+ PWM_X Input
	PWMB_IN  SM3OCTRL = 0x01 << 14 //+ PWM_B Input
	PWMA_IN  SM3OCTRL = 0x01 << 15 //+ PWM_A Input
)

const (
	PWMXFSn  = 0
	PWMBFSn  = 2
	PWMAFSn  = 4
	POLXn    = 8
	POLBn    = 9
	POLAn    = 10
	PWMX_INn = 13
	PWMB_INn = 14
	PWMA_INn = 15
)

const (
	CMPF   SM3STS = 0x3F << 0  //+ Compare Flags
	CMPF_0 SM3STS = 0x00 << 0  //  No compare event has occurred for a particular VALx value.
	CMPF_1 SM3STS = 0x01 << 0  //  A compare event has occurred for a particular VALx value.
	CFX0   SM3STS = 0x01 << 6  //+ Capture Flag X0
	CFX1   SM3STS = 0x01 << 7  //+ Capture Flag X1
	CFB0   SM3STS = 0x01 << 8  //+ Capture Flag B0
	CFB1   SM3STS = 0x01 << 9  //+ Capture Flag B1
	CFA0   SM3STS = 0x01 << 10 //+ Capture Flag A0
	CFA1   SM3STS = 0x01 << 11 //+ Capture Flag A1
	RF     SM3STS = 0x01 << 12 //+ Reload Flag
	REF    SM3STS = 0x01 << 13 //+ Reload Error Flag
	RUF    SM3STS = 0x01 << 14 //+ Registers Updated Flag
)

const (
	CMPFn = 0
	CFX0n = 6
	CFX1n = 7
	CFB0n = 8
	CFB1n = 9
	CFA0n = 10
	CFA1n = 11
	RFn   = 12
	REFn  = 13
	RUFn  = 14
)

const (
	CMPIE   SM3INTEN = 0x3F << 0  //+ Compare Interrupt Enables
	CMPIE_0 SM3INTEN = 0x00 << 0  //  The corresponding STS[CMPF] bit will not cause an interrupt request.
	CMPIE_1 SM3INTEN = 0x01 << 0  //  The corresponding STS[CMPF] bit will cause an interrupt request.
	CX0IE   SM3INTEN = 0x01 << 6  //+ Capture X 0 Interrupt Enable
	CX1IE   SM3INTEN = 0x01 << 7  //+ Capture X 1 Interrupt Enable
	CB0IE   SM3INTEN = 0x01 << 8  //+ Capture B 0 Interrupt Enable
	CB1IE   SM3INTEN = 0x01 << 9  //+ Capture B 1 Interrupt Enable
	CA0IE   SM3INTEN = 0x01 << 10 //+ Capture A 0 Interrupt Enable
	CA1IE   SM3INTEN = 0x01 << 11 //+ Capture A 1 Interrupt Enable
	RIE     SM3INTEN = 0x01 << 12 //+ Reload Interrupt Enable
	REIE    SM3INTEN = 0x01 << 13 //+ Reload Error Interrupt Enable
)

const (
	CMPIEn = 0
	CX0IEn = 6
	CX1IEn = 7
	CB0IEn = 8
	CB1IEn = 9
	CA0IEn = 10
	CA1IEn = 11
	RIEn   = 12
	REIEn  = 13
)

const (
	CX0DE    SM3DMAEN = 0x01 << 0 //+ Capture X0 FIFO DMA Enable
	CX1DE    SM3DMAEN = 0x01 << 1 //+ Capture X1 FIFO DMA Enable
	CB0DE    SM3DMAEN = 0x01 << 2 //+ Capture B0 FIFO DMA Enable
	CB1DE    SM3DMAEN = 0x01 << 3 //+ Capture B1 FIFO DMA Enable
	CA0DE    SM3DMAEN = 0x01 << 4 //+ Capture A0 FIFO DMA Enable
	CA1DE    SM3DMAEN = 0x01 << 5 //+ Capture A1 FIFO DMA Enable
	CAPTDE   SM3DMAEN = 0x03 << 6 //+ Capture DMA Enable Source Select
	CAPTDE_0 SM3DMAEN = 0x00 << 6 //  Read DMA requests disabled.
	CAPTDE_1 SM3DMAEN = 0x01 << 6 //  Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	CAPTDE_2 SM3DMAEN = 0x02 << 6 //  A local sync (VAL1 matches counter) sets the read DMA request.
	CAPTDE_3 SM3DMAEN = 0x03 << 6 //  A local reload (STS[RF] being set) sets the read DMA request.
	FAND     SM3DMAEN = 0x01 << 8 //+ FIFO Watermark AND Control
	VALDE    SM3DMAEN = 0x01 << 9 //+ Value Registers DMA Enable
)

const (
	CX0DEn  = 0
	CX1DEn  = 1
	CB0DEn  = 2
	CB1DEn  = 3
	CA0DEn  = 4
	CA1DEn  = 5
	CAPTDEn = 6
	FANDn   = 8
	VALDEn  = 9
)

const (
	OUT_TRIG_EN   SM3TCTRL = 0x3F << 0  //+ Output Trigger Enables
	OUT_TRIG_EN_0 SM3TCTRL = 0x00 << 0  //  PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	OUT_TRIG_EN_1 SM3TCTRL = 0x01 << 0  //  PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	TRGFRQ        SM3TCTRL = 0x01 << 12 //+ Trigger frequency
	PWBOT1        SM3TCTRL = 0x01 << 14 //+ Output Trigger 1 Source Select
	PWAOT0        SM3TCTRL = 0x01 << 15 //+ Output Trigger 0 Source Select
)

const (
	OUT_TRIG_ENn = 0
	TRGFRQn      = 12
	PWBOT1n      = 14
	PWAOT0n      = 15
)

const (
	DIS0A SM3DISMAP0 = 0x0F << 0 //+ PWM_A Fault Disable Mask 0
	DIS0B SM3DISMAP0 = 0x0F << 4 //+ PWM_B Fault Disable Mask 0
	DIS0X SM3DISMAP0 = 0x0F << 8 //+ PWM_X Fault Disable Mask 0
)

const (
	DIS0An = 0
	DIS0Bn = 4
	DIS0Xn = 8
)

const (
	DIS1A SM3DISMAP1 = 0x0F << 0 //+ PWM_A Fault Disable Mask 1
	DIS1B SM3DISMAP1 = 0x0F << 4 //+ PWM_B Fault Disable Mask 1
	DIS1X SM3DISMAP1 = 0x0F << 8 //+ PWM_X Fault Disable Mask 1
)

const (
	DIS1An = 0
	DIS1Bn = 4
	DIS1Xn = 8
)

const (
	DTCNT0 SM3DTCNT0 = 0xFFFF << 0 //+ DTCNT0
)

const (
	DTCNT0n = 0
)

const (
	DTCNT1 SM3DTCNT1 = 0xFFFF << 0 //+ DTCNT1
)

const (
	DTCNT1n = 0
)

const (
	ARMA       SM3CAPTCTRLA = 0x01 << 0  //+ Arm A
	ONESHOTA   SM3CAPTCTRLA = 0x01 << 1  //+ One Shot Mode A
	EDGA0      SM3CAPTCTRLA = 0x03 << 2  //+ Edge A 0
	EDGA0_0    SM3CAPTCTRLA = 0x00 << 2  //  Disabled
	EDGA0_1    SM3CAPTCTRLA = 0x01 << 2  //  Capture falling edges
	EDGA0_2    SM3CAPTCTRLA = 0x02 << 2  //  Capture rising edges
	EDGA0_3    SM3CAPTCTRLA = 0x03 << 2  //  Capture any edge
	EDGA1      SM3CAPTCTRLA = 0x03 << 4  //+ Edge A 1
	EDGA1_0    SM3CAPTCTRLA = 0x00 << 4  //  Disabled
	EDGA1_1    SM3CAPTCTRLA = 0x01 << 4  //  Capture falling edges
	EDGA1_2    SM3CAPTCTRLA = 0x02 << 4  //  Capture rising edges
	EDGA1_3    SM3CAPTCTRLA = 0x03 << 4  //  Capture any edge
	INP_SELA   SM3CAPTCTRLA = 0x01 << 6  //+ Input Select A
	EDGCNTA_EN SM3CAPTCTRLA = 0x01 << 7  //+ Edge Counter A Enable
	CFAWM      SM3CAPTCTRLA = 0x03 << 8  //+ Capture A FIFOs Water Mark
	CA0CNT     SM3CAPTCTRLA = 0x07 << 10 //+ Capture A0 FIFO Word Count
	CA1CNT     SM3CAPTCTRLA = 0x07 << 13 //+ Capture A1 FIFO Word Count
)

const (
	ARMAn       = 0
	ONESHOTAn   = 1
	EDGA0n      = 2
	EDGA1n      = 4
	INP_SELAn   = 6
	EDGCNTA_ENn = 7
	CFAWMn      = 8
	CA0CNTn     = 10
	CA1CNTn     = 13
)

const (
	EDGCMPA SM3CAPTCOMPA = 0xFF << 0 //+ Edge Compare A
	EDGCNTA SM3CAPTCOMPA = 0xFF << 8 //+ Edge Counter A
)

const (
	EDGCMPAn = 0
	EDGCNTAn = 8
)

const (
	ARMB       SM3CAPTCTRLB = 0x01 << 0  //+ Arm B
	ONESHOTB   SM3CAPTCTRLB = 0x01 << 1  //+ One Shot Mode B
	EDGB0      SM3CAPTCTRLB = 0x03 << 2  //+ Edge B 0
	EDGB0_0    SM3CAPTCTRLB = 0x00 << 2  //  Disabled
	EDGB0_1    SM3CAPTCTRLB = 0x01 << 2  //  Capture falling edges
	EDGB0_2    SM3CAPTCTRLB = 0x02 << 2  //  Capture rising edges
	EDGB0_3    SM3CAPTCTRLB = 0x03 << 2  //  Capture any edge
	EDGB1      SM3CAPTCTRLB = 0x03 << 4  //+ Edge B 1
	EDGB1_0    SM3CAPTCTRLB = 0x00 << 4  //  Disabled
	EDGB1_1    SM3CAPTCTRLB = 0x01 << 4  //  Capture falling edges
	EDGB1_2    SM3CAPTCTRLB = 0x02 << 4  //  Capture rising edges
	EDGB1_3    SM3CAPTCTRLB = 0x03 << 4  //  Capture any edge
	INP_SELB   SM3CAPTCTRLB = 0x01 << 6  //+ Input Select B
	EDGCNTB_EN SM3CAPTCTRLB = 0x01 << 7  //+ Edge Counter B Enable
	CFBWM      SM3CAPTCTRLB = 0x03 << 8  //+ Capture B FIFOs Water Mark
	CB0CNT     SM3CAPTCTRLB = 0x07 << 10 //+ Capture B0 FIFO Word Count
	CB1CNT     SM3CAPTCTRLB = 0x07 << 13 //+ Capture B1 FIFO Word Count
)

const (
	ARMBn       = 0
	ONESHOTBn   = 1
	EDGB0n      = 2
	EDGB1n      = 4
	INP_SELBn   = 6
	EDGCNTB_ENn = 7
	CFBWMn      = 8
	CB0CNTn     = 10
	CB1CNTn     = 13
)

const (
	EDGCMPB SM3CAPTCOMPB = 0xFF << 0 //+ Edge Compare B
	EDGCNTB SM3CAPTCOMPB = 0xFF << 8 //+ Edge Counter B
)

const (
	EDGCMPBn = 0
	EDGCNTBn = 8
)

const (
	ARMX       SM3CAPTCTRLX = 0x01 << 0  //+ Arm X
	ONESHOTX   SM3CAPTCTRLX = 0x01 << 1  //+ One Shot Mode Aux
	EDGX0      SM3CAPTCTRLX = 0x03 << 2  //+ Edge X 0
	EDGX0_0    SM3CAPTCTRLX = 0x00 << 2  //  Disabled
	EDGX0_1    SM3CAPTCTRLX = 0x01 << 2  //  Capture falling edges
	EDGX0_2    SM3CAPTCTRLX = 0x02 << 2  //  Capture rising edges
	EDGX0_3    SM3CAPTCTRLX = 0x03 << 2  //  Capture any edge
	EDGX1      SM3CAPTCTRLX = 0x03 << 4  //+ Edge X 1
	EDGX1_0    SM3CAPTCTRLX = 0x00 << 4  //  Disabled
	EDGX1_1    SM3CAPTCTRLX = 0x01 << 4  //  Capture falling edges
	EDGX1_2    SM3CAPTCTRLX = 0x02 << 4  //  Capture rising edges
	EDGX1_3    SM3CAPTCTRLX = 0x03 << 4  //  Capture any edge
	INP_SELX   SM3CAPTCTRLX = 0x01 << 6  //+ Input Select X
	EDGCNTX_EN SM3CAPTCTRLX = 0x01 << 7  //+ Edge Counter X Enable
	CFXWM      SM3CAPTCTRLX = 0x03 << 8  //+ Capture X FIFOs Water Mark
	CX0CNT     SM3CAPTCTRLX = 0x07 << 10 //+ Capture X0 FIFO Word Count
	CX1CNT     SM3CAPTCTRLX = 0x07 << 13 //+ Capture X1 FIFO Word Count
)

const (
	ARMXn       = 0
	ONESHOTXn   = 1
	EDGX0n      = 2
	EDGX1n      = 4
	INP_SELXn   = 6
	EDGCNTX_ENn = 7
	CFXWMn      = 8
	CX0CNTn     = 10
	CX1CNTn     = 13
)

const (
	EDGCMPX SM3CAPTCOMPX = 0xFF << 0 //+ Edge Compare X
	EDGCNTX SM3CAPTCOMPX = 0xFF << 8 //+ Edge Counter X
)

const (
	EDGCMPXn = 0
	EDGCNTXn = 8
)

const (
	CAPTVAL0 SM3CVAL0 = 0xFFFF << 0 //+ CAPTVAL0
)

const (
	CAPTVAL0n = 0
)

const (
	CVAL0CYC SM3CVAL0CYC = 0x0F << 0 //+ CVAL0CYC
)

const (
	CVAL0CYCn = 0
)

const (
	CAPTVAL1 SM3CVAL1 = 0xFFFF << 0 //+ CAPTVAL1
)

const (
	CAPTVAL1n = 0
)

const (
	CVAL1CYC SM3CVAL1CYC = 0x0F << 0 //+ CVAL1CYC
)

const (
	CVAL1CYCn = 0
)

const (
	CAPTVAL2 SM3CVAL2 = 0xFFFF << 0 //+ CAPTVAL2
)

const (
	CAPTVAL2n = 0
)

const (
	CVAL2CYC SM3CVAL2CYC = 0x0F << 0 //+ CVAL2CYC
)

const (
	CVAL2CYCn = 0
)

const (
	CAPTVAL3 SM3CVAL3 = 0xFFFF << 0 //+ CAPTVAL3
)

const (
	CAPTVAL3n = 0
)

const (
	CVAL3CYC SM3CVAL3CYC = 0x0F << 0 //+ CVAL3CYC
)

const (
	CVAL3CYCn = 0
)

const (
	CAPTVAL4 SM3CVAL4 = 0xFFFF << 0 //+ CAPTVAL4
)

const (
	CAPTVAL4n = 0
)

const (
	CVAL4CYC SM3CVAL4CYC = 0x0F << 0 //+ CVAL4CYC
)

const (
	CVAL4CYCn = 0
)

const (
	CAPTVAL5 SM3CVAL5 = 0xFFFF << 0 //+ CAPTVAL5
)

const (
	CAPTVAL5n = 0
)

const (
	CVAL5CYC SM3CVAL5CYC = 0x0F << 0 //+ CVAL5CYC
)

const (
	CVAL5CYCn = 0
)

const (
	PWMX_EN   OUTEN = 0x0F << 0 //+ PWM_X Output Enables
	PWMX_EN_0 OUTEN = 0x00 << 0 //  PWM_X output disabled.
	PWMX_EN_1 OUTEN = 0x01 << 0 //  PWM_X output enabled.
	PWMB_EN   OUTEN = 0x0F << 4 //+ PWM_B Output Enables
	PWMB_EN_0 OUTEN = 0x00 << 4 //  PWM_B output disabled.
	PWMB_EN_1 OUTEN = 0x01 << 4 //  PWM_B output enabled.
	PWMA_EN   OUTEN = 0x0F << 8 //+ PWM_A Output Enables
	PWMA_EN_0 OUTEN = 0x00 << 8 //  PWM_A output disabled.
	PWMA_EN_1 OUTEN = 0x01 << 8 //  PWM_A output enabled.
)

const (
	PWMX_ENn = 0
	PWMB_ENn = 4
	PWMA_ENn = 8
)

const (
	MASKX         MASK = 0x0F << 0  //+ PWM_X Masks
	MASKX_0       MASK = 0x00 << 0  //  PWM_X output normal.
	MASKX_1       MASK = 0x01 << 0  //  PWM_X output masked.
	MASKB         MASK = 0x0F << 4  //+ PWM_B Masks
	MASKB_0       MASK = 0x00 << 4  //  PWM_B output normal.
	MASKB_1       MASK = 0x01 << 4  //  PWM_B output masked.
	MASKA         MASK = 0x0F << 8  //+ PWM_A Masks
	MASKA_0       MASK = 0x00 << 8  //  PWM_A output normal.
	MASKA_1       MASK = 0x01 << 8  //  PWM_A output masked.
	UPDATE_MASK   MASK = 0x0F << 12 //+ Update Mask Bits Immediately
	UPDATE_MASK_0 MASK = 0x00 << 12 //  Normal operation. MASK* bits within the corresponding submodule are not updated until a FORCE_OUT event occurs within the submodule.
	UPDATE_MASK_1 MASK = 0x01 << 12 //  Immediate operation. MASK* bits within the corresponding submodule are updated on the following clock edge after setting this bit.
)

const (
	MASKXn       = 0
	MASKBn       = 4
	MASKAn       = 8
	UPDATE_MASKn = 12
)

const (
	SM0OUT45 SWCOUT = 0x01 << 0 //+ Submodule 0 Software Controlled Output 45
	SM0OUT23 SWCOUT = 0x01 << 1 //+ Submodule 0 Software Controlled Output 23
	SM1OUT45 SWCOUT = 0x01 << 2 //+ Submodule 1 Software Controlled Output 45
	SM1OUT23 SWCOUT = 0x01 << 3 //+ Submodule 1 Software Controlled Output 23
	SM2OUT45 SWCOUT = 0x01 << 4 //+ Submodule 2 Software Controlled Output 45
	SM2OUT23 SWCOUT = 0x01 << 5 //+ Submodule 2 Software Controlled Output 23
	SM3OUT45 SWCOUT = 0x01 << 6 //+ Submodule 3 Software Controlled Output 45
	SM3OUT23 SWCOUT = 0x01 << 7 //+ Submodule 3 Software Controlled Output 23
)

const (
	SM0OUT45n = 0
	SM0OUT23n = 1
	SM1OUT45n = 2
	SM1OUT23n = 3
	SM2OUT45n = 4
	SM2OUT23n = 5
	SM3OUT45n = 6
	SM3OUT23n = 7
)

const (
	SM0SEL45   DTSRCSEL = 0x03 << 0  //+ Submodule 0 PWM45 Control Select
	SM0SEL45_0 DTSRCSEL = 0x00 << 0  //  Generated SM0PWM45 signal is used by the deadtime logic.
	SM0SEL45_1 DTSRCSEL = 0x01 << 0  //  Inverted generated SM0PWM45 signal is used by the deadtime logic.
	SM0SEL45_2 DTSRCSEL = 0x02 << 0  //  SWCOUT[SM0OUT45] is used by the deadtime logic.
	SM0SEL45_3 DTSRCSEL = 0x03 << 0  //  PWM0_EXTB signal is used by the deadtime logic.
	SM0SEL23   DTSRCSEL = 0x03 << 2  //+ Submodule 0 PWM23 Control Select
	SM0SEL23_0 DTSRCSEL = 0x00 << 2  //  Generated SM0PWM23 signal is used by the deadtime logic.
	SM0SEL23_1 DTSRCSEL = 0x01 << 2  //  Inverted generated SM0PWM23 signal is used by the deadtime logic.
	SM0SEL23_2 DTSRCSEL = 0x02 << 2  //  SWCOUT[SM0OUT23] is used by the deadtime logic.
	SM0SEL23_3 DTSRCSEL = 0x03 << 2  //  PWM0_EXTA signal is used by the deadtime logic.
	SM1SEL45   DTSRCSEL = 0x03 << 4  //+ Submodule 1 PWM45 Control Select
	SM1SEL45_0 DTSRCSEL = 0x00 << 4  //  Generated SM1PWM45 signal is used by the deadtime logic.
	SM1SEL45_1 DTSRCSEL = 0x01 << 4  //  Inverted generated SM1PWM45 signal is used by the deadtime logic.
	SM1SEL45_2 DTSRCSEL = 0x02 << 4  //  SWCOUT[SM1OUT45] is used by the deadtime logic.
	SM1SEL45_3 DTSRCSEL = 0x03 << 4  //  PWM1_EXTB signal is used by the deadtime logic.
	SM1SEL23   DTSRCSEL = 0x03 << 6  //+ Submodule 1 PWM23 Control Select
	SM1SEL23_0 DTSRCSEL = 0x00 << 6  //  Generated SM1PWM23 signal is used by the deadtime logic.
	SM1SEL23_1 DTSRCSEL = 0x01 << 6  //  Inverted generated SM1PWM23 signal is used by the deadtime logic.
	SM1SEL23_2 DTSRCSEL = 0x02 << 6  //  SWCOUT[SM1OUT23] is used by the deadtime logic.
	SM1SEL23_3 DTSRCSEL = 0x03 << 6  //  PWM1_EXTA signal is used by the deadtime logic.
	SM2SEL45   DTSRCSEL = 0x03 << 8  //+ Submodule 2 PWM45 Control Select
	SM2SEL45_0 DTSRCSEL = 0x00 << 8  //  Generated SM2PWM45 signal is used by the deadtime logic.
	SM2SEL45_1 DTSRCSEL = 0x01 << 8  //  Inverted generated SM2PWM45 signal is used by the deadtime logic.
	SM2SEL45_2 DTSRCSEL = 0x02 << 8  //  SWCOUT[SM2OUT45] is used by the deadtime logic.
	SM2SEL45_3 DTSRCSEL = 0x03 << 8  //  PWM2_EXTB signal is used by the deadtime logic.
	SM2SEL23   DTSRCSEL = 0x03 << 10 //+ Submodule 2 PWM23 Control Select
	SM2SEL23_0 DTSRCSEL = 0x00 << 10 //  Generated SM2PWM23 signal is used by the deadtime logic.
	SM2SEL23_1 DTSRCSEL = 0x01 << 10 //  Inverted generated SM2PWM23 signal is used by the deadtime logic.
	SM2SEL23_2 DTSRCSEL = 0x02 << 10 //  SWCOUT[SM2OUT23] is used by the deadtime logic.
	SM2SEL23_3 DTSRCSEL = 0x03 << 10 //  PWM2_EXTA signal is used by the deadtime logic.
	SM3SEL45   DTSRCSEL = 0x03 << 12 //+ Submodule 3 PWM45 Control Select
	SM3SEL45_0 DTSRCSEL = 0x00 << 12 //  Generated SM3PWM45 signal is used by the deadtime logic.
	SM3SEL45_1 DTSRCSEL = 0x01 << 12 //  Inverted generated SM3PWM45 signal is used by the deadtime logic.
	SM3SEL45_2 DTSRCSEL = 0x02 << 12 //  SWCOUT[SM3OUT45] is used by the deadtime logic.
	SM3SEL45_3 DTSRCSEL = 0x03 << 12 //  PWM3_EXTB signal is used by the deadtime logic.
	SM3SEL23   DTSRCSEL = 0x03 << 14 //+ Submodule 3 PWM23 Control Select
	SM3SEL23_0 DTSRCSEL = 0x00 << 14 //  Generated SM3PWM23 signal is used by the deadtime logic.
	SM3SEL23_1 DTSRCSEL = 0x01 << 14 //  Inverted generated SM3PWM23 signal is used by the deadtime logic.
	SM3SEL23_2 DTSRCSEL = 0x02 << 14 //  SWCOUT[SM3OUT23] is used by the deadtime logic.
	SM3SEL23_3 DTSRCSEL = 0x03 << 14 //  PWM3_EXTA signal is used by the deadtime logic.
)

const (
	SM0SEL45n = 0
	SM0SEL23n = 2
	SM1SEL45n = 4
	SM1SEL23n = 6
	SM2SEL45n = 8
	SM2SEL23n = 10
	SM3SEL45n = 12
	SM3SEL23n = 14
)

const (
	LDOK   MCTRL = 0x0F << 0  //+ Load Okay
	LDOK_0 MCTRL = 0x00 << 0  //  Do not load new values.
	LDOK_1 MCTRL = 0x01 << 0  //  Load prescaler, modulus, and PWM values of the corresponding submodule.
	CLDOK  MCTRL = 0x0F << 4  //+ Clear Load Okay
	RUN    MCTRL = 0x0F << 8  //+ Run
	RUN_0  MCTRL = 0x00 << 8  //  PWM generator is disabled in the corresponding submodule.
	RUN_1  MCTRL = 0x01 << 8  //  PWM generator is enabled in the corresponding submodule.
	IPOL   MCTRL = 0x0F << 12 //+ Current Polarity
	IPOL_0 MCTRL = 0x00 << 12 //  PWM23 is used to generate complementary PWM pair in the corresponding submodule.
	IPOL_1 MCTRL = 0x01 << 12 //  PWM45 is used to generate complementary PWM pair in the corresponding submodule.
)

const (
	LDOKn  = 0
	CLDOKn = 4
	RUNn   = 8
	IPOLn  = 12
)

const (
	MONPLL   MCTRL2 = 0x03 << 0 //+ Monitor PLL State
	MONPLL_0 MCTRL2 = 0x00 << 0 //  Not locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software.
	MONPLL_1 MCTRL2 = 0x01 << 0 //  Not locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems.
	MONPLL_2 MCTRL2 = 0x02 << 0 //  Locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software. These bits are write protected until the next reset.
	MONPLL_3 MCTRL2 = 0x03 << 0 //  Locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems. These bits are write protected until the next reset.
)

const (
	MONPLLn = 0
)

const (
	FIE     FCTRL0 = 0x0F << 0  //+ Fault Interrupt Enables
	FIE_0   FCTRL0 = 0x00 << 0  //  FAULTx CPU interrupt requests disabled.
	FIE_1   FCTRL0 = 0x01 << 0  //  FAULTx CPU interrupt requests enabled.
	FSAFE   FCTRL0 = 0x0F << 4  //+ Fault Safety Mode
	FSAFE_0 FCTRL0 = 0x00 << 4  //  Normal mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFPINx]. The PWM outputs disabled by this fault input will not be re-enabled until the actual FAULTx input signal de-asserts since the fault input will combinationally disable the PWM outputs (as programmed in DISMAPn).
	FSAFE_1 FCTRL0 = 0x01 << 4  //  Safe mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL].
	FAUTO   FCTRL0 = 0x0F << 8  //+ Automatic Fault Clearing
	FAUTO_0 FCTRL0 = 0x00 << 8  //  Manual fault clearing. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending the state of FSTS[FFULL]. This is further controlled by FCTRL[FSAFE].
	FAUTO_1 FCTRL0 = 0x01 << 8  //  Automatic fault clearing. PWM outputs disabled by this fault are enabled when FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFLAGx].
	FLVL    FCTRL0 = 0x0F << 12 //+ Fault Level
	FLVL_0  FCTRL0 = 0x00 << 12 //  A logic 0 on the fault input indicates a fault condition.
	FLVL_1  FCTRL0 = 0x01 << 12 //  A logic 1 on the fault input indicates a fault condition.
)

const (
	FIEn   = 0
	FSAFEn = 4
	FAUTOn = 8
	FLVLn  = 12
)

const (
	FFLAG   FSTS0 = 0x0F << 0  //+ Fault Flags
	FFLAG_0 FSTS0 = 0x00 << 0  //  No fault on the FAULTx pin.
	FFLAG_1 FSTS0 = 0x01 << 0  //  Fault on the FAULTx pin.
	FFULL   FSTS0 = 0x0F << 4  //+ Full Cycle
	FFULL_0 FSTS0 = 0x00 << 4  //  PWM outputs are not re-enabled at the start of a full cycle
	FFULL_1 FSTS0 = 0x01 << 4  //  PWM outputs are re-enabled at the start of a full cycle
	FFPIN   FSTS0 = 0x0F << 8  //+ Filtered Fault Pins
	FHALF   FSTS0 = 0x0F << 12 //+ Half Cycle Fault Recovery
	FHALF_0 FSTS0 = 0x00 << 12 //  PWM outputs are not re-enabled at the start of a half cycle.
	FHALF_1 FSTS0 = 0x01 << 12 //  PWM outputs are re-enabled at the start of a half cycle (as defined by VAL0).
)

const (
	FFLAGn = 0
	FFULLn = 4
	FFPINn = 8
	FHALFn = 12
)

const (
	FILT_PER FFILT0 = 0xFF << 0  //+ Fault Filter Period
	FILT_CNT FFILT0 = 0x07 << 8  //+ Fault Filter Count
	GSTR     FFILT0 = 0x01 << 15 //+ Fault Glitch Stretch Enable
)

const (
	FILT_PERn = 0
	FILT_CNTn = 8
	GSTRn     = 15
)

const (
	FTEST FTST0 = 0x01 << 0 //+ Fault Test
)

const (
	FTESTn = 0
)

const (
	NOCOMB   FCTRL20 = 0x0F << 0 //+ No Combinational Path From Fault Input To PWM Output
	NOCOMB_0 FCTRL20 = 0x00 << 0 //  There is a combinational link from the fault inputs to the PWM outputs. The fault inputs are combined with the filtered and latched fault signals to disable the PWM outputs.
	NOCOMB_1 FCTRL20 = 0x01 << 0 //  The direct combinational path from the fault inputs to the PWM outputs is disabled and the filtered and latched fault signals are used to disable the PWM outputs.
)

const (
	NOCOMBn = 0
)
