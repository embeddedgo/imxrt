// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build imxrt1060

package ocotp

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	CTRL           mmio.R32[CTRL]
	CTRL_SET       mmio.R32[CTRL]
	CTRL_CLR       mmio.R32[CTRL]
	CTRL_TOG       mmio.R32[CTRL]
	TIMING         mmio.R32[TIMING]
	_              [3]uint32
	DATA           mmio.R32[uint32]
	_              [3]uint32
	READ_CTRL      mmio.R32[READ_CTRL]
	_              [3]uint32
	READ_FUSE_DATA mmio.R32[uint32]
	_              [3]uint32
	SW_STICKY      mmio.R32[SW_STICKY]
	_              [3]uint32
	SCS            mmio.R32[SCS]
	SCS_SET        mmio.R32[SCS]
	SCS_CLR        mmio.R32[SCS]
	SCS_TOG        mmio.R32[SCS]
	CRC_ADDR       mmio.R32[CRC_ADDR]
	_              [3]uint32
	CRC_VALUE      mmio.R32[uint32]
	_              [3]uint32
	VERSION        mmio.R32[VERSION]
	_              [27]uint32
	TIMING2        mmio.R32[TIMING2]
	_              [191]uint32
	LOCK           mmio.R32[LOCK]
	_              [3]uint32
	CFG            [7]mmio.R32[uint32]
	_              [21]uint32
	MEM            [5]mmio.R32[uint32]
	_              [15]uint32
	ANA            [3]mmio.R32[uint32]
	_              [9]uint32
	OTPMK          [8]mmio.R32[uint32]
	_              [24]uint32
	SRK            [8]mmio.R32[uint32]
	_              [24]uint32
	SJC_RESP       [2]mmio.R32[uint32]
	_              [6]uint32
	MAC            [3]mmio.R32[uint32]
	_              [9]uint32
	OTPMK_CRC32    mmio.R32[uint32]
	_              [3]uint32
	GP1            mmio.R32[uint32]
	_              [3]uint32
	GP2            mmio.R32[uint32]
	_              [3]uint32
	SW_GP1         mmio.R32[uint32]
	_              [3]uint32
	SW_GP2         [4]mmio.R32[uint32]
	_              [12]uint32
	MISC_CONF      [2]mmio.R32[uint32]
	_              [6]uint32
	SRK_REVOKE     mmio.R32[uint32]
	_              [67]uint32
	ROM_PATCH      [8]mmio.R32[uint32]
	_              [24]uint32
	GP3            [4]mmio.R32[uint32]
	_              [12]uint32
	GP4            [4]mmio.R32[uint32]
}

func OCOTP() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.OCOTP_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type CTRL uint32

func ADDR_(p *Periph) mmio.RM32[CTRL]           { return mmio.RM32[CTRL]{&p.CTRL, ADDR} }
func BUSY_(p *Periph) mmio.RM32[CTRL]           { return mmio.RM32[CTRL]{&p.CTRL, BUSY} }
func ERROR_(p *Periph) mmio.RM32[CTRL]          { return mmio.RM32[CTRL]{&p.CTRL, ERROR} }
func RELOAD_SHADOWS_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CTRL, RELOAD_SHADOWS} }
func CRC_TEST_(p *Periph) mmio.RM32[CTRL]       { return mmio.RM32[CTRL]{&p.CTRL, CRC_TEST} }
func CRC_FAIL_(p *Periph) mmio.RM32[CTRL]       { return mmio.RM32[CTRL]{&p.CTRL, CRC_FAIL} }
func WR_UNLOCK_(p *Periph) mmio.RM32[CTRL]      { return mmio.RM32[CTRL]{&p.CTRL, WR_UNLOCK} }

type TIMING uint32

func STROBE_PROG_(p *Periph) mmio.RM32[TIMING] { return mmio.RM32[TIMING]{&p.TIMING, STROBE_PROG} }
func RELAX_(p *Periph) mmio.RM32[TIMING]       { return mmio.RM32[TIMING]{&p.TIMING, RELAX} }
func STROBE_READ_(p *Periph) mmio.RM32[TIMING] { return mmio.RM32[TIMING]{&p.TIMING, STROBE_READ} }
func WAIT_(p *Periph) mmio.RM32[TIMING]        { return mmio.RM32[TIMING]{&p.TIMING, WAIT} }

type READ_CTRL uint32

func READ_FUSE_(p *Periph) mmio.RM32[READ_CTRL] { return mmio.RM32[READ_CTRL]{&p.READ_CTRL, READ_FUSE} }

type SW_STICKY uint32

func BLOCK_DTCP_KEY_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{&p.SW_STICKY, BLOCK_DTCP_KEY}
}
func SRK_REVOKE_LOCK_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{&p.SW_STICKY, SRK_REVOKE_LOCK}
}
func FIELD_RETURN_LOCK_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{&p.SW_STICKY, FIELD_RETURN_LOCK}
}
func BLOCK_ROM_PART_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{&p.SW_STICKY, BLOCK_ROM_PART}
}
func JTAG_BLOCK_RELEASE_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{&p.SW_STICKY, JTAG_BLOCK_RELEASE}
}

type SCS uint32

func HAB_JDE_(p *Periph) mmio.RM32[SCS] { return mmio.RM32[SCS]{&p.SCS, HAB_JDE} }
func SPARE_(p *Periph) mmio.RM32[SCS]   { return mmio.RM32[SCS]{&p.SCS, SPARE} }
func LCK_(p *Periph) mmio.RM32[SCS]     { return mmio.RM32[SCS]{&p.SCS, LCK} }

type CRC_ADDR uint32

func DATA_START_ADDR_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{&p.CRC_ADDR, DATA_START_ADDR}
}
func DATA_END_ADDR_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{&p.CRC_ADDR, DATA_END_ADDR}
}
func ADDR_CRC_(p *Periph) mmio.RM32[CRC_ADDR]  { return mmio.RM32[CRC_ADDR]{&p.CRC_ADDR, ADDR_CRC} }
func OTPMK_CRC_(p *Periph) mmio.RM32[CRC_ADDR] { return mmio.RM32[CRC_ADDR]{&p.CRC_ADDR, OTPMK_CRC} }

type VERSION uint32

func STEP_(p *Periph) mmio.RM32[VERSION]  { return mmio.RM32[VERSION]{&p.VERSION, STEP} }
func MINOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{&p.VERSION, MINOR} }
func MAJOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{&p.VERSION, MAJOR} }

type TIMING2 uint32

func RELAX_PROG_(p *Periph) mmio.RM32[TIMING2] { return mmio.RM32[TIMING2]{&p.TIMING2, RELAX_PROG} }
func RELAX_READ_(p *Periph) mmio.RM32[TIMING2] { return mmio.RM32[TIMING2]{&p.TIMING2, RELAX_READ} }

type LOCK uint32

func TESTER_LCK_(p *Periph) mmio.RM32[LOCK]       { return mmio.RM32[LOCK]{&p.LOCK, TESTER_LCK} }
func BOOT_CFG_LCK_(p *Periph) mmio.RM32[LOCK]     { return mmio.RM32[LOCK]{&p.LOCK, BOOT_CFG_LCK} }
func MEM_TRIM_LCK_(p *Periph) mmio.RM32[LOCK]     { return mmio.RM32[LOCK]{&p.LOCK, MEM_TRIM_LCK} }
func SJC_RESP_LCK_(p *Periph) mmio.RM32[LOCK]     { return mmio.RM32[LOCK]{&p.LOCK, SJC_RESP_LCK} }
func GP4_R_LCK_(p *Periph) mmio.RM32[LOCK]        { return mmio.RM32[LOCK]{&p.LOCK, GP4_R_LCK} }
func MAC_ADDR_LCK_(p *Periph) mmio.RM32[LOCK]     { return mmio.RM32[LOCK]{&p.LOCK, MAC_ADDR_LCK} }
func GP1_LCK_(p *Periph) mmio.RM32[LOCK]          { return mmio.RM32[LOCK]{&p.LOCK, GP1_LCK} }
func GP2_LCK_(p *Periph) mmio.RM32[LOCK]          { return mmio.RM32[LOCK]{&p.LOCK, GP2_LCK} }
func ROM_PATCH_LCK_(p *Periph) mmio.RM32[LOCK]    { return mmio.RM32[LOCK]{&p.LOCK, ROM_PATCH_LCK} }
func SW_GP1_LCK_(p *Periph) mmio.RM32[LOCK]       { return mmio.RM32[LOCK]{&p.LOCK, SW_GP1_LCK} }
func OTPMK_LCK_(p *Periph) mmio.RM32[LOCK]        { return mmio.RM32[LOCK]{&p.LOCK, OTPMK_LCK} }
func ANALOG_LCK_(p *Periph) mmio.RM32[LOCK]       { return mmio.RM32[LOCK]{&p.LOCK, ANALOG_LCK} }
func OTPMK_CRC_LCK_(p *Periph) mmio.RM32[LOCK]    { return mmio.RM32[LOCK]{&p.LOCK, OTPMK_CRC_LCK} }
func SW_GP2__LCK_(p *Periph) mmio.RM32[LOCK]      { return mmio.RM32[LOCK]{&p.LOCK, SW_GP2__LCK} }
func MISC_CONF_LCK_(p *Periph) mmio.RM32[LOCK]    { return mmio.RM32[LOCK]{&p.LOCK, MISC_CONF_LCK} }
func SW_GP2_R_LCK_(p *Periph) mmio.RM32[LOCK]     { return mmio.RM32[LOCK]{&p.LOCK, SW_GP2_R_LCK} }
func GP4_LCK_(p *Periph) mmio.RM32[LOCK]          { return mmio.RM32[LOCK]{&p.LOCK, GP4_LCK} }
func GP3_LCK_(p *Periph) mmio.RM32[LOCK]          { return mmio.RM32[LOCK]{&p.LOCK, GP3_LCK} }
func FIELD_RETURN_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{&p.LOCK, FIELD_RETURN_LCK} }
