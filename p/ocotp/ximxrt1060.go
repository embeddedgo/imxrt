// Code generated by xgen -g; DO NOT EDIT.

//go:build imxrt1060

package ocotp

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	CTRL           mmio.R32[CTRL]
	CTRL_SET       mmio.R32[CTRL]
	CTRL_CLR       mmio.R32[CTRL]
	CTRL_TOG       mmio.R32[CTRL]
	TIMING         mmio.R32[TIMING]
	_              [3]uint32
	DATA           mmio.R32[uint32]
	_              [3]uint32
	READ_CTRL      mmio.R32[READ_CTRL]
	_              [3]uint32
	READ_FUSE_DATA mmio.R32[uint32]
	_              [3]uint32
	SW_STICKY      mmio.R32[SW_STICKY]
	_              [3]uint32
	SCS            mmio.R32[SCS]
	SCS_SET        mmio.R32[SCS]
	SCS_CLR        mmio.R32[SCS]
	SCS_TOG        mmio.R32[SCS]
	CRC_ADDR       mmio.R32[CRC_ADDR]
	_              [3]uint32
	CRC_VALUE      mmio.R32[uint32]
	_              [3]uint32
	VERSION        mmio.R32[VERSION]
	_              [27]uint32
	TIMING2        mmio.R32[TIMING2]
	_              [191]uint32
	LOCK           mmio.R32[LOCK]
	_              [3]uint32
	CFG            [7]mmio.R32[uint32]
	_              [21]uint32
	MEM            [5]mmio.R32[uint32]
	_              [15]uint32
	ANA            [3]mmio.R32[uint32]
	_              [9]uint32
	OTPMK          [8]mmio.R32[uint32]
	_              [24]uint32
	SRK            [8]mmio.R32[uint32]
	_              [24]uint32
	SJC_RESP       [2]mmio.R32[uint32]
	_              [6]uint32
	MAC            [3]mmio.R32[uint32]
	_              [9]uint32
	OTPMK_CRC32    mmio.R32[uint32]
	_              [3]uint32
	GP1            mmio.R32[uint32]
	_              [3]uint32
	GP2            mmio.R32[uint32]
	_              [3]uint32
	SW_GP1         mmio.R32[uint32]
	_              [3]uint32
	SW_GP2         [4]mmio.R32[uint32]
	_              [12]uint32
	MISC_CONF      [2]mmio.R32[uint32]
	_              [6]uint32
	SRK_REVOKE     mmio.R32[uint32]
	_              [67]uint32
	ROM_PATCH      [8]mmio.R32[uint32]
	_              [24]uint32
	GP3            [4]mmio.R32[uint32]
	_              [12]uint32
	GP4            [4]mmio.R32[uint32]
}

func OCOTP() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.OCOTP_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type CTRL uint32

func ADDR_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ADDR} }
func BUSY_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: BUSY} }
func ERROR_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: ERROR} }
func RELOAD_SHADOWS_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: RELOAD_SHADOWS}
}
func CRC_TEST_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: CRC_TEST} }
func CRC_FAIL_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: CRC_FAIL} }
func WR_UNLOCK_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: WR_UNLOCK} }

type TIMING uint32

func STROBE_PROG_(p *Periph) mmio.RM32[TIMING] {
	return mmio.RM32[TIMING]{R: &p.TIMING, Mask: STROBE_PROG}
}
func RELAX_(p *Periph) mmio.RM32[TIMING] { return mmio.RM32[TIMING]{R: &p.TIMING, Mask: RELAX} }
func STROBE_READ_(p *Periph) mmio.RM32[TIMING] {
	return mmio.RM32[TIMING]{R: &p.TIMING, Mask: STROBE_READ}
}
func WAIT_(p *Periph) mmio.RM32[TIMING] { return mmio.RM32[TIMING]{R: &p.TIMING, Mask: WAIT} }

type READ_CTRL uint32

func READ_FUSE_(p *Periph) mmio.RM32[READ_CTRL] {
	return mmio.RM32[READ_CTRL]{R: &p.READ_CTRL, Mask: READ_FUSE}
}

type SW_STICKY uint32

func BLOCK_DTCP_KEY_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{R: &p.SW_STICKY, Mask: BLOCK_DTCP_KEY}
}
func SRK_REVOKE_LOCK_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{R: &p.SW_STICKY, Mask: SRK_REVOKE_LOCK}
}
func FIELD_RETURN_LOCK_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{R: &p.SW_STICKY, Mask: FIELD_RETURN_LOCK}
}
func BLOCK_ROM_PART_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{R: &p.SW_STICKY, Mask: BLOCK_ROM_PART}
}
func JTAG_BLOCK_RELEASE_(p *Periph) mmio.RM32[SW_STICKY] {
	return mmio.RM32[SW_STICKY]{R: &p.SW_STICKY, Mask: JTAG_BLOCK_RELEASE}
}

type SCS uint32

func HAB_JDE_(p *Periph) mmio.RM32[SCS] { return mmio.RM32[SCS]{R: &p.SCS, Mask: HAB_JDE} }
func SPARE_(p *Periph) mmio.RM32[SCS]   { return mmio.RM32[SCS]{R: &p.SCS, Mask: SPARE} }
func LCK_(p *Periph) mmio.RM32[SCS]     { return mmio.RM32[SCS]{R: &p.SCS, Mask: LCK} }

type CRC_ADDR uint32

func DATA_START_ADDR_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{R: &p.CRC_ADDR, Mask: DATA_START_ADDR}
}
func DATA_END_ADDR_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{R: &p.CRC_ADDR, Mask: DATA_END_ADDR}
}
func ADDR_CRC_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{R: &p.CRC_ADDR, Mask: ADDR_CRC}
}
func OTPMK_CRC_(p *Periph) mmio.RM32[CRC_ADDR] {
	return mmio.RM32[CRC_ADDR]{R: &p.CRC_ADDR, Mask: OTPMK_CRC}
}

type VERSION uint32

func STEP_(p *Periph) mmio.RM32[VERSION]  { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: STEP} }
func MINOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: MINOR} }
func MAJOR_(p *Periph) mmio.RM32[VERSION] { return mmio.RM32[VERSION]{R: &p.VERSION, Mask: MAJOR} }

type TIMING2 uint32

func RELAX_PROG_(p *Periph) mmio.RM32[TIMING2] {
	return mmio.RM32[TIMING2]{R: &p.TIMING2, Mask: RELAX_PROG}
}
func RELAX_READ_(p *Periph) mmio.RM32[TIMING2] {
	return mmio.RM32[TIMING2]{R: &p.TIMING2, Mask: RELAX_READ}
}

type LOCK uint32

func TESTER_LCK_(p *Periph) mmio.RM32[LOCK]   { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: TESTER_LCK} }
func BOOT_CFG_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: BOOT_CFG_LCK} }
func MEM_TRIM_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: MEM_TRIM_LCK} }
func SJC_RESP_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: SJC_RESP_LCK} }
func GP4_R_LCK_(p *Periph) mmio.RM32[LOCK]    { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: GP4_R_LCK} }
func MAC_ADDR_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: MAC_ADDR_LCK} }
func GP1_LCK_(p *Periph) mmio.RM32[LOCK]      { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: GP1_LCK} }
func GP2_LCK_(p *Periph) mmio.RM32[LOCK]      { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: GP2_LCK} }
func ROM_PATCH_LCK_(p *Periph) mmio.RM32[LOCK] {
	return mmio.RM32[LOCK]{R: &p.LOCK, Mask: ROM_PATCH_LCK}
}
func SW_GP1_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: SW_GP1_LCK} }
func OTPMK_LCK_(p *Periph) mmio.RM32[LOCK]  { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: OTPMK_LCK} }
func ANALOG_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: ANALOG_LCK} }
func OTPMK_CRC_LCK_(p *Periph) mmio.RM32[LOCK] {
	return mmio.RM32[LOCK]{R: &p.LOCK, Mask: OTPMK_CRC_LCK}
}
func SW_GP2__LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: SW_GP2__LCK} }
func MISC_CONF_LCK_(p *Periph) mmio.RM32[LOCK] {
	return mmio.RM32[LOCK]{R: &p.LOCK, Mask: MISC_CONF_LCK}
}
func SW_GP2_R_LCK_(p *Periph) mmio.RM32[LOCK] { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: SW_GP2_R_LCK} }
func GP4_LCK_(p *Periph) mmio.RM32[LOCK]      { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: GP4_LCK} }
func GP3_LCK_(p *Periph) mmio.RM32[LOCK]      { return mmio.RM32[LOCK]{R: &p.LOCK, Mask: GP3_LCK} }
func FIELD_RETURN_LCK_(p *Periph) mmio.RM32[LOCK] {
	return mmio.RM32[LOCK]{R: &p.LOCK, Mask: FIELD_RETURN_LCK}
}
