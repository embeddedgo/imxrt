// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package dma provides access to the registers of the DMA peripheral.
//
// Instances:
//  DMA0  DMA0_BASE  -  DMA0_DMA16*,DMA1_DMA17*,DMA2_DMA18*,DMA3_DMA19*,DMA4_DMA20*,DMA5_DMA21*,DMA6_DMA22*,DMA7_DMA23*,DMA8_DMA24*,DMA9_DMA25*,DMA10_DMA26*,DMA11_DMA27*,DMA12_DMA28*,DMA13_DMA29*,DMA14_DMA30*,DMA15_DMA31*,DMA_ERROR*
// Registers:
//  0x000  32  CR                     Control Register
//  0x004  32  ES                     Error Status Register
//  0x00C  32  ERQ                    Enable Request Register
//  0x014  32  EEI                    Enable Error Interrupt Register
//  0x018   8  CEEI                   Clear Enable Error Interrupt Register
//  0x019   8  SEEI                   Set Enable Error Interrupt Register
//  0x01A   8  CERQ                   Clear Enable Request Register
//  0x01B   8  SERQ                   Set Enable Request Register
//  0x01C   8  CDNE                   Clear DONE Status Bit Register
//  0x01D   8  SSRT                   Set START Bit Register
//  0x01E   8  CERR                   Clear Error Register
//  0x01F   8  CINT                   Clear Interrupt Request Register
//  0x024  32  INT                    Interrupt Request Register
//  0x02C  32  ERR                    Error Register
//  0x034  32  HRS                    Hardware Request Status Register
//  0x044  32  EARS                   Enable Asynchronous Request in Stop Register
//  0x100   8  DCHPRI3                Channel n Priority Register
//  0x101   8  DCHPRI2                Channel n Priority Register
//  0x102   8  DCHPRI1                Channel n Priority Register
//  0x103   8  DCHPRI0                Channel n Priority Register
//  0x104   8  DCHPRI7                Channel n Priority Register
//  0x105   8  DCHPRI6                Channel n Priority Register
//  0x106   8  DCHPRI5                Channel n Priority Register
//  0x107   8  DCHPRI4                Channel n Priority Register
//  0x108   8  DCHPRI11               Channel n Priority Register
//  0x109   8  DCHPRI10               Channel n Priority Register
//  0x10A   8  DCHPRI9                Channel n Priority Register
//  0x10B   8  DCHPRI8                Channel n Priority Register
//  0x10C   8  DCHPRI15               Channel n Priority Register
//  0x10D   8  DCHPRI14               Channel n Priority Register
//  0x10E   8  DCHPRI13               Channel n Priority Register
//  0x10F   8  DCHPRI12               Channel n Priority Register
//  0x110   8  DCHPRI19               Channel n Priority Register
//  0x111   8  DCHPRI18               Channel n Priority Register
//  0x112   8  DCHPRI17               Channel n Priority Register
//  0x113   8  DCHPRI16               Channel n Priority Register
//  0x114   8  DCHPRI23               Channel n Priority Register
//  0x115   8  DCHPRI22               Channel n Priority Register
//  0x116   8  DCHPRI21               Channel n Priority Register
//  0x117   8  DCHPRI20               Channel n Priority Register
//  0x118   8  DCHPRI27               Channel n Priority Register
//  0x119   8  DCHPRI26               Channel n Priority Register
//  0x11A   8  DCHPRI25               Channel n Priority Register
//  0x11B   8  DCHPRI24               Channel n Priority Register
//  0x11C   8  DCHPRI31               Channel n Priority Register
//  0x11D   8  DCHPRI30               Channel n Priority Register
//  0x11E   8  DCHPRI29               Channel n Priority Register
//  0x11F   8  DCHPRI28               Channel n Priority Register
//  0x1000 32  TCD0_SADDR             TCD Source Address
//  0x1004 16  TCD0_SOFF              TCD Signed Source Address Offset
//  0x1006 16  TCD0_ATTR              TCD Transfer Attributes
//  0x1008 32  TCD0_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1008 32  TCD0_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1008 32  TCD0_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x100C 32  TCD0_SLAST             TCD Last Source Address Adjustment
//  0x1010 32  TCD0_DADDR             TCD Destination Address
//  0x1014 16  TCD0_DOFF              TCD Signed Destination Address Offset
//  0x1016 16  TCD0_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1016 16  TCD0_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1018 32  TCD0_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x101C 16  TCD0_CSR               TCD Control and Status
//  0x101E 16  TCD0_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x101E 16  TCD0_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1020 32  TCD1_SADDR             TCD Source Address
//  0x1024 16  TCD1_SOFF              TCD Signed Source Address Offset
//  0x1026 16  TCD1_ATTR              TCD Transfer Attributes
//  0x1028 32  TCD1_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1028 32  TCD1_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1028 32  TCD1_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x102C 32  TCD1_SLAST             TCD Last Source Address Adjustment
//  0x1030 32  TCD1_DADDR             TCD Destination Address
//  0x1034 16  TCD1_DOFF              TCD Signed Destination Address Offset
//  0x1036 16  TCD1_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1036 16  TCD1_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1038 32  TCD1_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x103C 16  TCD1_CSR               TCD Control and Status
//  0x103E 16  TCD1_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x103E 16  TCD1_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1040 32  TCD2_SADDR             TCD Source Address
//  0x1044 16  TCD2_SOFF              TCD Signed Source Address Offset
//  0x1046 16  TCD2_ATTR              TCD Transfer Attributes
//  0x1048 32  TCD2_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1048 32  TCD2_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1048 32  TCD2_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x104C 32  TCD2_SLAST             TCD Last Source Address Adjustment
//  0x1050 32  TCD2_DADDR             TCD Destination Address
//  0x1054 16  TCD2_DOFF              TCD Signed Destination Address Offset
//  0x1056 16  TCD2_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1056 16  TCD2_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1058 32  TCD2_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x105C 16  TCD2_CSR               TCD Control and Status
//  0x105E 16  TCD2_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x105E 16  TCD2_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1060 32  TCD3_SADDR             TCD Source Address
//  0x1064 16  TCD3_SOFF              TCD Signed Source Address Offset
//  0x1066 16  TCD3_ATTR              TCD Transfer Attributes
//  0x1068 32  TCD3_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1068 32  TCD3_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1068 32  TCD3_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x106C 32  TCD3_SLAST             TCD Last Source Address Adjustment
//  0x1070 32  TCD3_DADDR             TCD Destination Address
//  0x1074 16  TCD3_DOFF              TCD Signed Destination Address Offset
//  0x1076 16  TCD3_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1076 16  TCD3_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1078 32  TCD3_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x107C 16  TCD3_CSR               TCD Control and Status
//  0x107E 16  TCD3_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x107E 16  TCD3_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1080 32  TCD4_SADDR             TCD Source Address
//  0x1084 16  TCD4_SOFF              TCD Signed Source Address Offset
//  0x1086 16  TCD4_ATTR              TCD Transfer Attributes
//  0x1088 32  TCD4_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1088 32  TCD4_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1088 32  TCD4_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x108C 32  TCD4_SLAST             TCD Last Source Address Adjustment
//  0x1090 32  TCD4_DADDR             TCD Destination Address
//  0x1094 16  TCD4_DOFF              TCD Signed Destination Address Offset
//  0x1096 16  TCD4_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1096 16  TCD4_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1098 32  TCD4_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x109C 16  TCD4_CSR               TCD Control and Status
//  0x109E 16  TCD4_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x109E 16  TCD4_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10A0 32  TCD5_SADDR             TCD Source Address
//  0x10A4 16  TCD5_SOFF              TCD Signed Source Address Offset
//  0x10A6 16  TCD5_ATTR              TCD Transfer Attributes
//  0x10A8 32  TCD5_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10A8 32  TCD5_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10A8 32  TCD5_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10AC 32  TCD5_SLAST             TCD Last Source Address Adjustment
//  0x10B0 32  TCD5_DADDR             TCD Destination Address
//  0x10B4 16  TCD5_DOFF              TCD Signed Destination Address Offset
//  0x10B6 16  TCD5_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10B6 16  TCD5_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10B8 32  TCD5_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10BC 16  TCD5_CSR               TCD Control and Status
//  0x10BE 16  TCD5_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10BE 16  TCD5_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10C0 32  TCD6_SADDR             TCD Source Address
//  0x10C4 16  TCD6_SOFF              TCD Signed Source Address Offset
//  0x10C6 16  TCD6_ATTR              TCD Transfer Attributes
//  0x10C8 32  TCD6_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10C8 32  TCD6_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10C8 32  TCD6_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10CC 32  TCD6_SLAST             TCD Last Source Address Adjustment
//  0x10D0 32  TCD6_DADDR             TCD Destination Address
//  0x10D4 16  TCD6_DOFF              TCD Signed Destination Address Offset
//  0x10D6 16  TCD6_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10D6 16  TCD6_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10D8 32  TCD6_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10DC 16  TCD6_CSR               TCD Control and Status
//  0x10DE 16  TCD6_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10DE 16  TCD6_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10E0 32  TCD7_SADDR             TCD Source Address
//  0x10E4 16  TCD7_SOFF              TCD Signed Source Address Offset
//  0x10E6 16  TCD7_ATTR              TCD Transfer Attributes
//  0x10E8 32  TCD7_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10E8 32  TCD7_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10E8 32  TCD7_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10EC 32  TCD7_SLAST             TCD Last Source Address Adjustment
//  0x10F0 32  TCD7_DADDR             TCD Destination Address
//  0x10F4 16  TCD7_DOFF              TCD Signed Destination Address Offset
//  0x10F6 16  TCD7_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10F6 16  TCD7_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10F8 32  TCD7_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10FC 16  TCD7_CSR               TCD Control and Status
//  0x10FE 16  TCD7_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10FE 16  TCD7_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1100 32  TCD8_SADDR             TCD Source Address
//  0x1104 16  TCD8_SOFF              TCD Signed Source Address Offset
//  0x1106 16  TCD8_ATTR              TCD Transfer Attributes
//  0x1108 32  TCD8_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1108 32  TCD8_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1108 32  TCD8_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x110C 32  TCD8_SLAST             TCD Last Source Address Adjustment
//  0x1110 32  TCD8_DADDR             TCD Destination Address
//  0x1114 16  TCD8_DOFF              TCD Signed Destination Address Offset
//  0x1116 16  TCD8_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1116 16  TCD8_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1118 32  TCD8_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x111C 16  TCD8_CSR               TCD Control and Status
//  0x111E 16  TCD8_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x111E 16  TCD8_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1120 32  TCD9_SADDR             TCD Source Address
//  0x1124 16  TCD9_SOFF              TCD Signed Source Address Offset
//  0x1126 16  TCD9_ATTR              TCD Transfer Attributes
//  0x1128 32  TCD9_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1128 32  TCD9_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1128 32  TCD9_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x112C 32  TCD9_SLAST             TCD Last Source Address Adjustment
//  0x1130 32  TCD9_DADDR             TCD Destination Address
//  0x1134 16  TCD9_DOFF              TCD Signed Destination Address Offset
//  0x1136 16  TCD9_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1136 16  TCD9_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1138 32  TCD9_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x113C 16  TCD9_CSR               TCD Control and Status
//  0x113E 16  TCD9_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x113E 16  TCD9_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1140 32  TCD10_SADDR            TCD Source Address
//  0x1144 16  TCD10_SOFF             TCD Signed Source Address Offset
//  0x1146 16  TCD10_ATTR             TCD Transfer Attributes
//  0x1148 32  TCD10_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1148 32  TCD10_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1148 32  TCD10_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x114C 32  TCD10_SLAST            TCD Last Source Address Adjustment
//  0x1150 32  TCD10_DADDR            TCD Destination Address
//  0x1154 16  TCD10_DOFF             TCD Signed Destination Address Offset
//  0x1156 16  TCD10_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1156 16  TCD10_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1158 32  TCD10_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x115C 16  TCD10_CSR              TCD Control and Status
//  0x115E 16  TCD10_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x115E 16  TCD10_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1160 32  TCD11_SADDR            TCD Source Address
//  0x1164 16  TCD11_SOFF             TCD Signed Source Address Offset
//  0x1166 16  TCD11_ATTR             TCD Transfer Attributes
//  0x1168 32  TCD11_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1168 32  TCD11_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1168 32  TCD11_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x116C 32  TCD11_SLAST            TCD Last Source Address Adjustment
//  0x1170 32  TCD11_DADDR            TCD Destination Address
//  0x1174 16  TCD11_DOFF             TCD Signed Destination Address Offset
//  0x1176 16  TCD11_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1176 16  TCD11_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1178 32  TCD11_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x117C 16  TCD11_CSR              TCD Control and Status
//  0x117E 16  TCD11_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x117E 16  TCD11_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1180 32  TCD12_SADDR            TCD Source Address
//  0x1184 16  TCD12_SOFF             TCD Signed Source Address Offset
//  0x1186 16  TCD12_ATTR             TCD Transfer Attributes
//  0x1188 32  TCD12_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1188 32  TCD12_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1188 32  TCD12_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x118C 32  TCD12_SLAST            TCD Last Source Address Adjustment
//  0x1190 32  TCD12_DADDR            TCD Destination Address
//  0x1194 16  TCD12_DOFF             TCD Signed Destination Address Offset
//  0x1196 16  TCD12_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1196 16  TCD12_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1198 32  TCD12_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x119C 16  TCD12_CSR              TCD Control and Status
//  0x119E 16  TCD12_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x119E 16  TCD12_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11A0 32  TCD13_SADDR            TCD Source Address
//  0x11A4 16  TCD13_SOFF             TCD Signed Source Address Offset
//  0x11A6 16  TCD13_ATTR             TCD Transfer Attributes
//  0x11A8 32  TCD13_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11A8 32  TCD13_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11A8 32  TCD13_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11AC 32  TCD13_SLAST            TCD Last Source Address Adjustment
//  0x11B0 32  TCD13_DADDR            TCD Destination Address
//  0x11B4 16  TCD13_DOFF             TCD Signed Destination Address Offset
//  0x11B6 16  TCD13_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11B6 16  TCD13_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11B8 32  TCD13_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11BC 16  TCD13_CSR              TCD Control and Status
//  0x11BE 16  TCD13_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11BE 16  TCD13_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11C0 32  TCD14_SADDR            TCD Source Address
//  0x11C4 16  TCD14_SOFF             TCD Signed Source Address Offset
//  0x11C6 16  TCD14_ATTR             TCD Transfer Attributes
//  0x11C8 32  TCD14_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11C8 32  TCD14_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11C8 32  TCD14_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11CC 32  TCD14_SLAST            TCD Last Source Address Adjustment
//  0x11D0 32  TCD14_DADDR            TCD Destination Address
//  0x11D4 16  TCD14_DOFF             TCD Signed Destination Address Offset
//  0x11D6 16  TCD14_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11D6 16  TCD14_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11D8 32  TCD14_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11DC 16  TCD14_CSR              TCD Control and Status
//  0x11DE 16  TCD14_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11DE 16  TCD14_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11E0 32  TCD15_SADDR            TCD Source Address
//  0x11E4 16  TCD15_SOFF             TCD Signed Source Address Offset
//  0x11E6 16  TCD15_ATTR             TCD Transfer Attributes
//  0x11E8 32  TCD15_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11E8 32  TCD15_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11E8 32  TCD15_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11EC 32  TCD15_SLAST            TCD Last Source Address Adjustment
//  0x11F0 32  TCD15_DADDR            TCD Destination Address
//  0x11F4 16  TCD15_DOFF             TCD Signed Destination Address Offset
//  0x11F6 16  TCD15_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11F6 16  TCD15_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11F8 32  TCD15_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11FC 16  TCD15_CSR              TCD Control and Status
//  0x11FE 16  TCD15_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11FE 16  TCD15_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1200 32  TCD16_SADDR            TCD Source Address
//  0x1204 16  TCD16_SOFF             TCD Signed Source Address Offset
//  0x1206 16  TCD16_ATTR             TCD Transfer Attributes
//  0x1208 32  TCD16_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1208 32  TCD16_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1208 32  TCD16_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x120C 32  TCD16_SLAST            TCD Last Source Address Adjustment
//  0x1210 32  TCD16_DADDR            TCD Destination Address
//  0x1214 16  TCD16_DOFF             TCD Signed Destination Address Offset
//  0x1216 16  TCD16_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1216 16  TCD16_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1218 32  TCD16_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x121C 16  TCD16_CSR              TCD Control and Status
//  0x121E 16  TCD16_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x121E 16  TCD16_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1220 32  TCD17_SADDR            TCD Source Address
//  0x1224 16  TCD17_SOFF             TCD Signed Source Address Offset
//  0x1226 16  TCD17_ATTR             TCD Transfer Attributes
//  0x1228 32  TCD17_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1228 32  TCD17_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1228 32  TCD17_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x122C 32  TCD17_SLAST            TCD Last Source Address Adjustment
//  0x1230 32  TCD17_DADDR            TCD Destination Address
//  0x1234 16  TCD17_DOFF             TCD Signed Destination Address Offset
//  0x1236 16  TCD17_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1236 16  TCD17_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1238 32  TCD17_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x123C 16  TCD17_CSR              TCD Control and Status
//  0x123E 16  TCD17_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x123E 16  TCD17_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1240 32  TCD18_SADDR            TCD Source Address
//  0x1244 16  TCD18_SOFF             TCD Signed Source Address Offset
//  0x1246 16  TCD18_ATTR             TCD Transfer Attributes
//  0x1248 32  TCD18_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1248 32  TCD18_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1248 32  TCD18_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x124C 32  TCD18_SLAST            TCD Last Source Address Adjustment
//  0x1250 32  TCD18_DADDR            TCD Destination Address
//  0x1254 16  TCD18_DOFF             TCD Signed Destination Address Offset
//  0x1256 16  TCD18_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1256 16  TCD18_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1258 32  TCD18_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x125C 16  TCD18_CSR              TCD Control and Status
//  0x125E 16  TCD18_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x125E 16  TCD18_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1260 32  TCD19_SADDR            TCD Source Address
//  0x1264 16  TCD19_SOFF             TCD Signed Source Address Offset
//  0x1266 16  TCD19_ATTR             TCD Transfer Attributes
//  0x1268 32  TCD19_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1268 32  TCD19_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1268 32  TCD19_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x126C 32  TCD19_SLAST            TCD Last Source Address Adjustment
//  0x1270 32  TCD19_DADDR            TCD Destination Address
//  0x1274 16  TCD19_DOFF             TCD Signed Destination Address Offset
//  0x1276 16  TCD19_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1276 16  TCD19_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1278 32  TCD19_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x127C 16  TCD19_CSR              TCD Control and Status
//  0x127E 16  TCD19_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x127E 16  TCD19_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1280 32  TCD20_SADDR            TCD Source Address
//  0x1284 16  TCD20_SOFF             TCD Signed Source Address Offset
//  0x1286 16  TCD20_ATTR             TCD Transfer Attributes
//  0x1288 32  TCD20_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1288 32  TCD20_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1288 32  TCD20_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x128C 32  TCD20_SLAST            TCD Last Source Address Adjustment
//  0x1290 32  TCD20_DADDR            TCD Destination Address
//  0x1294 16  TCD20_DOFF             TCD Signed Destination Address Offset
//  0x1296 16  TCD20_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1296 16  TCD20_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1298 32  TCD20_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x129C 16  TCD20_CSR              TCD Control and Status
//  0x129E 16  TCD20_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x129E 16  TCD20_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12A0 32  TCD21_SADDR            TCD Source Address
//  0x12A4 16  TCD21_SOFF             TCD Signed Source Address Offset
//  0x12A6 16  TCD21_ATTR             TCD Transfer Attributes
//  0x12A8 32  TCD21_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12A8 32  TCD21_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12A8 32  TCD21_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12AC 32  TCD21_SLAST            TCD Last Source Address Adjustment
//  0x12B0 32  TCD21_DADDR            TCD Destination Address
//  0x12B4 16  TCD21_DOFF             TCD Signed Destination Address Offset
//  0x12B6 16  TCD21_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12B6 16  TCD21_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12B8 32  TCD21_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12BC 16  TCD21_CSR              TCD Control and Status
//  0x12BE 16  TCD21_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12BE 16  TCD21_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12C0 32  TCD22_SADDR            TCD Source Address
//  0x12C4 16  TCD22_SOFF             TCD Signed Source Address Offset
//  0x12C6 16  TCD22_ATTR             TCD Transfer Attributes
//  0x12C8 32  TCD22_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12C8 32  TCD22_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12C8 32  TCD22_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12CC 32  TCD22_SLAST            TCD Last Source Address Adjustment
//  0x12D0 32  TCD22_DADDR            TCD Destination Address
//  0x12D4 16  TCD22_DOFF             TCD Signed Destination Address Offset
//  0x12D6 16  TCD22_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12D6 16  TCD22_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12D8 32  TCD22_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12DC 16  TCD22_CSR              TCD Control and Status
//  0x12DE 16  TCD22_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12DE 16  TCD22_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12E0 32  TCD23_SADDR            TCD Source Address
//  0x12E4 16  TCD23_SOFF             TCD Signed Source Address Offset
//  0x12E6 16  TCD23_ATTR             TCD Transfer Attributes
//  0x12E8 32  TCD23_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12E8 32  TCD23_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12E8 32  TCD23_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12EC 32  TCD23_SLAST            TCD Last Source Address Adjustment
//  0x12F0 32  TCD23_DADDR            TCD Destination Address
//  0x12F4 16  TCD23_DOFF             TCD Signed Destination Address Offset
//  0x12F6 16  TCD23_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12F6 16  TCD23_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12F8 32  TCD23_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12FC 16  TCD23_CSR              TCD Control and Status
//  0x12FE 16  TCD23_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12FE 16  TCD23_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1300 32  TCD24_SADDR            TCD Source Address
//  0x1304 16  TCD24_SOFF             TCD Signed Source Address Offset
//  0x1306 16  TCD24_ATTR             TCD Transfer Attributes
//  0x1308 32  TCD24_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1308 32  TCD24_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1308 32  TCD24_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x130C 32  TCD24_SLAST            TCD Last Source Address Adjustment
//  0x1310 32  TCD24_DADDR            TCD Destination Address
//  0x1314 16  TCD24_DOFF             TCD Signed Destination Address Offset
//  0x1316 16  TCD24_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1316 16  TCD24_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1318 32  TCD24_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x131C 16  TCD24_CSR              TCD Control and Status
//  0x131E 16  TCD24_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x131E 16  TCD24_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1320 32  TCD25_SADDR            TCD Source Address
//  0x1324 16  TCD25_SOFF             TCD Signed Source Address Offset
//  0x1326 16  TCD25_ATTR             TCD Transfer Attributes
//  0x1328 32  TCD25_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1328 32  TCD25_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1328 32  TCD25_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x132C 32  TCD25_SLAST            TCD Last Source Address Adjustment
//  0x1330 32  TCD25_DADDR            TCD Destination Address
//  0x1334 16  TCD25_DOFF             TCD Signed Destination Address Offset
//  0x1336 16  TCD25_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1336 16  TCD25_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1338 32  TCD25_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x133C 16  TCD25_CSR              TCD Control and Status
//  0x133E 16  TCD25_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x133E 16  TCD25_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1340 32  TCD26_SADDR            TCD Source Address
//  0x1344 16  TCD26_SOFF             TCD Signed Source Address Offset
//  0x1346 16  TCD26_ATTR             TCD Transfer Attributes
//  0x1348 32  TCD26_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1348 32  TCD26_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1348 32  TCD26_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x134C 32  TCD26_SLAST            TCD Last Source Address Adjustment
//  0x1350 32  TCD26_DADDR            TCD Destination Address
//  0x1354 16  TCD26_DOFF             TCD Signed Destination Address Offset
//  0x1356 16  TCD26_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1356 16  TCD26_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1358 32  TCD26_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x135C 16  TCD26_CSR              TCD Control and Status
//  0x135E 16  TCD26_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x135E 16  TCD26_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1360 32  TCD27_SADDR            TCD Source Address
//  0x1364 16  TCD27_SOFF             TCD Signed Source Address Offset
//  0x1366 16  TCD27_ATTR             TCD Transfer Attributes
//  0x1368 32  TCD27_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1368 32  TCD27_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1368 32  TCD27_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x136C 32  TCD27_SLAST            TCD Last Source Address Adjustment
//  0x1370 32  TCD27_DADDR            TCD Destination Address
//  0x1374 16  TCD27_DOFF             TCD Signed Destination Address Offset
//  0x1376 16  TCD27_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1376 16  TCD27_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1378 32  TCD27_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x137C 16  TCD27_CSR              TCD Control and Status
//  0x137E 16  TCD27_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x137E 16  TCD27_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1380 32  TCD28_SADDR            TCD Source Address
//  0x1384 16  TCD28_SOFF             TCD Signed Source Address Offset
//  0x1386 16  TCD28_ATTR             TCD Transfer Attributes
//  0x1388 32  TCD28_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1388 32  TCD28_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1388 32  TCD28_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x138C 32  TCD28_SLAST            TCD Last Source Address Adjustment
//  0x1390 32  TCD28_DADDR            TCD Destination Address
//  0x1394 16  TCD28_DOFF             TCD Signed Destination Address Offset
//  0x1396 16  TCD28_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1396 16  TCD28_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1398 32  TCD28_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x139C 16  TCD28_CSR              TCD Control and Status
//  0x139E 16  TCD28_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x139E 16  TCD28_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13A0 32  TCD29_SADDR            TCD Source Address
//  0x13A4 16  TCD29_SOFF             TCD Signed Source Address Offset
//  0x13A6 16  TCD29_ATTR             TCD Transfer Attributes
//  0x13A8 32  TCD29_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13A8 32  TCD29_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13A8 32  TCD29_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13AC 32  TCD29_SLAST            TCD Last Source Address Adjustment
//  0x13B0 32  TCD29_DADDR            TCD Destination Address
//  0x13B4 16  TCD29_DOFF             TCD Signed Destination Address Offset
//  0x13B6 16  TCD29_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13B6 16  TCD29_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13B8 32  TCD29_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13BC 16  TCD29_CSR              TCD Control and Status
//  0x13BE 16  TCD29_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13BE 16  TCD29_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13C0 32  TCD30_SADDR            TCD Source Address
//  0x13C4 16  TCD30_SOFF             TCD Signed Source Address Offset
//  0x13C6 16  TCD30_ATTR             TCD Transfer Attributes
//  0x13C8 32  TCD30_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13C8 32  TCD30_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13C8 32  TCD30_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13CC 32  TCD30_SLAST            TCD Last Source Address Adjustment
//  0x13D0 32  TCD30_DADDR            TCD Destination Address
//  0x13D4 16  TCD30_DOFF             TCD Signed Destination Address Offset
//  0x13D6 16  TCD30_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13D6 16  TCD30_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13D8 32  TCD30_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13DC 16  TCD30_CSR              TCD Control and Status
//  0x13DE 16  TCD30_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13DE 16  TCD30_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13E0 32  TCD31_SADDR            TCD Source Address
//  0x13E4 16  TCD31_SOFF             TCD Signed Source Address Offset
//  0x13E6 16  TCD31_ATTR             TCD Transfer Attributes
//  0x13E8 32  TCD31_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13E8 32  TCD31_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13E8 32  TCD31_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13EC 32  TCD31_SLAST            TCD Last Source Address Adjustment
//  0x13F0 32  TCD31_DADDR            TCD Destination Address
//  0x13F4 16  TCD31_DOFF             TCD Signed Destination Address Offset
//  0x13F6 16  TCD31_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13F6 16  TCD31_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13F8 32  TCD31_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13FC 16  TCD31_CSR              TCD Control and Status
//  0x13FE 16  TCD31_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13FE 16  TCD31_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package dma

const (
	EDBG    CR = 0x01 << 1  //+ Enable Debug
	ERCA    CR = 0x01 << 2  //+ Enable Round Robin Channel Arbitration
	ERGA    CR = 0x01 << 3  //+ Enable Round Robin Group Arbitration
	HOE     CR = 0x01 << 4  //+ Halt On Error
	HALT    CR = 0x01 << 5  //+ Halt DMA Operations
	CLM     CR = 0x01 << 6  //+ Continuous Link Mode
	EMLM    CR = 0x01 << 7  //+ Enable Minor Loop Mapping
	GRP0PRI CR = 0x01 << 8  //+ Channel Group 0 Priority
	GRP1PRI CR = 0x01 << 10 //+ Channel Group 1 Priority
	ECX     CR = 0x01 << 16 //+ Error Cancel Transfer
	CX      CR = 0x01 << 17 //+ Cancel Transfer
	ACTIVE  CR = 0x01 << 31 //+ DMA Active Status
)

const (
	EDBGn    = 1
	ERCAn    = 2
	ERGAn    = 3
	HOEn     = 4
	HALTn    = 5
	CLMn     = 6
	EMLMn    = 7
	GRP0PRIn = 8
	GRP1PRIn = 10
	ECXn     = 16
	CXn      = 17
	ACTIVEn  = 31
)

const (
	DBE    ES = 0x01 << 0  //+ Destination Bus Error
	SBE    ES = 0x01 << 1  //+ Source Bus Error
	SGE    ES = 0x01 << 2  //+ Scatter/Gather Configuration Error
	NCE    ES = 0x01 << 3  //+ NBYTES/CITER Configuration Error
	DOE    ES = 0x01 << 4  //+ Destination Offset Error
	DAE    ES = 0x01 << 5  //+ Destination Address Error
	SOE    ES = 0x01 << 6  //+ Source Offset Error
	SAE    ES = 0x01 << 7  //+ Source Address Error
	ERRCHN ES = 0x1F << 8  //+ Error Channel Number or Canceled Channel Number
	CPE    ES = 0x01 << 14 //+ Channel Priority Error
	GPE    ES = 0x01 << 15 //+ Group Priority Error
	ECX    ES = 0x01 << 16 //+ Transfer Canceled
	VLD    ES = 0x01 << 31 //+ VLD
)

const (
	DBEn    = 0
	SBEn    = 1
	SGEn    = 2
	NCEn    = 3
	DOEn    = 4
	DAEn    = 5
	SOEn    = 6
	SAEn    = 7
	ERRCHNn = 8
	CPEn    = 14
	GPEn    = 15
	ECXn    = 16
	VLDn    = 31
)

const (
	ERQ0  ERQ = 0x01 << 0  //+ Enable DMA Request 0
	ERQ1  ERQ = 0x01 << 1  //+ Enable DMA Request 1
	ERQ2  ERQ = 0x01 << 2  //+ Enable DMA Request 2
	ERQ3  ERQ = 0x01 << 3  //+ Enable DMA Request 3
	ERQ4  ERQ = 0x01 << 4  //+ Enable DMA Request 4
	ERQ5  ERQ = 0x01 << 5  //+ Enable DMA Request 5
	ERQ6  ERQ = 0x01 << 6  //+ Enable DMA Request 6
	ERQ7  ERQ = 0x01 << 7  //+ Enable DMA Request 7
	ERQ8  ERQ = 0x01 << 8  //+ Enable DMA Request 8
	ERQ9  ERQ = 0x01 << 9  //+ Enable DMA Request 9
	ERQ10 ERQ = 0x01 << 10 //+ Enable DMA Request 10
	ERQ11 ERQ = 0x01 << 11 //+ Enable DMA Request 11
	ERQ12 ERQ = 0x01 << 12 //+ Enable DMA Request 12
	ERQ13 ERQ = 0x01 << 13 //+ Enable DMA Request 13
	ERQ14 ERQ = 0x01 << 14 //+ Enable DMA Request 14
	ERQ15 ERQ = 0x01 << 15 //+ Enable DMA Request 15
	ERQ16 ERQ = 0x01 << 16 //+ Enable DMA Request 16
	ERQ17 ERQ = 0x01 << 17 //+ Enable DMA Request 17
	ERQ18 ERQ = 0x01 << 18 //+ Enable DMA Request 18
	ERQ19 ERQ = 0x01 << 19 //+ Enable DMA Request 19
	ERQ20 ERQ = 0x01 << 20 //+ Enable DMA Request 20
	ERQ21 ERQ = 0x01 << 21 //+ Enable DMA Request 21
	ERQ22 ERQ = 0x01 << 22 //+ Enable DMA Request 22
	ERQ23 ERQ = 0x01 << 23 //+ Enable DMA Request 23
	ERQ24 ERQ = 0x01 << 24 //+ Enable DMA Request 24
	ERQ25 ERQ = 0x01 << 25 //+ Enable DMA Request 25
	ERQ26 ERQ = 0x01 << 26 //+ Enable DMA Request 26
	ERQ27 ERQ = 0x01 << 27 //+ Enable DMA Request 27
	ERQ28 ERQ = 0x01 << 28 //+ Enable DMA Request 28
	ERQ29 ERQ = 0x01 << 29 //+ Enable DMA Request 29
	ERQ30 ERQ = 0x01 << 30 //+ Enable DMA Request 30
	ERQ31 ERQ = 0x01 << 31 //+ Enable DMA Request 31
)

const (
	ERQ0n  = 0
	ERQ1n  = 1
	ERQ2n  = 2
	ERQ3n  = 3
	ERQ4n  = 4
	ERQ5n  = 5
	ERQ6n  = 6
	ERQ7n  = 7
	ERQ8n  = 8
	ERQ9n  = 9
	ERQ10n = 10
	ERQ11n = 11
	ERQ12n = 12
	ERQ13n = 13
	ERQ14n = 14
	ERQ15n = 15
	ERQ16n = 16
	ERQ17n = 17
	ERQ18n = 18
	ERQ19n = 19
	ERQ20n = 20
	ERQ21n = 21
	ERQ22n = 22
	ERQ23n = 23
	ERQ24n = 24
	ERQ25n = 25
	ERQ26n = 26
	ERQ27n = 27
	ERQ28n = 28
	ERQ29n = 29
	ERQ30n = 30
	ERQ31n = 31
)

const (
	EEI0  EEI = 0x01 << 0  //+ Enable Error Interrupt 0
	EEI1  EEI = 0x01 << 1  //+ Enable Error Interrupt 1
	EEI2  EEI = 0x01 << 2  //+ Enable Error Interrupt 2
	EEI3  EEI = 0x01 << 3  //+ Enable Error Interrupt 3
	EEI4  EEI = 0x01 << 4  //+ Enable Error Interrupt 4
	EEI5  EEI = 0x01 << 5  //+ Enable Error Interrupt 5
	EEI6  EEI = 0x01 << 6  //+ Enable Error Interrupt 6
	EEI7  EEI = 0x01 << 7  //+ Enable Error Interrupt 7
	EEI8  EEI = 0x01 << 8  //+ Enable Error Interrupt 8
	EEI9  EEI = 0x01 << 9  //+ Enable Error Interrupt 9
	EEI10 EEI = 0x01 << 10 //+ Enable Error Interrupt 10
	EEI11 EEI = 0x01 << 11 //+ Enable Error Interrupt 11
	EEI12 EEI = 0x01 << 12 //+ Enable Error Interrupt 12
	EEI13 EEI = 0x01 << 13 //+ Enable Error Interrupt 13
	EEI14 EEI = 0x01 << 14 //+ Enable Error Interrupt 14
	EEI15 EEI = 0x01 << 15 //+ Enable Error Interrupt 15
	EEI16 EEI = 0x01 << 16 //+ Enable Error Interrupt 16
	EEI17 EEI = 0x01 << 17 //+ Enable Error Interrupt 17
	EEI18 EEI = 0x01 << 18 //+ Enable Error Interrupt 18
	EEI19 EEI = 0x01 << 19 //+ Enable Error Interrupt 19
	EEI20 EEI = 0x01 << 20 //+ Enable Error Interrupt 20
	EEI21 EEI = 0x01 << 21 //+ Enable Error Interrupt 21
	EEI22 EEI = 0x01 << 22 //+ Enable Error Interrupt 22
	EEI23 EEI = 0x01 << 23 //+ Enable Error Interrupt 23
	EEI24 EEI = 0x01 << 24 //+ Enable Error Interrupt 24
	EEI25 EEI = 0x01 << 25 //+ Enable Error Interrupt 25
	EEI26 EEI = 0x01 << 26 //+ Enable Error Interrupt 26
	EEI27 EEI = 0x01 << 27 //+ Enable Error Interrupt 27
	EEI28 EEI = 0x01 << 28 //+ Enable Error Interrupt 28
	EEI29 EEI = 0x01 << 29 //+ Enable Error Interrupt 29
	EEI30 EEI = 0x01 << 30 //+ Enable Error Interrupt 30
	EEI31 EEI = 0x01 << 31 //+ Enable Error Interrupt 31
)

const (
	EEI0n  = 0
	EEI1n  = 1
	EEI2n  = 2
	EEI3n  = 3
	EEI4n  = 4
	EEI5n  = 5
	EEI6n  = 6
	EEI7n  = 7
	EEI8n  = 8
	EEI9n  = 9
	EEI10n = 10
	EEI11n = 11
	EEI12n = 12
	EEI13n = 13
	EEI14n = 14
	EEI15n = 15
	EEI16n = 16
	EEI17n = 17
	EEI18n = 18
	EEI19n = 19
	EEI20n = 20
	EEI21n = 21
	EEI22n = 22
	EEI23n = 23
	EEI24n = 24
	EEI25n = 25
	EEI26n = 26
	EEI27n = 27
	EEI28n = 28
	EEI29n = 29
	EEI30n = 30
	EEI31n = 31
)

const (
	CEEI CEEI = 0x1F << 0 //+ Clear Enable Error Interrupt
	CAEE CEEI = 0x01 << 6 //+ Clear All Enable Error Interrupts
	NOP  CEEI = 0x01 << 7 //+ No Op enable
)

const (
	CEEIn = 0
	CAEEn = 6
	NOPn  = 7
)

const (
	SEEI SEEI = 0x1F << 0 //+ Set Enable Error Interrupt
	SAEE SEEI = 0x01 << 6 //+ Sets All Enable Error Interrupts
	NOP  SEEI = 0x01 << 7 //+ No Op enable
)

const (
	SEEIn = 0
	SAEEn = 6
	NOPn  = 7
)

const (
	CERQ CERQ = 0x1F << 0 //+ Clear Enable Request
	CAER CERQ = 0x01 << 6 //+ Clear All Enable Requests
	NOP  CERQ = 0x01 << 7 //+ No Op enable
)

const (
	CERQn = 0
	CAERn = 6
	NOPn  = 7
)

const (
	SERQ SERQ = 0x1F << 0 //+ Set Enable Request
	SAER SERQ = 0x01 << 6 //+ Set All Enable Requests
	NOP  SERQ = 0x01 << 7 //+ No Op enable
)

const (
	SERQn = 0
	SAERn = 6
	NOPn  = 7
)

const (
	CDNE CDNE = 0x1F << 0 //+ Clear DONE Bit
	CADN CDNE = 0x01 << 6 //+ Clears All DONE Bits
	NOP  CDNE = 0x01 << 7 //+ No Op enable
)

const (
	CDNEn = 0
	CADNn = 6
	NOPn  = 7
)

const (
	SSRT SSRT = 0x1F << 0 //+ Set START Bit
	SAST SSRT = 0x01 << 6 //+ Set All START Bits (activates all channels)
	NOP  SSRT = 0x01 << 7 //+ No Op enable
)

const (
	SSRTn = 0
	SASTn = 6
	NOPn  = 7
)

const (
	CERR CERR = 0x1F << 0 //+ Clear Error Indicator
	CAEI CERR = 0x01 << 6 //+ Clear All Error Indicators
	NOP  CERR = 0x01 << 7 //+ No Op enable
)

const (
	CERRn = 0
	CAEIn = 6
	NOPn  = 7
)

const (
	CINT CINT = 0x1F << 0 //+ Clear Interrupt Request
	CAIR CINT = 0x01 << 6 //+ Clear All Interrupt Requests
	NOP  CINT = 0x01 << 7 //+ No Op enable
)

const (
	CINTn = 0
	CAIRn = 6
	NOPn  = 7
)

const (
	INT0  INT = 0x01 << 0  //+ Interrupt Request 0
	INT1  INT = 0x01 << 1  //+ Interrupt Request 1
	INT2  INT = 0x01 << 2  //+ Interrupt Request 2
	INT3  INT = 0x01 << 3  //+ Interrupt Request 3
	INT4  INT = 0x01 << 4  //+ Interrupt Request 4
	INT5  INT = 0x01 << 5  //+ Interrupt Request 5
	INT6  INT = 0x01 << 6  //+ Interrupt Request 6
	INT7  INT = 0x01 << 7  //+ Interrupt Request 7
	INT8  INT = 0x01 << 8  //+ Interrupt Request 8
	INT9  INT = 0x01 << 9  //+ Interrupt Request 9
	INT10 INT = 0x01 << 10 //+ Interrupt Request 10
	INT11 INT = 0x01 << 11 //+ Interrupt Request 11
	INT12 INT = 0x01 << 12 //+ Interrupt Request 12
	INT13 INT = 0x01 << 13 //+ Interrupt Request 13
	INT14 INT = 0x01 << 14 //+ Interrupt Request 14
	INT15 INT = 0x01 << 15 //+ Interrupt Request 15
	INT16 INT = 0x01 << 16 //+ Interrupt Request 16
	INT17 INT = 0x01 << 17 //+ Interrupt Request 17
	INT18 INT = 0x01 << 18 //+ Interrupt Request 18
	INT19 INT = 0x01 << 19 //+ Interrupt Request 19
	INT20 INT = 0x01 << 20 //+ Interrupt Request 20
	INT21 INT = 0x01 << 21 //+ Interrupt Request 21
	INT22 INT = 0x01 << 22 //+ Interrupt Request 22
	INT23 INT = 0x01 << 23 //+ Interrupt Request 23
	INT24 INT = 0x01 << 24 //+ Interrupt Request 24
	INT25 INT = 0x01 << 25 //+ Interrupt Request 25
	INT26 INT = 0x01 << 26 //+ Interrupt Request 26
	INT27 INT = 0x01 << 27 //+ Interrupt Request 27
	INT28 INT = 0x01 << 28 //+ Interrupt Request 28
	INT29 INT = 0x01 << 29 //+ Interrupt Request 29
	INT30 INT = 0x01 << 30 //+ Interrupt Request 30
	INT31 INT = 0x01 << 31 //+ Interrupt Request 31
)

const (
	INT0n  = 0
	INT1n  = 1
	INT2n  = 2
	INT3n  = 3
	INT4n  = 4
	INT5n  = 5
	INT6n  = 6
	INT7n  = 7
	INT8n  = 8
	INT9n  = 9
	INT10n = 10
	INT11n = 11
	INT12n = 12
	INT13n = 13
	INT14n = 14
	INT15n = 15
	INT16n = 16
	INT17n = 17
	INT18n = 18
	INT19n = 19
	INT20n = 20
	INT21n = 21
	INT22n = 22
	INT23n = 23
	INT24n = 24
	INT25n = 25
	INT26n = 26
	INT27n = 27
	INT28n = 28
	INT29n = 29
	INT30n = 30
	INT31n = 31
)

const (
	ERR0  ERR = 0x01 << 0  //+ Error In Channel 0
	ERR1  ERR = 0x01 << 1  //+ Error In Channel 1
	ERR2  ERR = 0x01 << 2  //+ Error In Channel 2
	ERR3  ERR = 0x01 << 3  //+ Error In Channel 3
	ERR4  ERR = 0x01 << 4  //+ Error In Channel 4
	ERR5  ERR = 0x01 << 5  //+ Error In Channel 5
	ERR6  ERR = 0x01 << 6  //+ Error In Channel 6
	ERR7  ERR = 0x01 << 7  //+ Error In Channel 7
	ERR8  ERR = 0x01 << 8  //+ Error In Channel 8
	ERR9  ERR = 0x01 << 9  //+ Error In Channel 9
	ERR10 ERR = 0x01 << 10 //+ Error In Channel 10
	ERR11 ERR = 0x01 << 11 //+ Error In Channel 11
	ERR12 ERR = 0x01 << 12 //+ Error In Channel 12
	ERR13 ERR = 0x01 << 13 //+ Error In Channel 13
	ERR14 ERR = 0x01 << 14 //+ Error In Channel 14
	ERR15 ERR = 0x01 << 15 //+ Error In Channel 15
	ERR16 ERR = 0x01 << 16 //+ Error In Channel 16
	ERR17 ERR = 0x01 << 17 //+ Error In Channel 17
	ERR18 ERR = 0x01 << 18 //+ Error In Channel 18
	ERR19 ERR = 0x01 << 19 //+ Error In Channel 19
	ERR20 ERR = 0x01 << 20 //+ Error In Channel 20
	ERR21 ERR = 0x01 << 21 //+ Error In Channel 21
	ERR22 ERR = 0x01 << 22 //+ Error In Channel 22
	ERR23 ERR = 0x01 << 23 //+ Error In Channel 23
	ERR24 ERR = 0x01 << 24 //+ Error In Channel 24
	ERR25 ERR = 0x01 << 25 //+ Error In Channel 25
	ERR26 ERR = 0x01 << 26 //+ Error In Channel 26
	ERR27 ERR = 0x01 << 27 //+ Error In Channel 27
	ERR28 ERR = 0x01 << 28 //+ Error In Channel 28
	ERR29 ERR = 0x01 << 29 //+ Error In Channel 29
	ERR30 ERR = 0x01 << 30 //+ Error In Channel 30
	ERR31 ERR = 0x01 << 31 //+ Error In Channel 31
)

const (
	ERR0n  = 0
	ERR1n  = 1
	ERR2n  = 2
	ERR3n  = 3
	ERR4n  = 4
	ERR5n  = 5
	ERR6n  = 6
	ERR7n  = 7
	ERR8n  = 8
	ERR9n  = 9
	ERR10n = 10
	ERR11n = 11
	ERR12n = 12
	ERR13n = 13
	ERR14n = 14
	ERR15n = 15
	ERR16n = 16
	ERR17n = 17
	ERR18n = 18
	ERR19n = 19
	ERR20n = 20
	ERR21n = 21
	ERR22n = 22
	ERR23n = 23
	ERR24n = 24
	ERR25n = 25
	ERR26n = 26
	ERR27n = 27
	ERR28n = 28
	ERR29n = 29
	ERR30n = 30
	ERR31n = 31
)

const (
	HRS0  HRS = 0x01 << 0  //+ Hardware Request Status Channel 0
	HRS1  HRS = 0x01 << 1  //+ Hardware Request Status Channel 1
	HRS2  HRS = 0x01 << 2  //+ Hardware Request Status Channel 2
	HRS3  HRS = 0x01 << 3  //+ Hardware Request Status Channel 3
	HRS4  HRS = 0x01 << 4  //+ Hardware Request Status Channel 4
	HRS5  HRS = 0x01 << 5  //+ Hardware Request Status Channel 5
	HRS6  HRS = 0x01 << 6  //+ Hardware Request Status Channel 6
	HRS7  HRS = 0x01 << 7  //+ Hardware Request Status Channel 7
	HRS8  HRS = 0x01 << 8  //+ Hardware Request Status Channel 8
	HRS9  HRS = 0x01 << 9  //+ Hardware Request Status Channel 9
	HRS10 HRS = 0x01 << 10 //+ Hardware Request Status Channel 10
	HRS11 HRS = 0x01 << 11 //+ Hardware Request Status Channel 11
	HRS12 HRS = 0x01 << 12 //+ Hardware Request Status Channel 12
	HRS13 HRS = 0x01 << 13 //+ Hardware Request Status Channel 13
	HRS14 HRS = 0x01 << 14 //+ Hardware Request Status Channel 14
	HRS15 HRS = 0x01 << 15 //+ Hardware Request Status Channel 15
	HRS16 HRS = 0x01 << 16 //+ Hardware Request Status Channel 16
	HRS17 HRS = 0x01 << 17 //+ Hardware Request Status Channel 17
	HRS18 HRS = 0x01 << 18 //+ Hardware Request Status Channel 18
	HRS19 HRS = 0x01 << 19 //+ Hardware Request Status Channel 19
	HRS20 HRS = 0x01 << 20 //+ Hardware Request Status Channel 20
	HRS21 HRS = 0x01 << 21 //+ Hardware Request Status Channel 21
	HRS22 HRS = 0x01 << 22 //+ Hardware Request Status Channel 22
	HRS23 HRS = 0x01 << 23 //+ Hardware Request Status Channel 23
	HRS24 HRS = 0x01 << 24 //+ Hardware Request Status Channel 24
	HRS25 HRS = 0x01 << 25 //+ Hardware Request Status Channel 25
	HRS26 HRS = 0x01 << 26 //+ Hardware Request Status Channel 26
	HRS27 HRS = 0x01 << 27 //+ Hardware Request Status Channel 27
	HRS28 HRS = 0x01 << 28 //+ Hardware Request Status Channel 28
	HRS29 HRS = 0x01 << 29 //+ Hardware Request Status Channel 29
	HRS30 HRS = 0x01 << 30 //+ Hardware Request Status Channel 30
	HRS31 HRS = 0x01 << 31 //+ Hardware Request Status Channel 31
)

const (
	HRS0n  = 0
	HRS1n  = 1
	HRS2n  = 2
	HRS3n  = 3
	HRS4n  = 4
	HRS5n  = 5
	HRS6n  = 6
	HRS7n  = 7
	HRS8n  = 8
	HRS9n  = 9
	HRS10n = 10
	HRS11n = 11
	HRS12n = 12
	HRS13n = 13
	HRS14n = 14
	HRS15n = 15
	HRS16n = 16
	HRS17n = 17
	HRS18n = 18
	HRS19n = 19
	HRS20n = 20
	HRS21n = 21
	HRS22n = 22
	HRS23n = 23
	HRS24n = 24
	HRS25n = 25
	HRS26n = 26
	HRS27n = 27
	HRS28n = 28
	HRS29n = 29
	HRS30n = 30
	HRS31n = 31
)

const (
	EDREQ_0  EARS = 0x01 << 0  //+ Enable asynchronous DMA request in stop mode for channel 0.
	EDREQ_1  EARS = 0x01 << 1  //+ Enable asynchronous DMA request in stop mode for channel 1.
	EDREQ_2  EARS = 0x01 << 2  //+ Enable asynchronous DMA request in stop mode for channel 2.
	EDREQ_3  EARS = 0x01 << 3  //+ Enable asynchronous DMA request in stop mode for channel 3.
	EDREQ_4  EARS = 0x01 << 4  //+ Enable asynchronous DMA request in stop mode for channel 4
	EDREQ_5  EARS = 0x01 << 5  //+ Enable asynchronous DMA request in stop mode for channel 5
	EDREQ_6  EARS = 0x01 << 6  //+ Enable asynchronous DMA request in stop mode for channel 6
	EDREQ_7  EARS = 0x01 << 7  //+ Enable asynchronous DMA request in stop mode for channel 7
	EDREQ_8  EARS = 0x01 << 8  //+ Enable asynchronous DMA request in stop mode for channel 8
	EDREQ_9  EARS = 0x01 << 9  //+ Enable asynchronous DMA request in stop mode for channel 9
	EDREQ_10 EARS = 0x01 << 10 //+ Enable asynchronous DMA request in stop mode for channel 10
	EDREQ_11 EARS = 0x01 << 11 //+ Enable asynchronous DMA request in stop mode for channel 11
	EDREQ_12 EARS = 0x01 << 12 //+ Enable asynchronous DMA request in stop mode for channel 12
	EDREQ_13 EARS = 0x01 << 13 //+ Enable asynchronous DMA request in stop mode for channel 13
	EDREQ_14 EARS = 0x01 << 14 //+ Enable asynchronous DMA request in stop mode for channel 14
	EDREQ_15 EARS = 0x01 << 15 //+ Enable asynchronous DMA request in stop mode for channel 15
	EDREQ_16 EARS = 0x01 << 16 //+ Enable asynchronous DMA request in stop mode for channel 16
	EDREQ_17 EARS = 0x01 << 17 //+ Enable asynchronous DMA request in stop mode for channel 17
	EDREQ_18 EARS = 0x01 << 18 //+ Enable asynchronous DMA request in stop mode for channel 18
	EDREQ_19 EARS = 0x01 << 19 //+ Enable asynchronous DMA request in stop mode for channel 19
	EDREQ_20 EARS = 0x01 << 20 //+ Enable asynchronous DMA request in stop mode for channel 20
	EDREQ_21 EARS = 0x01 << 21 //+ Enable asynchronous DMA request in stop mode for channel 21
	EDREQ_22 EARS = 0x01 << 22 //+ Enable asynchronous DMA request in stop mode for channel 22
	EDREQ_23 EARS = 0x01 << 23 //+ Enable asynchronous DMA request in stop mode for channel 23
	EDREQ_24 EARS = 0x01 << 24 //+ Enable asynchronous DMA request in stop mode for channel 24
	EDREQ_25 EARS = 0x01 << 25 //+ Enable asynchronous DMA request in stop mode for channel 25
	EDREQ_26 EARS = 0x01 << 26 //+ Enable asynchronous DMA request in stop mode for channel 26
	EDREQ_27 EARS = 0x01 << 27 //+ Enable asynchronous DMA request in stop mode for channel 27
	EDREQ_28 EARS = 0x01 << 28 //+ Enable asynchronous DMA request in stop mode for channel 28
	EDREQ_29 EARS = 0x01 << 29 //+ Enable asynchronous DMA request in stop mode for channel 29
	EDREQ_30 EARS = 0x01 << 30 //+ Enable asynchronous DMA request in stop mode for channel 30
	EDREQ_31 EARS = 0x01 << 31 //+ Enable asynchronous DMA request in stop mode for channel 31
)

const (
	EDREQ_0n  = 0
	EDREQ_1n  = 1
	EDREQ_2n  = 2
	EDREQ_3n  = 3
	EDREQ_4n  = 4
	EDREQ_5n  = 5
	EDREQ_6n  = 6
	EDREQ_7n  = 7
	EDREQ_8n  = 8
	EDREQ_9n  = 9
	EDREQ_10n = 10
	EDREQ_11n = 11
	EDREQ_12n = 12
	EDREQ_13n = 13
	EDREQ_14n = 14
	EDREQ_15n = 15
	EDREQ_16n = 16
	EDREQ_17n = 17
	EDREQ_18n = 18
	EDREQ_19n = 19
	EDREQ_20n = 20
	EDREQ_21n = 21
	EDREQ_22n = 22
	EDREQ_23n = 23
	EDREQ_24n = 24
	EDREQ_25n = 25
	EDREQ_26n = 26
	EDREQ_27n = 27
	EDREQ_28n = 28
	EDREQ_29n = 29
	EDREQ_30n = 30
	EDREQ_31n = 31
)

const (
	CHPRI  DCHPRI3 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI3 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI3 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI3 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI2 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI2 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI2 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI2 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI1 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI1 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI1 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI1 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI0 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI0 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI0 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI0 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI7 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI7 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI7 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI7 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI6 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI6 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI6 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI6 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI5 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI5 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI5 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI5 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI4 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI4 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI4 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI4 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI11 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI11 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI11 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI11 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI10 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI10 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI10 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI10 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI9 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI9 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI9 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI9 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI8 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI8 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI8 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI8 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI15 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI15 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI15 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI15 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI14 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI14 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI14 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI14 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI13 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI13 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI13 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI13 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI12 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI12 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI12 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI12 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI19 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI19 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI19 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI19 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI18 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI18 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI18 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI18 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI17 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI17 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI17 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI17 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI16 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI16 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI16 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI16 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI23 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI23 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI23 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI23 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI22 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI22 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI22 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI22 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI21 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI21 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI21 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI21 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI20 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI20 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI20 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI20 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI27 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI27 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI27 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI27 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI26 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI26 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI26 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI26 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI25 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI25 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI25 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI25 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI24 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI24 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI24 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI24 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI31 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI31 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI31 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI31 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI30 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI30 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI30 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI30 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI29 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI29 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI29 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI29 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI28 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI28 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI28 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	ECP    DCHPRI28 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	SADDR TCD0_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD0_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD0_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD0_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD0_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD0_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD0_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD0_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD0_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD0_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD0_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD0_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD0_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD0_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD0_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD0_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD0_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD0_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD0_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD0_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD0_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD0_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD0_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD0_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD0_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD0_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD0_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD0_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD0_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD0_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD0_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD0_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD0_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD0_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD0_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD0_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD0_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD0_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD0_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD0_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD0_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD0_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD0_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD0_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD0_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD0_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD0_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD0_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD0_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD0_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD0_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD0_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD0_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD0_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD0_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD0_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD1_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD1_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD1_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD1_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD1_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD1_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD1_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD1_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD1_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD1_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD1_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD1_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD1_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD1_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD1_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD1_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD1_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD1_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD1_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD1_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD1_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD1_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD1_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD1_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD1_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD1_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD1_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD1_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD1_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD1_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD1_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD1_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD1_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD1_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD1_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD1_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD1_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD1_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD1_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD1_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD1_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD1_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD1_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD1_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD1_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD1_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD1_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD1_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD1_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD1_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD1_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD1_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD1_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD1_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD1_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD1_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD2_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD2_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD2_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD2_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD2_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD2_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD2_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD2_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD2_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD2_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD2_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD2_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD2_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD2_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD2_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD2_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD2_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD2_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD2_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD2_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD2_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD2_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD2_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD2_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD2_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD2_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD2_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD2_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD2_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD2_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD2_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD2_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD2_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD2_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD2_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD2_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD2_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD2_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD2_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD2_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD2_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD2_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD2_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD2_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD2_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD2_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD2_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD2_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD2_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD2_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD2_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD2_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD2_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD2_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD2_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD2_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD3_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD3_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD3_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD3_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD3_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD3_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD3_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD3_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD3_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD3_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD3_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD3_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD3_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD3_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD3_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD3_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD3_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD3_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD3_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD3_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD3_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD3_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD3_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD3_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD3_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD3_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD3_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD3_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD3_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD3_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD3_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD3_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD3_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD3_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD3_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD3_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD3_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD3_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD3_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD3_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD3_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD3_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD3_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD3_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD3_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD3_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD3_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD3_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD3_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD3_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD3_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD3_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD3_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD3_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD3_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD3_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD4_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD4_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD4_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD4_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD4_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD4_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD4_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD4_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD4_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD4_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD4_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD4_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD4_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD4_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD4_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD4_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD4_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD4_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD4_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD4_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD4_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD4_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD4_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD4_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD4_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD4_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD4_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD4_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD4_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD4_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD4_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD4_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER  TCD4_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD4_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD4_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER TCD4_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD4_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD4_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD4_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD4_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD4_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD4_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD4_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD4_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD4_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD4_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD4_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD4_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD4_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD4_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD4_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD4_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD4_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD4_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD4_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD4_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD5_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD5_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD5_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD5_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD5_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD5_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD5_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD5_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD5_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD5_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD5_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD5_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD5_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD5_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD5_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD5_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD5_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD5_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD5_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD5_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD5_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD5_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD5_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD5_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD5_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD5_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD5_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD5_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD5_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD5_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD5_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD5_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER  TCD5_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD5_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD5_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER TCD5_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD5_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD5_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD5_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD5_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD5_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD5_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD5_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD5_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD5_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD5_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD5_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD5_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD5_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD5_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD5_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD5_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD5_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD5_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD5_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD5_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD6_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD6_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD6_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD6_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD6_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD6_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD6_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD6_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD6_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD6_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD6_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD6_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD6_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD6_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD6_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD6_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD6_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD6_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD6_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD6_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD6_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD6_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD6_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD6_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD6_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD6_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD6_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD6_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD6_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD6_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD6_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD6_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD6_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD6_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD6_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD6_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD6_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD6_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD6_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD6_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD6_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD6_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD6_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD6_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD6_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD6_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD6_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD6_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD6_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD6_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD6_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD6_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD6_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD6_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD6_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD6_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD7_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD7_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD7_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD7_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD7_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD7_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD7_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD7_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD7_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD7_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD7_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD7_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD7_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD7_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD7_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD7_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD7_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD7_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD7_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD7_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD7_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD7_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD7_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD7_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD7_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD7_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD7_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD7_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD7_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD7_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD7_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD7_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD7_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD7_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD7_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD7_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD7_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD7_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD7_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD7_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD7_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD7_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD7_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD7_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD7_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD7_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD7_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD7_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD7_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD7_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD7_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD7_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD7_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD7_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD7_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD7_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD8_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD8_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD8_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD8_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD8_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD8_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD8_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD8_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD8_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD8_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD8_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD8_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD8_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD8_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD8_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD8_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD8_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD8_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD8_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD8_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD8_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD8_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD8_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD8_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD8_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD8_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD8_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD8_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD8_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD8_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD8_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD8_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD8_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD8_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD8_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD8_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD8_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD8_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD8_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD8_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD8_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD8_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD8_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD8_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD8_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD8_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD8_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD8_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD8_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD8_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD8_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD8_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD8_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD8_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD8_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD8_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD9_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD9_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD9_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD9_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD9_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD9_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD9_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD9_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD9_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD9_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD9_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD9_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD9_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD9_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD9_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD9_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD9_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD9_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD9_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD9_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD9_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD9_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD9_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD9_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD9_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD9_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD9_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD9_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD9_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD9_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD9_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD9_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER  TCD9_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD9_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD9_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER TCD9_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD9_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD9_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD9_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD9_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD9_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD9_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD9_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD9_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD9_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD9_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD9_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD9_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD9_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD9_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD9_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD9_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD9_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD9_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD9_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD9_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD10_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD10_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD10_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD10_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD10_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD10_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD10_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD10_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD10_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD10_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD10_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD10_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD10_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD10_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD10_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD10_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD10_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD10_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD10_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD10_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD10_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD10_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD10_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD10_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD10_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD10_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD10_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD10_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD10_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD10_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD10_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD10_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD10_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD10_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD10_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD10_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD10_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD10_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD10_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD10_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD10_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD10_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD10_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD10_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD10_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD10_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD10_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD10_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD10_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD10_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD10_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD10_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD10_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD10_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD10_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD10_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD11_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD11_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD11_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD11_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD11_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD11_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD11_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD11_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD11_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD11_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD11_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD11_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD11_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD11_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD11_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD11_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD11_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD11_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD11_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD11_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD11_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD11_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD11_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD11_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD11_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD11_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD11_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD11_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD11_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD11_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD11_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD11_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD11_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD11_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD11_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD11_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD11_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD11_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD11_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD11_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD11_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD11_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD11_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD11_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD11_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD11_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD11_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD11_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD11_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD11_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD11_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD11_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD11_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD11_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD11_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD11_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD12_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD12_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD12_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD12_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD12_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD12_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD12_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD12_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD12_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD12_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD12_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD12_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD12_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD12_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD12_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD12_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD12_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD12_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD12_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD12_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD12_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD12_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD12_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD12_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD12_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD12_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD12_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD12_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD12_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD12_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD12_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD12_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD12_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD12_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD12_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD12_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD12_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD12_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD12_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD12_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD12_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD12_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD12_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD12_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD12_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD12_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD12_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD12_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD12_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD12_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD12_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD12_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD12_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD12_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD12_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD12_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD13_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD13_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD13_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD13_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD13_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD13_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD13_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD13_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD13_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD13_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD13_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD13_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD13_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD13_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD13_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD13_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD13_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD13_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD13_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD13_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD13_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD13_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD13_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD13_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD13_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD13_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD13_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD13_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD13_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD13_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD13_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD13_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD13_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD13_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD13_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD13_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD13_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD13_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD13_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD13_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD13_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD13_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD13_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD13_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD13_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD13_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD13_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD13_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD13_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD13_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD13_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD13_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD13_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD13_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD13_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD13_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD14_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD14_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD14_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD14_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD14_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD14_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD14_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD14_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD14_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD14_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD14_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD14_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD14_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD14_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD14_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD14_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD14_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD14_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD14_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD14_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD14_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD14_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD14_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD14_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD14_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD14_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD14_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD14_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD14_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD14_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD14_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD14_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD14_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD14_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD14_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD14_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD14_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD14_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD14_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD14_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD14_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD14_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD14_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD14_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD14_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD14_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD14_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD14_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD14_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD14_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD14_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD14_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD14_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD14_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD14_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD14_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD15_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD15_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD15_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD15_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD15_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD15_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD15_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD15_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD15_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD15_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD15_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD15_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD15_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD15_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD15_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD15_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD15_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD15_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD15_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD15_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD15_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD15_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD15_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD15_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD15_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD15_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD15_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD15_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD15_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD15_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD15_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD15_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD15_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD15_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD15_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD15_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD15_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD15_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD15_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD15_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD15_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD15_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD15_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD15_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD15_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD15_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD15_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD15_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD15_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD15_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD15_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD15_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD15_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD15_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD15_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD15_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD16_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD16_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD16_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD16_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD16_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD16_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD16_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD16_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD16_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD16_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD16_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD16_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD16_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD16_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD16_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD16_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD16_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD16_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD16_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD16_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD16_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD16_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD16_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD16_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD16_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD16_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD16_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD16_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD16_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD16_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD16_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD16_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD16_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD16_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD16_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD16_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD16_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD16_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD16_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD16_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD16_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD16_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD16_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD16_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD16_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD16_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD16_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD16_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD16_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD16_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD16_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD16_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD16_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD16_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD16_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD16_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD17_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD17_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD17_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD17_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD17_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD17_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD17_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD17_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD17_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD17_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD17_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD17_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD17_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD17_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD17_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD17_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD17_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD17_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD17_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD17_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD17_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD17_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD17_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD17_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD17_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD17_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD17_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD17_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD17_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD17_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD17_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD17_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD17_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD17_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD17_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD17_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD17_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD17_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD17_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD17_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD17_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD17_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD17_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD17_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD17_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD17_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD17_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD17_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD17_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD17_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD17_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD17_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD17_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD17_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD17_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD17_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD18_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD18_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD18_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD18_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD18_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD18_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD18_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD18_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD18_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD18_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD18_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD18_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD18_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD18_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD18_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD18_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD18_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD18_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD18_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD18_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD18_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD18_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD18_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD18_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD18_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD18_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD18_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD18_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD18_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD18_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD18_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD18_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD18_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD18_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD18_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD18_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD18_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD18_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD18_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD18_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD18_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD18_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD18_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD18_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD18_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD18_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD18_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD18_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD18_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD18_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD18_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD18_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD18_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD18_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD18_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD18_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD19_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD19_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD19_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD19_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD19_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD19_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD19_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD19_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD19_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD19_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD19_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD19_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD19_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD19_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD19_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD19_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD19_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD19_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD19_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD19_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD19_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD19_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD19_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD19_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD19_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD19_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD19_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD19_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD19_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD19_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD19_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD19_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD19_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD19_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD19_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD19_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD19_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD19_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD19_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD19_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD19_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD19_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD19_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD19_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD19_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD19_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD19_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD19_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD19_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD19_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD19_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD19_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD19_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD19_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD19_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD19_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD20_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD20_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD20_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD20_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD20_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD20_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD20_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD20_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD20_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD20_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD20_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD20_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD20_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD20_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD20_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD20_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD20_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD20_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD20_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD20_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD20_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD20_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD20_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD20_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD20_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD20_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD20_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD20_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD20_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD20_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD20_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD20_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER  TCD20_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD20_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD20_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER TCD20_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD20_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD20_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD20_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD20_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD20_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD20_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD20_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD20_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD20_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD20_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD20_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD20_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD20_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD20_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD20_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD20_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD20_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD20_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD20_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD20_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD21_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD21_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD21_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD21_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD21_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD21_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD21_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD21_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD21_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD21_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD21_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD21_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD21_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD21_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD21_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD21_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD21_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD21_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD21_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD21_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD21_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD21_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD21_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD21_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD21_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD21_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD21_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD21_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD21_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD21_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD21_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD21_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD21_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD21_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD21_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD21_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD21_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD21_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD21_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD21_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD21_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD21_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD21_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD21_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD21_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD21_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD21_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD21_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD21_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD21_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD21_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD21_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD21_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD21_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD21_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD21_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD22_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD22_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD22_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD22_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD22_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD22_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD22_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD22_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD22_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD22_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD22_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD22_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD22_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD22_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD22_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD22_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD22_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD22_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD22_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD22_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD22_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD22_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD22_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD22_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD22_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD22_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD22_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD22_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD22_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD22_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD22_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD22_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD22_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD22_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD22_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD22_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD22_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD22_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD22_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD22_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD22_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD22_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD22_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD22_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD22_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD22_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD22_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD22_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD22_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD22_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD22_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD22_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD22_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD22_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD22_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD22_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD23_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD23_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD23_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD23_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD23_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD23_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD23_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD23_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD23_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD23_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD23_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD23_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD23_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD23_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD23_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD23_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD23_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD23_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD23_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD23_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD23_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD23_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD23_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD23_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD23_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD23_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD23_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD23_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD23_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD23_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD23_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD23_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD23_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD23_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD23_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD23_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD23_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD23_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD23_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD23_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD23_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD23_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD23_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD23_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD23_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD23_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD23_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD23_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD23_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD23_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD23_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD23_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD23_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD23_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD23_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD23_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD24_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD24_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD24_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD24_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD24_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD24_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD24_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD24_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD24_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD24_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD24_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD24_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD24_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD24_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD24_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD24_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD24_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD24_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD24_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD24_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD24_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD24_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD24_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD24_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD24_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD24_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD24_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD24_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD24_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD24_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD24_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD24_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD24_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD24_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD24_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD24_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD24_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD24_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD24_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD24_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD24_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD24_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD24_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD24_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD24_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD24_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD24_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD24_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD24_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD24_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD24_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD24_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD24_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD24_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD24_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD24_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD25_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD25_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD25_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD25_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD25_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD25_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD25_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD25_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD25_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD25_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD25_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD25_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD25_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD25_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD25_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD25_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD25_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD25_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD25_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD25_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD25_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD25_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD25_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD25_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD25_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD25_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD25_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD25_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD25_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD25_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD25_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD25_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD25_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD25_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD25_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD25_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD25_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD25_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD25_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD25_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD25_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD25_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD25_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD25_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD25_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD25_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD25_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD25_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD25_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD25_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD25_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD25_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD25_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD25_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD25_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD25_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD26_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD26_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD26_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD26_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD26_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD26_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD26_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD26_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD26_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD26_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD26_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD26_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD26_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD26_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD26_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD26_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD26_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD26_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD26_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD26_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD26_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD26_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD26_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD26_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD26_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD26_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD26_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD26_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD26_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD26_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD26_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD26_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER  TCD26_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD26_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD26_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER TCD26_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD26_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD26_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD26_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD26_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD26_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD26_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD26_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD26_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD26_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD26_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD26_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD26_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD26_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD26_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD26_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD26_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD26_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD26_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD26_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD26_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD27_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD27_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD27_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD27_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD27_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD27_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD27_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD27_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD27_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD27_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD27_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD27_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD27_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD27_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD27_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD27_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD27_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD27_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD27_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD27_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD27_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD27_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD27_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD27_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD27_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD27_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD27_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD27_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD27_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD27_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD27_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD27_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD27_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD27_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD27_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD27_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD27_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD27_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD27_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD27_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD27_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD27_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD27_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD27_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD27_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD27_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD27_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD27_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD27_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD27_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD27_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD27_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD27_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD27_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD27_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD27_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD28_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD28_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD28_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD28_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD28_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD28_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD28_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD28_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD28_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD28_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD28_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD28_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD28_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD28_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD28_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD28_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD28_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD28_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD28_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD28_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD28_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD28_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD28_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD28_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD28_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD28_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD28_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD28_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD28_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD28_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD28_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD28_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD28_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD28_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD28_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD28_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD28_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD28_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD28_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD28_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD28_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD28_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD28_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD28_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD28_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD28_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD28_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD28_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD28_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD28_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD28_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD28_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD28_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD28_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD28_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD28_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD29_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD29_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD29_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD29_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD29_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD29_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD29_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD29_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD29_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD29_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD29_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD29_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD29_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD29_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD29_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD29_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD29_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD29_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD29_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD29_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD29_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD29_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD29_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD29_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD29_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD29_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD29_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD29_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD29_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD29_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD29_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD29_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD29_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD29_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD29_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD29_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD29_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD29_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD29_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD29_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD29_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD29_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD29_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD29_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD29_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD29_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD29_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD29_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD29_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD29_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD29_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER  TCD29_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD29_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD29_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER TCD29_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD29_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD30_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD30_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD30_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD30_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD30_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD30_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD30_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD30_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD30_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD30_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD30_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD30_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD30_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD30_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD30_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD30_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD30_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD30_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD30_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD30_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD30_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD30_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD30_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD30_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD30_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD30_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD30_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD30_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD30_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD30_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD30_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD30_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD30_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD30_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD30_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD30_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD30_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD30_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD30_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD30_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD30_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD30_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD30_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD30_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD30_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD30_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD30_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD30_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD30_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD30_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD30_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD30_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD30_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD30_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD30_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD30_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD31_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD31_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD31_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD31_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD31_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD31_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD31_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD31_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD31_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD31_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD31_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD31_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD31_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD31_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD31_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD31_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD31_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD31_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD31_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD31_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD31_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD31_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES TCD31_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE  TCD31_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	SMLOE  TCD31_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD31_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF  TCD31_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE  TCD31_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	SMLOE  TCD31_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD31_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD31_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD31_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER TCD31_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK TCD31_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER  TCD31_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH TCD31_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK  TCD31_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD31_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START       TCD31_CSR = 0x01 << 0  //+ Channel Start
	INTMAJOR    TCD31_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTHALF     TCD31_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	DREQ        TCD31_CSR = 0x01 << 3  //+ Disable Request
	ESG         TCD31_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	MAJORELINK  TCD31_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	ACTIVE      TCD31_CSR = 0x01 << 6  //+ Channel Active
	DONE        TCD31_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH TCD31_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC         TCD31_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0       TCD31_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2       TCD31_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3       TCD31_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER TCD31_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK TCD31_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER  TCD31_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH TCD31_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK  TCD31_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)
