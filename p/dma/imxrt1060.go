// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package dma provides access to the registers of the DMA peripheral.
//
// Instances:
//  DMA0  DMA0_BASE  -  DMA0_DMA16*,DMA1_DMA17*,DMA2_DMA18*,DMA3_DMA19*,DMA4_DMA20*,DMA5_DMA21*,DMA6_DMA22*,DMA7_DMA23*,DMA8_DMA24*,DMA9_DMA25*,DMA10_DMA26*,DMA11_DMA27*,DMA12_DMA28*,DMA13_DMA29*,DMA14_DMA30*,DMA15_DMA31*,DMA_ERROR*
// Registers:
//  0x000  32  CR                     Control Register
//  0x004  32  ES                     Error Status Register
//  0x00C  32  ERQ                    Enable Request Register
//  0x014  32  EEI                    Enable Error Interrupt Register
//  0x018   8  CEEI                   Clear Enable Error Interrupt Register
//  0x019   8  SEEI                   Set Enable Error Interrupt Register
//  0x01A   8  CERQ                   Clear Enable Request Register
//  0x01B   8  SERQ                   Set Enable Request Register
//  0x01C   8  CDNE                   Clear DONE Status Bit Register
//  0x01D   8  SSRT                   Set START Bit Register
//  0x01E   8  CERR                   Clear Error Register
//  0x01F   8  CINT                   Clear Interrupt Request Register
//  0x024  32  INT                    Interrupt Request Register
//  0x02C  32  ERR                    Error Register
//  0x034  32  HRS                    Hardware Request Status Register
//  0x044  32  EARS                   Enable Asynchronous Request in Stop Register
//  0x100   8  DCHPRI3                Channel n Priority Register
//  0x101   8  DCHPRI2                Channel n Priority Register
//  0x102   8  DCHPRI1                Channel n Priority Register
//  0x103   8  DCHPRI0                Channel n Priority Register
//  0x104   8  DCHPRI7                Channel n Priority Register
//  0x105   8  DCHPRI6                Channel n Priority Register
//  0x106   8  DCHPRI5                Channel n Priority Register
//  0x107   8  DCHPRI4                Channel n Priority Register
//  0x108   8  DCHPRI11               Channel n Priority Register
//  0x109   8  DCHPRI10               Channel n Priority Register
//  0x10A   8  DCHPRI9                Channel n Priority Register
//  0x10B   8  DCHPRI8                Channel n Priority Register
//  0x10C   8  DCHPRI15               Channel n Priority Register
//  0x10D   8  DCHPRI14               Channel n Priority Register
//  0x10E   8  DCHPRI13               Channel n Priority Register
//  0x10F   8  DCHPRI12               Channel n Priority Register
//  0x110   8  DCHPRI19               Channel n Priority Register
//  0x111   8  DCHPRI18               Channel n Priority Register
//  0x112   8  DCHPRI17               Channel n Priority Register
//  0x113   8  DCHPRI16               Channel n Priority Register
//  0x114   8  DCHPRI23               Channel n Priority Register
//  0x115   8  DCHPRI22               Channel n Priority Register
//  0x116   8  DCHPRI21               Channel n Priority Register
//  0x117   8  DCHPRI20               Channel n Priority Register
//  0x118   8  DCHPRI27               Channel n Priority Register
//  0x119   8  DCHPRI26               Channel n Priority Register
//  0x11A   8  DCHPRI25               Channel n Priority Register
//  0x11B   8  DCHPRI24               Channel n Priority Register
//  0x11C   8  DCHPRI31               Channel n Priority Register
//  0x11D   8  DCHPRI30               Channel n Priority Register
//  0x11E   8  DCHPRI29               Channel n Priority Register
//  0x11F   8  DCHPRI28               Channel n Priority Register
//  0x1000 32  TCD0_SADDR             TCD Source Address
//  0x1004 16  TCD0_SOFF              TCD Signed Source Address Offset
//  0x1006 16  TCD0_ATTR              TCD Transfer Attributes
//  0x1008 32  TCD0_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1008 32  TCD0_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1008 32  TCD0_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x100C 32  TCD0_SLAST             TCD Last Source Address Adjustment
//  0x1010 32  TCD0_DADDR             TCD Destination Address
//  0x1014 16  TCD0_DOFF              TCD Signed Destination Address Offset
//  0x1016 16  TCD0_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1016 16  TCD0_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1018 32  TCD0_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x101C 16  TCD0_CSR               TCD Control and Status
//  0x101E 16  TCD0_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x101E 16  TCD0_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1020 32  TCD1_SADDR             TCD Source Address
//  0x1024 16  TCD1_SOFF              TCD Signed Source Address Offset
//  0x1026 16  TCD1_ATTR              TCD Transfer Attributes
//  0x1028 32  TCD1_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1028 32  TCD1_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1028 32  TCD1_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x102C 32  TCD1_SLAST             TCD Last Source Address Adjustment
//  0x1030 32  TCD1_DADDR             TCD Destination Address
//  0x1034 16  TCD1_DOFF              TCD Signed Destination Address Offset
//  0x1036 16  TCD1_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1036 16  TCD1_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1038 32  TCD1_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x103C 16  TCD1_CSR               TCD Control and Status
//  0x103E 16  TCD1_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x103E 16  TCD1_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1040 32  TCD2_SADDR             TCD Source Address
//  0x1044 16  TCD2_SOFF              TCD Signed Source Address Offset
//  0x1046 16  TCD2_ATTR              TCD Transfer Attributes
//  0x1048 32  TCD2_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1048 32  TCD2_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1048 32  TCD2_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x104C 32  TCD2_SLAST             TCD Last Source Address Adjustment
//  0x1050 32  TCD2_DADDR             TCD Destination Address
//  0x1054 16  TCD2_DOFF              TCD Signed Destination Address Offset
//  0x1056 16  TCD2_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1056 16  TCD2_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1058 32  TCD2_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x105C 16  TCD2_CSR               TCD Control and Status
//  0x105E 16  TCD2_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x105E 16  TCD2_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1060 32  TCD3_SADDR             TCD Source Address
//  0x1064 16  TCD3_SOFF              TCD Signed Source Address Offset
//  0x1066 16  TCD3_ATTR              TCD Transfer Attributes
//  0x1068 32  TCD3_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1068 32  TCD3_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1068 32  TCD3_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x106C 32  TCD3_SLAST             TCD Last Source Address Adjustment
//  0x1070 32  TCD3_DADDR             TCD Destination Address
//  0x1074 16  TCD3_DOFF              TCD Signed Destination Address Offset
//  0x1076 16  TCD3_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1076 16  TCD3_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1078 32  TCD3_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x107C 16  TCD3_CSR               TCD Control and Status
//  0x107E 16  TCD3_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x107E 16  TCD3_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1080 32  TCD4_SADDR             TCD Source Address
//  0x1084 16  TCD4_SOFF              TCD Signed Source Address Offset
//  0x1086 16  TCD4_ATTR              TCD Transfer Attributes
//  0x1088 32  TCD4_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1088 32  TCD4_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1088 32  TCD4_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x108C 32  TCD4_SLAST             TCD Last Source Address Adjustment
//  0x1090 32  TCD4_DADDR             TCD Destination Address
//  0x1094 16  TCD4_DOFF              TCD Signed Destination Address Offset
//  0x1096 16  TCD4_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1096 16  TCD4_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1098 32  TCD4_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x109C 16  TCD4_CSR               TCD Control and Status
//  0x109E 16  TCD4_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x109E 16  TCD4_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10A0 32  TCD5_SADDR             TCD Source Address
//  0x10A4 16  TCD5_SOFF              TCD Signed Source Address Offset
//  0x10A6 16  TCD5_ATTR              TCD Transfer Attributes
//  0x10A8 32  TCD5_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10A8 32  TCD5_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10A8 32  TCD5_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10AC 32  TCD5_SLAST             TCD Last Source Address Adjustment
//  0x10B0 32  TCD5_DADDR             TCD Destination Address
//  0x10B4 16  TCD5_DOFF              TCD Signed Destination Address Offset
//  0x10B6 16  TCD5_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10B6 16  TCD5_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10B8 32  TCD5_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10BC 16  TCD5_CSR               TCD Control and Status
//  0x10BE 16  TCD5_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10BE 16  TCD5_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10C0 32  TCD6_SADDR             TCD Source Address
//  0x10C4 16  TCD6_SOFF              TCD Signed Source Address Offset
//  0x10C6 16  TCD6_ATTR              TCD Transfer Attributes
//  0x10C8 32  TCD6_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10C8 32  TCD6_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10C8 32  TCD6_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10CC 32  TCD6_SLAST             TCD Last Source Address Adjustment
//  0x10D0 32  TCD6_DADDR             TCD Destination Address
//  0x10D4 16  TCD6_DOFF              TCD Signed Destination Address Offset
//  0x10D6 16  TCD6_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10D6 16  TCD6_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10D8 32  TCD6_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10DC 16  TCD6_CSR               TCD Control and Status
//  0x10DE 16  TCD6_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10DE 16  TCD6_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10E0 32  TCD7_SADDR             TCD Source Address
//  0x10E4 16  TCD7_SOFF              TCD Signed Source Address Offset
//  0x10E6 16  TCD7_ATTR              TCD Transfer Attributes
//  0x10E8 32  TCD7_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x10E8 32  TCD7_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x10E8 32  TCD7_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x10EC 32  TCD7_SLAST             TCD Last Source Address Adjustment
//  0x10F0 32  TCD7_DADDR             TCD Destination Address
//  0x10F4 16  TCD7_DOFF              TCD Signed Destination Address Offset
//  0x10F6 16  TCD7_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x10F6 16  TCD7_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10F8 32  TCD7_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x10FC 16  TCD7_CSR               TCD Control and Status
//  0x10FE 16  TCD7_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x10FE 16  TCD7_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1100 32  TCD8_SADDR             TCD Source Address
//  0x1104 16  TCD8_SOFF              TCD Signed Source Address Offset
//  0x1106 16  TCD8_ATTR              TCD Transfer Attributes
//  0x1108 32  TCD8_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1108 32  TCD8_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1108 32  TCD8_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x110C 32  TCD8_SLAST             TCD Last Source Address Adjustment
//  0x1110 32  TCD8_DADDR             TCD Destination Address
//  0x1114 16  TCD8_DOFF              TCD Signed Destination Address Offset
//  0x1116 16  TCD8_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1116 16  TCD8_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1118 32  TCD8_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x111C 16  TCD8_CSR               TCD Control and Status
//  0x111E 16  TCD8_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x111E 16  TCD8_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1120 32  TCD9_SADDR             TCD Source Address
//  0x1124 16  TCD9_SOFF              TCD Signed Source Address Offset
//  0x1126 16  TCD9_ATTR              TCD Transfer Attributes
//  0x1128 32  TCD9_NBYTES_MLNO       TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1128 32  TCD9_NBYTES_MLOFFNO    TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1128 32  TCD9_NBYTES_MLOFFYES   TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x112C 32  TCD9_SLAST             TCD Last Source Address Adjustment
//  0x1130 32  TCD9_DADDR             TCD Destination Address
//  0x1134 16  TCD9_DOFF              TCD Signed Destination Address Offset
//  0x1136 16  TCD9_CITER_ELINKYES    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1136 16  TCD9_CITER_ELINKNO     TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1138 32  TCD9_DLASTSGA          TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x113C 16  TCD9_CSR               TCD Control and Status
//  0x113E 16  TCD9_BITER_ELINKYES    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x113E 16  TCD9_BITER_ELINKNO     TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1140 32  TCD10_SADDR            TCD Source Address
//  0x1144 16  TCD10_SOFF             TCD Signed Source Address Offset
//  0x1146 16  TCD10_ATTR             TCD Transfer Attributes
//  0x1148 32  TCD10_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1148 32  TCD10_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1148 32  TCD10_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x114C 32  TCD10_SLAST            TCD Last Source Address Adjustment
//  0x1150 32  TCD10_DADDR            TCD Destination Address
//  0x1154 16  TCD10_DOFF             TCD Signed Destination Address Offset
//  0x1156 16  TCD10_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1156 16  TCD10_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1158 32  TCD10_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x115C 16  TCD10_CSR              TCD Control and Status
//  0x115E 16  TCD10_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x115E 16  TCD10_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1160 32  TCD11_SADDR            TCD Source Address
//  0x1164 16  TCD11_SOFF             TCD Signed Source Address Offset
//  0x1166 16  TCD11_ATTR             TCD Transfer Attributes
//  0x1168 32  TCD11_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1168 32  TCD11_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1168 32  TCD11_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x116C 32  TCD11_SLAST            TCD Last Source Address Adjustment
//  0x1170 32  TCD11_DADDR            TCD Destination Address
//  0x1174 16  TCD11_DOFF             TCD Signed Destination Address Offset
//  0x1176 16  TCD11_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1176 16  TCD11_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1178 32  TCD11_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x117C 16  TCD11_CSR              TCD Control and Status
//  0x117E 16  TCD11_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x117E 16  TCD11_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1180 32  TCD12_SADDR            TCD Source Address
//  0x1184 16  TCD12_SOFF             TCD Signed Source Address Offset
//  0x1186 16  TCD12_ATTR             TCD Transfer Attributes
//  0x1188 32  TCD12_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1188 32  TCD12_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1188 32  TCD12_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x118C 32  TCD12_SLAST            TCD Last Source Address Adjustment
//  0x1190 32  TCD12_DADDR            TCD Destination Address
//  0x1194 16  TCD12_DOFF             TCD Signed Destination Address Offset
//  0x1196 16  TCD12_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1196 16  TCD12_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1198 32  TCD12_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x119C 16  TCD12_CSR              TCD Control and Status
//  0x119E 16  TCD12_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x119E 16  TCD12_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11A0 32  TCD13_SADDR            TCD Source Address
//  0x11A4 16  TCD13_SOFF             TCD Signed Source Address Offset
//  0x11A6 16  TCD13_ATTR             TCD Transfer Attributes
//  0x11A8 32  TCD13_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11A8 32  TCD13_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11A8 32  TCD13_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11AC 32  TCD13_SLAST            TCD Last Source Address Adjustment
//  0x11B0 32  TCD13_DADDR            TCD Destination Address
//  0x11B4 16  TCD13_DOFF             TCD Signed Destination Address Offset
//  0x11B6 16  TCD13_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11B6 16  TCD13_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11B8 32  TCD13_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11BC 16  TCD13_CSR              TCD Control and Status
//  0x11BE 16  TCD13_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11BE 16  TCD13_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11C0 32  TCD14_SADDR            TCD Source Address
//  0x11C4 16  TCD14_SOFF             TCD Signed Source Address Offset
//  0x11C6 16  TCD14_ATTR             TCD Transfer Attributes
//  0x11C8 32  TCD14_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11C8 32  TCD14_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11C8 32  TCD14_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11CC 32  TCD14_SLAST            TCD Last Source Address Adjustment
//  0x11D0 32  TCD14_DADDR            TCD Destination Address
//  0x11D4 16  TCD14_DOFF             TCD Signed Destination Address Offset
//  0x11D6 16  TCD14_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11D6 16  TCD14_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11D8 32  TCD14_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11DC 16  TCD14_CSR              TCD Control and Status
//  0x11DE 16  TCD14_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11DE 16  TCD14_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11E0 32  TCD15_SADDR            TCD Source Address
//  0x11E4 16  TCD15_SOFF             TCD Signed Source Address Offset
//  0x11E6 16  TCD15_ATTR             TCD Transfer Attributes
//  0x11E8 32  TCD15_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x11E8 32  TCD15_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x11E8 32  TCD15_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x11EC 32  TCD15_SLAST            TCD Last Source Address Adjustment
//  0x11F0 32  TCD15_DADDR            TCD Destination Address
//  0x11F4 16  TCD15_DOFF             TCD Signed Destination Address Offset
//  0x11F6 16  TCD15_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11F6 16  TCD15_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x11F8 32  TCD15_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x11FC 16  TCD15_CSR              TCD Control and Status
//  0x11FE 16  TCD15_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x11FE 16  TCD15_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1200 32  TCD16_SADDR            TCD Source Address
//  0x1204 16  TCD16_SOFF             TCD Signed Source Address Offset
//  0x1206 16  TCD16_ATTR             TCD Transfer Attributes
//  0x1208 32  TCD16_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1208 32  TCD16_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1208 32  TCD16_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x120C 32  TCD16_SLAST            TCD Last Source Address Adjustment
//  0x1210 32  TCD16_DADDR            TCD Destination Address
//  0x1214 16  TCD16_DOFF             TCD Signed Destination Address Offset
//  0x1216 16  TCD16_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1216 16  TCD16_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1218 32  TCD16_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x121C 16  TCD16_CSR              TCD Control and Status
//  0x121E 16  TCD16_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x121E 16  TCD16_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1220 32  TCD17_SADDR            TCD Source Address
//  0x1224 16  TCD17_SOFF             TCD Signed Source Address Offset
//  0x1226 16  TCD17_ATTR             TCD Transfer Attributes
//  0x1228 32  TCD17_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1228 32  TCD17_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1228 32  TCD17_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x122C 32  TCD17_SLAST            TCD Last Source Address Adjustment
//  0x1230 32  TCD17_DADDR            TCD Destination Address
//  0x1234 16  TCD17_DOFF             TCD Signed Destination Address Offset
//  0x1236 16  TCD17_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1236 16  TCD17_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1238 32  TCD17_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x123C 16  TCD17_CSR              TCD Control and Status
//  0x123E 16  TCD17_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x123E 16  TCD17_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1240 32  TCD18_SADDR            TCD Source Address
//  0x1244 16  TCD18_SOFF             TCD Signed Source Address Offset
//  0x1246 16  TCD18_ATTR             TCD Transfer Attributes
//  0x1248 32  TCD18_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1248 32  TCD18_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1248 32  TCD18_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x124C 32  TCD18_SLAST            TCD Last Source Address Adjustment
//  0x1250 32  TCD18_DADDR            TCD Destination Address
//  0x1254 16  TCD18_DOFF             TCD Signed Destination Address Offset
//  0x1256 16  TCD18_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1256 16  TCD18_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1258 32  TCD18_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x125C 16  TCD18_CSR              TCD Control and Status
//  0x125E 16  TCD18_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x125E 16  TCD18_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1260 32  TCD19_SADDR            TCD Source Address
//  0x1264 16  TCD19_SOFF             TCD Signed Source Address Offset
//  0x1266 16  TCD19_ATTR             TCD Transfer Attributes
//  0x1268 32  TCD19_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1268 32  TCD19_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1268 32  TCD19_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x126C 32  TCD19_SLAST            TCD Last Source Address Adjustment
//  0x1270 32  TCD19_DADDR            TCD Destination Address
//  0x1274 16  TCD19_DOFF             TCD Signed Destination Address Offset
//  0x1276 16  TCD19_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1276 16  TCD19_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1278 32  TCD19_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x127C 16  TCD19_CSR              TCD Control and Status
//  0x127E 16  TCD19_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x127E 16  TCD19_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1280 32  TCD20_SADDR            TCD Source Address
//  0x1284 16  TCD20_SOFF             TCD Signed Source Address Offset
//  0x1286 16  TCD20_ATTR             TCD Transfer Attributes
//  0x1288 32  TCD20_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1288 32  TCD20_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1288 32  TCD20_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x128C 32  TCD20_SLAST            TCD Last Source Address Adjustment
//  0x1290 32  TCD20_DADDR            TCD Destination Address
//  0x1294 16  TCD20_DOFF             TCD Signed Destination Address Offset
//  0x1296 16  TCD20_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1296 16  TCD20_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1298 32  TCD20_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x129C 16  TCD20_CSR              TCD Control and Status
//  0x129E 16  TCD20_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x129E 16  TCD20_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12A0 32  TCD21_SADDR            TCD Source Address
//  0x12A4 16  TCD21_SOFF             TCD Signed Source Address Offset
//  0x12A6 16  TCD21_ATTR             TCD Transfer Attributes
//  0x12A8 32  TCD21_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12A8 32  TCD21_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12A8 32  TCD21_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12AC 32  TCD21_SLAST            TCD Last Source Address Adjustment
//  0x12B0 32  TCD21_DADDR            TCD Destination Address
//  0x12B4 16  TCD21_DOFF             TCD Signed Destination Address Offset
//  0x12B6 16  TCD21_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12B6 16  TCD21_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12B8 32  TCD21_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12BC 16  TCD21_CSR              TCD Control and Status
//  0x12BE 16  TCD21_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12BE 16  TCD21_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12C0 32  TCD22_SADDR            TCD Source Address
//  0x12C4 16  TCD22_SOFF             TCD Signed Source Address Offset
//  0x12C6 16  TCD22_ATTR             TCD Transfer Attributes
//  0x12C8 32  TCD22_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12C8 32  TCD22_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12C8 32  TCD22_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12CC 32  TCD22_SLAST            TCD Last Source Address Adjustment
//  0x12D0 32  TCD22_DADDR            TCD Destination Address
//  0x12D4 16  TCD22_DOFF             TCD Signed Destination Address Offset
//  0x12D6 16  TCD22_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12D6 16  TCD22_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12D8 32  TCD22_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12DC 16  TCD22_CSR              TCD Control and Status
//  0x12DE 16  TCD22_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12DE 16  TCD22_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12E0 32  TCD23_SADDR            TCD Source Address
//  0x12E4 16  TCD23_SOFF             TCD Signed Source Address Offset
//  0x12E6 16  TCD23_ATTR             TCD Transfer Attributes
//  0x12E8 32  TCD23_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x12E8 32  TCD23_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x12E8 32  TCD23_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x12EC 32  TCD23_SLAST            TCD Last Source Address Adjustment
//  0x12F0 32  TCD23_DADDR            TCD Destination Address
//  0x12F4 16  TCD23_DOFF             TCD Signed Destination Address Offset
//  0x12F6 16  TCD23_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12F6 16  TCD23_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x12F8 32  TCD23_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x12FC 16  TCD23_CSR              TCD Control and Status
//  0x12FE 16  TCD23_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x12FE 16  TCD23_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1300 32  TCD24_SADDR            TCD Source Address
//  0x1304 16  TCD24_SOFF             TCD Signed Source Address Offset
//  0x1306 16  TCD24_ATTR             TCD Transfer Attributes
//  0x1308 32  TCD24_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1308 32  TCD24_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1308 32  TCD24_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x130C 32  TCD24_SLAST            TCD Last Source Address Adjustment
//  0x1310 32  TCD24_DADDR            TCD Destination Address
//  0x1314 16  TCD24_DOFF             TCD Signed Destination Address Offset
//  0x1316 16  TCD24_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1316 16  TCD24_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1318 32  TCD24_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x131C 16  TCD24_CSR              TCD Control and Status
//  0x131E 16  TCD24_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x131E 16  TCD24_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1320 32  TCD25_SADDR            TCD Source Address
//  0x1324 16  TCD25_SOFF             TCD Signed Source Address Offset
//  0x1326 16  TCD25_ATTR             TCD Transfer Attributes
//  0x1328 32  TCD25_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1328 32  TCD25_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1328 32  TCD25_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x132C 32  TCD25_SLAST            TCD Last Source Address Adjustment
//  0x1330 32  TCD25_DADDR            TCD Destination Address
//  0x1334 16  TCD25_DOFF             TCD Signed Destination Address Offset
//  0x1336 16  TCD25_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1336 16  TCD25_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1338 32  TCD25_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x133C 16  TCD25_CSR              TCD Control and Status
//  0x133E 16  TCD25_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x133E 16  TCD25_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1340 32  TCD26_SADDR            TCD Source Address
//  0x1344 16  TCD26_SOFF             TCD Signed Source Address Offset
//  0x1346 16  TCD26_ATTR             TCD Transfer Attributes
//  0x1348 32  TCD26_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1348 32  TCD26_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1348 32  TCD26_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x134C 32  TCD26_SLAST            TCD Last Source Address Adjustment
//  0x1350 32  TCD26_DADDR            TCD Destination Address
//  0x1354 16  TCD26_DOFF             TCD Signed Destination Address Offset
//  0x1356 16  TCD26_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1356 16  TCD26_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1358 32  TCD26_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x135C 16  TCD26_CSR              TCD Control and Status
//  0x135E 16  TCD26_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x135E 16  TCD26_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1360 32  TCD27_SADDR            TCD Source Address
//  0x1364 16  TCD27_SOFF             TCD Signed Source Address Offset
//  0x1366 16  TCD27_ATTR             TCD Transfer Attributes
//  0x1368 32  TCD27_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1368 32  TCD27_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x1368 32  TCD27_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x136C 32  TCD27_SLAST            TCD Last Source Address Adjustment
//  0x1370 32  TCD27_DADDR            TCD Destination Address
//  0x1374 16  TCD27_DOFF             TCD Signed Destination Address Offset
//  0x1376 16  TCD27_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1376 16  TCD27_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1378 32  TCD27_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x137C 16  TCD27_CSR              TCD Control and Status
//  0x137E 16  TCD27_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x137E 16  TCD27_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1380 32  TCD28_SADDR            TCD Source Address
//  0x1384 16  TCD28_SOFF             TCD Signed Source Address Offset
//  0x1386 16  TCD28_ATTR             TCD Transfer Attributes
//  0x1388 32  TCD28_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x1388 32  TCD28_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x1388 32  TCD28_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x138C 32  TCD28_SLAST            TCD Last Source Address Adjustment
//  0x1390 32  TCD28_DADDR            TCD Destination Address
//  0x1394 16  TCD28_DOFF             TCD Signed Destination Address Offset
//  0x1396 16  TCD28_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x1396 16  TCD28_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x1398 32  TCD28_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x139C 16  TCD28_CSR              TCD Control and Status
//  0x139E 16  TCD28_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x139E 16  TCD28_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13A0 32  TCD29_SADDR            TCD Source Address
//  0x13A4 16  TCD29_SOFF             TCD Signed Source Address Offset
//  0x13A6 16  TCD29_ATTR             TCD Transfer Attributes
//  0x13A8 32  TCD29_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13A8 32  TCD29_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13A8 32  TCD29_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13AC 32  TCD29_SLAST            TCD Last Source Address Adjustment
//  0x13B0 32  TCD29_DADDR            TCD Destination Address
//  0x13B4 16  TCD29_DOFF             TCD Signed Destination Address Offset
//  0x13B6 16  TCD29_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13B6 16  TCD29_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13B8 32  TCD29_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13BC 16  TCD29_CSR              TCD Control and Status
//  0x13BE 16  TCD29_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13BE 16  TCD29_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13C0 32  TCD30_SADDR            TCD Source Address
//  0x13C4 16  TCD30_SOFF             TCD Signed Source Address Offset
//  0x13C6 16  TCD30_ATTR             TCD Transfer Attributes
//  0x13C8 32  TCD30_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13C8 32  TCD30_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13C8 32  TCD30_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13CC 32  TCD30_SLAST            TCD Last Source Address Adjustment
//  0x13D0 32  TCD30_DADDR            TCD Destination Address
//  0x13D4 16  TCD30_DOFF             TCD Signed Destination Address Offset
//  0x13D6 16  TCD30_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13D6 16  TCD30_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13D8 32  TCD30_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13DC 16  TCD30_CSR              TCD Control and Status
//  0x13DE 16  TCD30_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13DE 16  TCD30_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13E0 32  TCD31_SADDR            TCD Source Address
//  0x13E4 16  TCD31_SOFF             TCD Signed Source Address Offset
//  0x13E6 16  TCD31_ATTR             TCD Transfer Attributes
//  0x13E8 32  TCD31_NBYTES_MLNO      TCD Minor Byte Count (Minor Loop Mapping Disabled)
//  0x13E8 32  TCD31_NBYTES_MLOFFNO   TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
//  0x13E8 32  TCD31_NBYTES_MLOFFYES  TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
//  0x13EC 32  TCD31_SLAST            TCD Last Source Address Adjustment
//  0x13F0 32  TCD31_DADDR            TCD Destination Address
//  0x13F4 16  TCD31_DOFF             TCD Signed Destination Address Offset
//  0x13F6 16  TCD31_CITER_ELINKNO    TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13F6 16  TCD31_CITER_ELINKYES   TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//  0x13F8 32  TCD31_DLASTSGA         TCD Last Destination Address Adjustment/Scatter Gather Address
//  0x13FC 16  TCD31_CSR              TCD Control and Status
//  0x13FE 16  TCD31_BITER_ELINKNO    TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//  0x13FE 16  TCD31_BITER_ELINKYES   TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package dma

const (
	EDBG     CR = 0x01 << 1  //+ Enable Debug
	EDBG_0   CR = 0x00 << 1  //  When in debug mode, the DMA continues to operate.
	EDBG_1   CR = 0x01 << 1  //  When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
	ERCA     CR = 0x01 << 2  //+ Enable Round Robin Channel Arbitration
	ERCA_0   CR = 0x00 << 2  //  Fixed priority arbitration is used for channel selection within each group.
	ERCA_1   CR = 0x01 << 2  //  Round robin arbitration is used for channel selection within each group.
	ERGA     CR = 0x01 << 3  //+ Enable Round Robin Group Arbitration
	ERGA_0   CR = 0x00 << 3  //  Fixed priority arbitration is used for selection among the groups.
	ERGA_1   CR = 0x01 << 3  //  Round robin arbitration is used for selection among the groups.
	HOE      CR = 0x01 << 4  //+ Halt On Error
	HOE_0    CR = 0x00 << 4  //  Normal operation
	HOE_1    CR = 0x01 << 4  //  Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
	HALT     CR = 0x01 << 5  //+ Halt DMA Operations
	HALT_0   CR = 0x00 << 5  //  Normal operation
	HALT_1   CR = 0x01 << 5  //  Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
	CLM      CR = 0x01 << 6  //+ Continuous Link Mode
	CLM_0    CR = 0x00 << 6  //  A minor loop channel link made to itself goes through channel arbitration before being activated again.
	CLM_1    CR = 0x01 << 6  //  A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
	EMLM     CR = 0x01 << 7  //+ Enable Minor Loop Mapping
	EMLM_0   CR = 0x00 << 7  //  Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
	EMLM_1   CR = 0x01 << 7  //  Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
	GRP0PRI  CR = 0x01 << 8  //+ Channel Group 0 Priority
	GRP1PRI  CR = 0x01 << 10 //+ Channel Group 1 Priority
	ECX      CR = 0x01 << 16 //+ Error Cancel Transfer
	ECX_0    CR = 0x00 << 16 //  Normal operation
	ECX_1    CR = 0x01 << 16 //  Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
	CX       CR = 0x01 << 17 //+ Cancel Transfer
	CX_0     CR = 0x00 << 17 //  Normal operation
	CX_1     CR = 0x01 << 17 //  Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
	ACTIVE   CR = 0x01 << 31 //+ DMA Active Status
	ACTIVE_0 CR = 0x00 << 31 //  eDMA is idle.
	ACTIVE_1 CR = 0x01 << 31 //  eDMA is executing a channel.
)

const (
	EDBGn    = 1
	ERCAn    = 2
	ERGAn    = 3
	HOEn     = 4
	HALTn    = 5
	CLMn     = 6
	EMLMn    = 7
	GRP0PRIn = 8
	GRP1PRIn = 10
	ECXn     = 16
	CXn      = 17
	ACTIVEn  = 31
)

const (
	DBE    ES = 0x01 << 0  //+ Destination Bus Error
	DBE_0  ES = 0x00 << 0  //  No destination bus error
	DBE_1  ES = 0x01 << 0  //  The last recorded error was a bus error on a destination write
	SBE    ES = 0x01 << 1  //+ Source Bus Error
	SBE_0  ES = 0x00 << 1  //  No source bus error
	SBE_1  ES = 0x01 << 1  //  The last recorded error was a bus error on a source read
	SGE    ES = 0x01 << 2  //+ Scatter/Gather Configuration Error
	SGE_0  ES = 0x00 << 2  //  No scatter/gather configuration error
	SGE_1  ES = 0x01 << 2  //  The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
	NCE    ES = 0x01 << 3  //+ NBYTES/CITER Configuration Error
	NCE_0  ES = 0x00 << 3  //  No NBYTES/CITER configuration error
	NCE_1  ES = 0x01 << 3  //  The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
	DOE    ES = 0x01 << 4  //+ Destination Offset Error
	DOE_0  ES = 0x00 << 4  //  No destination offset configuration error
	DOE_1  ES = 0x01 << 4  //  The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
	DAE    ES = 0x01 << 5  //+ Destination Address Error
	DAE_0  ES = 0x00 << 5  //  No destination address configuration error
	DAE_1  ES = 0x01 << 5  //  The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
	SOE    ES = 0x01 << 6  //+ Source Offset Error
	SOE_0  ES = 0x00 << 6  //  No source offset configuration error
	SOE_1  ES = 0x01 << 6  //  The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
	SAE    ES = 0x01 << 7  //+ Source Address Error
	SAE_0  ES = 0x00 << 7  //  No source address configuration error.
	SAE_1  ES = 0x01 << 7  //  The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
	ERRCHN ES = 0x1F << 8  //+ Error Channel Number or Canceled Channel Number
	CPE    ES = 0x01 << 14 //+ Channel Priority Error
	CPE_0  ES = 0x00 << 14 //  No channel priority error
	CPE_1  ES = 0x01 << 14 //  The last recorded error was a configuration error in the channel priorities within a group. Channel priorities within a group are not unique.
	GPE    ES = 0x01 << 15 //+ Group Priority Error
	GPE_0  ES = 0x00 << 15 //  No group priority error
	GPE_1  ES = 0x01 << 15 //  The last recorded error was a configuration error among the group priorities. All group priorities are not unique.
	ECX    ES = 0x01 << 16 //+ Transfer Canceled
	ECX_0  ES = 0x00 << 16 //  No canceled transfers
	ECX_1  ES = 0x01 << 16 //  The last recorded entry was a canceled transfer by the error cancel transfer input
	VLD    ES = 0x01 << 31 //+ VLD
	VLD_0  ES = 0x00 << 31 //  No ERR bits are set.
	VLD_1  ES = 0x01 << 31 //  At least one ERR bit is set indicating a valid error exists that has not been cleared.
)

const (
	DBEn    = 0
	SBEn    = 1
	SGEn    = 2
	NCEn    = 3
	DOEn    = 4
	DAEn    = 5
	SOEn    = 6
	SAEn    = 7
	ERRCHNn = 8
	CPEn    = 14
	GPEn    = 15
	ECXn    = 16
	VLDn    = 31
)

const (
	ERQ0    ERQ = 0x01 << 0  //+ Enable DMA Request 0
	ERQ0_0  ERQ = 0x00 << 0  //  The DMA request signal for the corresponding channel is disabled
	ERQ0_1  ERQ = 0x01 << 0  //  The DMA request signal for the corresponding channel is enabled
	ERQ1    ERQ = 0x01 << 1  //+ Enable DMA Request 1
	ERQ1_0  ERQ = 0x00 << 1  //  The DMA request signal for the corresponding channel is disabled
	ERQ1_1  ERQ = 0x01 << 1  //  The DMA request signal for the corresponding channel is enabled
	ERQ2    ERQ = 0x01 << 2  //+ Enable DMA Request 2
	ERQ2_0  ERQ = 0x00 << 2  //  The DMA request signal for the corresponding channel is disabled
	ERQ2_1  ERQ = 0x01 << 2  //  The DMA request signal for the corresponding channel is enabled
	ERQ3    ERQ = 0x01 << 3  //+ Enable DMA Request 3
	ERQ3_0  ERQ = 0x00 << 3  //  The DMA request signal for the corresponding channel is disabled
	ERQ3_1  ERQ = 0x01 << 3  //  The DMA request signal for the corresponding channel is enabled
	ERQ4    ERQ = 0x01 << 4  //+ Enable DMA Request 4
	ERQ4_0  ERQ = 0x00 << 4  //  The DMA request signal for the corresponding channel is disabled
	ERQ4_1  ERQ = 0x01 << 4  //  The DMA request signal for the corresponding channel is enabled
	ERQ5    ERQ = 0x01 << 5  //+ Enable DMA Request 5
	ERQ5_0  ERQ = 0x00 << 5  //  The DMA request signal for the corresponding channel is disabled
	ERQ5_1  ERQ = 0x01 << 5  //  The DMA request signal for the corresponding channel is enabled
	ERQ6    ERQ = 0x01 << 6  //+ Enable DMA Request 6
	ERQ6_0  ERQ = 0x00 << 6  //  The DMA request signal for the corresponding channel is disabled
	ERQ6_1  ERQ = 0x01 << 6  //  The DMA request signal for the corresponding channel is enabled
	ERQ7    ERQ = 0x01 << 7  //+ Enable DMA Request 7
	ERQ7_0  ERQ = 0x00 << 7  //  The DMA request signal for the corresponding channel is disabled
	ERQ7_1  ERQ = 0x01 << 7  //  The DMA request signal for the corresponding channel is enabled
	ERQ8    ERQ = 0x01 << 8  //+ Enable DMA Request 8
	ERQ8_0  ERQ = 0x00 << 8  //  The DMA request signal for the corresponding channel is disabled
	ERQ8_1  ERQ = 0x01 << 8  //  The DMA request signal for the corresponding channel is enabled
	ERQ9    ERQ = 0x01 << 9  //+ Enable DMA Request 9
	ERQ9_0  ERQ = 0x00 << 9  //  The DMA request signal for the corresponding channel is disabled
	ERQ9_1  ERQ = 0x01 << 9  //  The DMA request signal for the corresponding channel is enabled
	ERQ10   ERQ = 0x01 << 10 //+ Enable DMA Request 10
	ERQ10_0 ERQ = 0x00 << 10 //  The DMA request signal for the corresponding channel is disabled
	ERQ10_1 ERQ = 0x01 << 10 //  The DMA request signal for the corresponding channel is enabled
	ERQ11   ERQ = 0x01 << 11 //+ Enable DMA Request 11
	ERQ11_0 ERQ = 0x00 << 11 //  The DMA request signal for the corresponding channel is disabled
	ERQ11_1 ERQ = 0x01 << 11 //  The DMA request signal for the corresponding channel is enabled
	ERQ12   ERQ = 0x01 << 12 //+ Enable DMA Request 12
	ERQ12_0 ERQ = 0x00 << 12 //  The DMA request signal for the corresponding channel is disabled
	ERQ12_1 ERQ = 0x01 << 12 //  The DMA request signal for the corresponding channel is enabled
	ERQ13   ERQ = 0x01 << 13 //+ Enable DMA Request 13
	ERQ13_0 ERQ = 0x00 << 13 //  The DMA request signal for the corresponding channel is disabled
	ERQ13_1 ERQ = 0x01 << 13 //  The DMA request signal for the corresponding channel is enabled
	ERQ14   ERQ = 0x01 << 14 //+ Enable DMA Request 14
	ERQ14_0 ERQ = 0x00 << 14 //  The DMA request signal for the corresponding channel is disabled
	ERQ14_1 ERQ = 0x01 << 14 //  The DMA request signal for the corresponding channel is enabled
	ERQ15   ERQ = 0x01 << 15 //+ Enable DMA Request 15
	ERQ15_0 ERQ = 0x00 << 15 //  The DMA request signal for the corresponding channel is disabled
	ERQ15_1 ERQ = 0x01 << 15 //  The DMA request signal for the corresponding channel is enabled
	ERQ16   ERQ = 0x01 << 16 //+ Enable DMA Request 16
	ERQ16_0 ERQ = 0x00 << 16 //  The DMA request signal for the corresponding channel is disabled
	ERQ16_1 ERQ = 0x01 << 16 //  The DMA request signal for the corresponding channel is enabled
	ERQ17   ERQ = 0x01 << 17 //+ Enable DMA Request 17
	ERQ17_0 ERQ = 0x00 << 17 //  The DMA request signal for the corresponding channel is disabled
	ERQ17_1 ERQ = 0x01 << 17 //  The DMA request signal for the corresponding channel is enabled
	ERQ18   ERQ = 0x01 << 18 //+ Enable DMA Request 18
	ERQ18_0 ERQ = 0x00 << 18 //  The DMA request signal for the corresponding channel is disabled
	ERQ18_1 ERQ = 0x01 << 18 //  The DMA request signal for the corresponding channel is enabled
	ERQ19   ERQ = 0x01 << 19 //+ Enable DMA Request 19
	ERQ19_0 ERQ = 0x00 << 19 //  The DMA request signal for the corresponding channel is disabled
	ERQ19_1 ERQ = 0x01 << 19 //  The DMA request signal for the corresponding channel is enabled
	ERQ20   ERQ = 0x01 << 20 //+ Enable DMA Request 20
	ERQ20_0 ERQ = 0x00 << 20 //  The DMA request signal for the corresponding channel is disabled
	ERQ20_1 ERQ = 0x01 << 20 //  The DMA request signal for the corresponding channel is enabled
	ERQ21   ERQ = 0x01 << 21 //+ Enable DMA Request 21
	ERQ21_0 ERQ = 0x00 << 21 //  The DMA request signal for the corresponding channel is disabled
	ERQ21_1 ERQ = 0x01 << 21 //  The DMA request signal for the corresponding channel is enabled
	ERQ22   ERQ = 0x01 << 22 //+ Enable DMA Request 22
	ERQ22_0 ERQ = 0x00 << 22 //  The DMA request signal for the corresponding channel is disabled
	ERQ22_1 ERQ = 0x01 << 22 //  The DMA request signal for the corresponding channel is enabled
	ERQ23   ERQ = 0x01 << 23 //+ Enable DMA Request 23
	ERQ23_0 ERQ = 0x00 << 23 //  The DMA request signal for the corresponding channel is disabled
	ERQ23_1 ERQ = 0x01 << 23 //  The DMA request signal for the corresponding channel is enabled
	ERQ24   ERQ = 0x01 << 24 //+ Enable DMA Request 24
	ERQ24_0 ERQ = 0x00 << 24 //  The DMA request signal for the corresponding channel is disabled
	ERQ24_1 ERQ = 0x01 << 24 //  The DMA request signal for the corresponding channel is enabled
	ERQ25   ERQ = 0x01 << 25 //+ Enable DMA Request 25
	ERQ25_0 ERQ = 0x00 << 25 //  The DMA request signal for the corresponding channel is disabled
	ERQ25_1 ERQ = 0x01 << 25 //  The DMA request signal for the corresponding channel is enabled
	ERQ26   ERQ = 0x01 << 26 //+ Enable DMA Request 26
	ERQ26_0 ERQ = 0x00 << 26 //  The DMA request signal for the corresponding channel is disabled
	ERQ26_1 ERQ = 0x01 << 26 //  The DMA request signal for the corresponding channel is enabled
	ERQ27   ERQ = 0x01 << 27 //+ Enable DMA Request 27
	ERQ27_0 ERQ = 0x00 << 27 //  The DMA request signal for the corresponding channel is disabled
	ERQ27_1 ERQ = 0x01 << 27 //  The DMA request signal for the corresponding channel is enabled
	ERQ28   ERQ = 0x01 << 28 //+ Enable DMA Request 28
	ERQ28_0 ERQ = 0x00 << 28 //  The DMA request signal for the corresponding channel is disabled
	ERQ28_1 ERQ = 0x01 << 28 //  The DMA request signal for the corresponding channel is enabled
	ERQ29   ERQ = 0x01 << 29 //+ Enable DMA Request 29
	ERQ29_0 ERQ = 0x00 << 29 //  The DMA request signal for the corresponding channel is disabled
	ERQ29_1 ERQ = 0x01 << 29 //  The DMA request signal for the corresponding channel is enabled
	ERQ30   ERQ = 0x01 << 30 //+ Enable DMA Request 30
	ERQ30_0 ERQ = 0x00 << 30 //  The DMA request signal for the corresponding channel is disabled
	ERQ30_1 ERQ = 0x01 << 30 //  The DMA request signal for the corresponding channel is enabled
	ERQ31   ERQ = 0x01 << 31 //+ Enable DMA Request 31
	ERQ31_0 ERQ = 0x00 << 31 //  The DMA request signal for the corresponding channel is disabled
	ERQ31_1 ERQ = 0x01 << 31 //  The DMA request signal for the corresponding channel is enabled
)

const (
	ERQ0n  = 0
	ERQ1n  = 1
	ERQ2n  = 2
	ERQ3n  = 3
	ERQ4n  = 4
	ERQ5n  = 5
	ERQ6n  = 6
	ERQ7n  = 7
	ERQ8n  = 8
	ERQ9n  = 9
	ERQ10n = 10
	ERQ11n = 11
	ERQ12n = 12
	ERQ13n = 13
	ERQ14n = 14
	ERQ15n = 15
	ERQ16n = 16
	ERQ17n = 17
	ERQ18n = 18
	ERQ19n = 19
	ERQ20n = 20
	ERQ21n = 21
	ERQ22n = 22
	ERQ23n = 23
	ERQ24n = 24
	ERQ25n = 25
	ERQ26n = 26
	ERQ27n = 27
	ERQ28n = 28
	ERQ29n = 29
	ERQ30n = 30
	ERQ31n = 31
)

const (
	EEI0    EEI = 0x01 << 0  //+ Enable Error Interrupt 0
	EEI0_0  EEI = 0x00 << 0  //  The error signal for corresponding channel does not generate an error interrupt
	EEI0_1  EEI = 0x01 << 0  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI1    EEI = 0x01 << 1  //+ Enable Error Interrupt 1
	EEI1_0  EEI = 0x00 << 1  //  The error signal for corresponding channel does not generate an error interrupt
	EEI1_1  EEI = 0x01 << 1  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI2    EEI = 0x01 << 2  //+ Enable Error Interrupt 2
	EEI2_0  EEI = 0x00 << 2  //  The error signal for corresponding channel does not generate an error interrupt
	EEI2_1  EEI = 0x01 << 2  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI3    EEI = 0x01 << 3  //+ Enable Error Interrupt 3
	EEI3_0  EEI = 0x00 << 3  //  The error signal for corresponding channel does not generate an error interrupt
	EEI3_1  EEI = 0x01 << 3  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI4    EEI = 0x01 << 4  //+ Enable Error Interrupt 4
	EEI4_0  EEI = 0x00 << 4  //  The error signal for corresponding channel does not generate an error interrupt
	EEI4_1  EEI = 0x01 << 4  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI5    EEI = 0x01 << 5  //+ Enable Error Interrupt 5
	EEI5_0  EEI = 0x00 << 5  //  The error signal for corresponding channel does not generate an error interrupt
	EEI5_1  EEI = 0x01 << 5  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI6    EEI = 0x01 << 6  //+ Enable Error Interrupt 6
	EEI6_0  EEI = 0x00 << 6  //  The error signal for corresponding channel does not generate an error interrupt
	EEI6_1  EEI = 0x01 << 6  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI7    EEI = 0x01 << 7  //+ Enable Error Interrupt 7
	EEI7_0  EEI = 0x00 << 7  //  The error signal for corresponding channel does not generate an error interrupt
	EEI7_1  EEI = 0x01 << 7  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI8    EEI = 0x01 << 8  //+ Enable Error Interrupt 8
	EEI8_0  EEI = 0x00 << 8  //  The error signal for corresponding channel does not generate an error interrupt
	EEI8_1  EEI = 0x01 << 8  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI9    EEI = 0x01 << 9  //+ Enable Error Interrupt 9
	EEI9_0  EEI = 0x00 << 9  //  The error signal for corresponding channel does not generate an error interrupt
	EEI9_1  EEI = 0x01 << 9  //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI10   EEI = 0x01 << 10 //+ Enable Error Interrupt 10
	EEI10_0 EEI = 0x00 << 10 //  The error signal for corresponding channel does not generate an error interrupt
	EEI10_1 EEI = 0x01 << 10 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI11   EEI = 0x01 << 11 //+ Enable Error Interrupt 11
	EEI11_0 EEI = 0x00 << 11 //  The error signal for corresponding channel does not generate an error interrupt
	EEI11_1 EEI = 0x01 << 11 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI12   EEI = 0x01 << 12 //+ Enable Error Interrupt 12
	EEI12_0 EEI = 0x00 << 12 //  The error signal for corresponding channel does not generate an error interrupt
	EEI12_1 EEI = 0x01 << 12 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI13   EEI = 0x01 << 13 //+ Enable Error Interrupt 13
	EEI13_0 EEI = 0x00 << 13 //  The error signal for corresponding channel does not generate an error interrupt
	EEI13_1 EEI = 0x01 << 13 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI14   EEI = 0x01 << 14 //+ Enable Error Interrupt 14
	EEI14_0 EEI = 0x00 << 14 //  The error signal for corresponding channel does not generate an error interrupt
	EEI14_1 EEI = 0x01 << 14 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI15   EEI = 0x01 << 15 //+ Enable Error Interrupt 15
	EEI15_0 EEI = 0x00 << 15 //  The error signal for corresponding channel does not generate an error interrupt
	EEI15_1 EEI = 0x01 << 15 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI16   EEI = 0x01 << 16 //+ Enable Error Interrupt 16
	EEI16_0 EEI = 0x00 << 16 //  The error signal for corresponding channel does not generate an error interrupt
	EEI16_1 EEI = 0x01 << 16 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI17   EEI = 0x01 << 17 //+ Enable Error Interrupt 17
	EEI17_0 EEI = 0x00 << 17 //  The error signal for corresponding channel does not generate an error interrupt
	EEI17_1 EEI = 0x01 << 17 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI18   EEI = 0x01 << 18 //+ Enable Error Interrupt 18
	EEI18_0 EEI = 0x00 << 18 //  The error signal for corresponding channel does not generate an error interrupt
	EEI18_1 EEI = 0x01 << 18 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI19   EEI = 0x01 << 19 //+ Enable Error Interrupt 19
	EEI19_0 EEI = 0x00 << 19 //  The error signal for corresponding channel does not generate an error interrupt
	EEI19_1 EEI = 0x01 << 19 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI20   EEI = 0x01 << 20 //+ Enable Error Interrupt 20
	EEI20_0 EEI = 0x00 << 20 //  The error signal for corresponding channel does not generate an error interrupt
	EEI20_1 EEI = 0x01 << 20 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI21   EEI = 0x01 << 21 //+ Enable Error Interrupt 21
	EEI21_0 EEI = 0x00 << 21 //  The error signal for corresponding channel does not generate an error interrupt
	EEI21_1 EEI = 0x01 << 21 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI22   EEI = 0x01 << 22 //+ Enable Error Interrupt 22
	EEI22_0 EEI = 0x00 << 22 //  The error signal for corresponding channel does not generate an error interrupt
	EEI22_1 EEI = 0x01 << 22 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI23   EEI = 0x01 << 23 //+ Enable Error Interrupt 23
	EEI23_0 EEI = 0x00 << 23 //  The error signal for corresponding channel does not generate an error interrupt
	EEI23_1 EEI = 0x01 << 23 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI24   EEI = 0x01 << 24 //+ Enable Error Interrupt 24
	EEI24_0 EEI = 0x00 << 24 //  The error signal for corresponding channel does not generate an error interrupt
	EEI24_1 EEI = 0x01 << 24 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI25   EEI = 0x01 << 25 //+ Enable Error Interrupt 25
	EEI25_0 EEI = 0x00 << 25 //  The error signal for corresponding channel does not generate an error interrupt
	EEI25_1 EEI = 0x01 << 25 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI26   EEI = 0x01 << 26 //+ Enable Error Interrupt 26
	EEI26_0 EEI = 0x00 << 26 //  The error signal for corresponding channel does not generate an error interrupt
	EEI26_1 EEI = 0x01 << 26 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI27   EEI = 0x01 << 27 //+ Enable Error Interrupt 27
	EEI27_0 EEI = 0x00 << 27 //  The error signal for corresponding channel does not generate an error interrupt
	EEI27_1 EEI = 0x01 << 27 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI28   EEI = 0x01 << 28 //+ Enable Error Interrupt 28
	EEI28_0 EEI = 0x00 << 28 //  The error signal for corresponding channel does not generate an error interrupt
	EEI28_1 EEI = 0x01 << 28 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI29   EEI = 0x01 << 29 //+ Enable Error Interrupt 29
	EEI29_0 EEI = 0x00 << 29 //  The error signal for corresponding channel does not generate an error interrupt
	EEI29_1 EEI = 0x01 << 29 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI30   EEI = 0x01 << 30 //+ Enable Error Interrupt 30
	EEI30_0 EEI = 0x00 << 30 //  The error signal for corresponding channel does not generate an error interrupt
	EEI30_1 EEI = 0x01 << 30 //  The assertion of the error signal for corresponding channel generates an error interrupt request
	EEI31   EEI = 0x01 << 31 //+ Enable Error Interrupt 31
	EEI31_0 EEI = 0x00 << 31 //  The error signal for corresponding channel does not generate an error interrupt
	EEI31_1 EEI = 0x01 << 31 //  The assertion of the error signal for corresponding channel generates an error interrupt request
)

const (
	EEI0n  = 0
	EEI1n  = 1
	EEI2n  = 2
	EEI3n  = 3
	EEI4n  = 4
	EEI5n  = 5
	EEI6n  = 6
	EEI7n  = 7
	EEI8n  = 8
	EEI9n  = 9
	EEI10n = 10
	EEI11n = 11
	EEI12n = 12
	EEI13n = 13
	EEI14n = 14
	EEI15n = 15
	EEI16n = 16
	EEI17n = 17
	EEI18n = 18
	EEI19n = 19
	EEI20n = 20
	EEI21n = 21
	EEI22n = 22
	EEI23n = 23
	EEI24n = 24
	EEI25n = 25
	EEI26n = 26
	EEI27n = 27
	EEI28n = 28
	EEI29n = 29
	EEI30n = 30
	EEI31n = 31
)

const (
	CEEI   CEEI = 0x1F << 0 //+ Clear Enable Error Interrupt
	CAEE   CEEI = 0x01 << 6 //+ Clear All Enable Error Interrupts
	CAEE_0 CEEI = 0x00 << 6 //  Clear only the EEI bit specified in the CEEI field
	CAEE_1 CEEI = 0x01 << 6 //  Clear all bits in EEI
	NOP    CEEI = 0x01 << 7 //+ No Op enable
	NOP_0  CEEI = 0x00 << 7 //  Normal operation
	NOP_1  CEEI = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	CEEIn = 0
	CAEEn = 6
	NOPn  = 7
)

const (
	SEEI   SEEI = 0x1F << 0 //+ Set Enable Error Interrupt
	SAEE   SEEI = 0x01 << 6 //+ Sets All Enable Error Interrupts
	SAEE_0 SEEI = 0x00 << 6 //  Set only the EEI bit specified in the SEEI field.
	SAEE_1 SEEI = 0x01 << 6 //  Sets all bits in EEI
	NOP    SEEI = 0x01 << 7 //+ No Op enable
	NOP_0  SEEI = 0x00 << 7 //  Normal operation
	NOP_1  SEEI = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	SEEIn = 0
	SAEEn = 6
	NOPn  = 7
)

const (
	CERQ   CERQ = 0x1F << 0 //+ Clear Enable Request
	CAER   CERQ = 0x01 << 6 //+ Clear All Enable Requests
	CAER_0 CERQ = 0x00 << 6 //  Clear only the ERQ bit specified in the CERQ field
	CAER_1 CERQ = 0x01 << 6 //  Clear all bits in ERQ
	NOP    CERQ = 0x01 << 7 //+ No Op enable
	NOP_0  CERQ = 0x00 << 7 //  Normal operation
	NOP_1  CERQ = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	CERQn = 0
	CAERn = 6
	NOPn  = 7
)

const (
	SERQ   SERQ = 0x1F << 0 //+ Set Enable Request
	SAER   SERQ = 0x01 << 6 //+ Set All Enable Requests
	SAER_0 SERQ = 0x00 << 6 //  Set only the ERQ bit specified in the SERQ field
	SAER_1 SERQ = 0x01 << 6 //  Set all bits in ERQ
	NOP    SERQ = 0x01 << 7 //+ No Op enable
	NOP_0  SERQ = 0x00 << 7 //  Normal operation
	NOP_1  SERQ = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	SERQn = 0
	SAERn = 6
	NOPn  = 7
)

const (
	CDNE   CDNE = 0x1F << 0 //+ Clear DONE Bit
	CADN   CDNE = 0x01 << 6 //+ Clears All DONE Bits
	CADN_0 CDNE = 0x00 << 6 //  Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
	CADN_1 CDNE = 0x01 << 6 //  Clears all bits in TCDn_CSR[DONE]
	NOP    CDNE = 0x01 << 7 //+ No Op enable
	NOP_0  CDNE = 0x00 << 7 //  Normal operation
	NOP_1  CDNE = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	CDNEn = 0
	CADNn = 6
	NOPn  = 7
)

const (
	SSRT   SSRT = 0x1F << 0 //+ Set START Bit
	SAST   SSRT = 0x01 << 6 //+ Set All START Bits (activates all channels)
	SAST_0 SSRT = 0x00 << 6 //  Set only the TCDn_CSR[START] bit specified in the SSRT field
	SAST_1 SSRT = 0x01 << 6 //  Set all bits in TCDn_CSR[START]
	NOP    SSRT = 0x01 << 7 //+ No Op enable
	NOP_0  SSRT = 0x00 << 7 //  Normal operation
	NOP_1  SSRT = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	SSRTn = 0
	SASTn = 6
	NOPn  = 7
)

const (
	CERR   CERR = 0x1F << 0 //+ Clear Error Indicator
	CAEI   CERR = 0x01 << 6 //+ Clear All Error Indicators
	CAEI_0 CERR = 0x00 << 6 //  Clear only the ERR bit specified in the CERR field
	CAEI_1 CERR = 0x01 << 6 //  Clear all bits in ERR
	NOP    CERR = 0x01 << 7 //+ No Op enable
	NOP_0  CERR = 0x00 << 7 //  Normal operation
	NOP_1  CERR = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	CERRn = 0
	CAEIn = 6
	NOPn  = 7
)

const (
	CINT   CINT = 0x1F << 0 //+ Clear Interrupt Request
	CAIR   CINT = 0x01 << 6 //+ Clear All Interrupt Requests
	CAIR_0 CINT = 0x00 << 6 //  Clear only the INT bit specified in the CINT field
	CAIR_1 CINT = 0x01 << 6 //  Clear all bits in INT
	NOP    CINT = 0x01 << 7 //+ No Op enable
	NOP_0  CINT = 0x00 << 7 //  Normal operation
	NOP_1  CINT = 0x01 << 7 //  No operation, ignore the other bits in this register
)

const (
	CINTn = 0
	CAIRn = 6
	NOPn  = 7
)

const (
	INT0    INT = 0x01 << 0  //+ Interrupt Request 0
	INT0_0  INT = 0x00 << 0  //  The interrupt request for corresponding channel is cleared
	INT0_1  INT = 0x01 << 0  //  The interrupt request for corresponding channel is active
	INT1    INT = 0x01 << 1  //+ Interrupt Request 1
	INT1_0  INT = 0x00 << 1  //  The interrupt request for corresponding channel is cleared
	INT1_1  INT = 0x01 << 1  //  The interrupt request for corresponding channel is active
	INT2    INT = 0x01 << 2  //+ Interrupt Request 2
	INT2_0  INT = 0x00 << 2  //  The interrupt request for corresponding channel is cleared
	INT2_1  INT = 0x01 << 2  //  The interrupt request for corresponding channel is active
	INT3    INT = 0x01 << 3  //+ Interrupt Request 3
	INT3_0  INT = 0x00 << 3  //  The interrupt request for corresponding channel is cleared
	INT3_1  INT = 0x01 << 3  //  The interrupt request for corresponding channel is active
	INT4    INT = 0x01 << 4  //+ Interrupt Request 4
	INT4_0  INT = 0x00 << 4  //  The interrupt request for corresponding channel is cleared
	INT4_1  INT = 0x01 << 4  //  The interrupt request for corresponding channel is active
	INT5    INT = 0x01 << 5  //+ Interrupt Request 5
	INT5_0  INT = 0x00 << 5  //  The interrupt request for corresponding channel is cleared
	INT5_1  INT = 0x01 << 5  //  The interrupt request for corresponding channel is active
	INT6    INT = 0x01 << 6  //+ Interrupt Request 6
	INT6_0  INT = 0x00 << 6  //  The interrupt request for corresponding channel is cleared
	INT6_1  INT = 0x01 << 6  //  The interrupt request for corresponding channel is active
	INT7    INT = 0x01 << 7  //+ Interrupt Request 7
	INT7_0  INT = 0x00 << 7  //  The interrupt request for corresponding channel is cleared
	INT7_1  INT = 0x01 << 7  //  The interrupt request for corresponding channel is active
	INT8    INT = 0x01 << 8  //+ Interrupt Request 8
	INT8_0  INT = 0x00 << 8  //  The interrupt request for corresponding channel is cleared
	INT8_1  INT = 0x01 << 8  //  The interrupt request for corresponding channel is active
	INT9    INT = 0x01 << 9  //+ Interrupt Request 9
	INT9_0  INT = 0x00 << 9  //  The interrupt request for corresponding channel is cleared
	INT9_1  INT = 0x01 << 9  //  The interrupt request for corresponding channel is active
	INT10   INT = 0x01 << 10 //+ Interrupt Request 10
	INT10_0 INT = 0x00 << 10 //  The interrupt request for corresponding channel is cleared
	INT10_1 INT = 0x01 << 10 //  The interrupt request for corresponding channel is active
	INT11   INT = 0x01 << 11 //+ Interrupt Request 11
	INT11_0 INT = 0x00 << 11 //  The interrupt request for corresponding channel is cleared
	INT11_1 INT = 0x01 << 11 //  The interrupt request for corresponding channel is active
	INT12   INT = 0x01 << 12 //+ Interrupt Request 12
	INT12_0 INT = 0x00 << 12 //  The interrupt request for corresponding channel is cleared
	INT12_1 INT = 0x01 << 12 //  The interrupt request for corresponding channel is active
	INT13   INT = 0x01 << 13 //+ Interrupt Request 13
	INT13_0 INT = 0x00 << 13 //  The interrupt request for corresponding channel is cleared
	INT13_1 INT = 0x01 << 13 //  The interrupt request for corresponding channel is active
	INT14   INT = 0x01 << 14 //+ Interrupt Request 14
	INT14_0 INT = 0x00 << 14 //  The interrupt request for corresponding channel is cleared
	INT14_1 INT = 0x01 << 14 //  The interrupt request for corresponding channel is active
	INT15   INT = 0x01 << 15 //+ Interrupt Request 15
	INT15_0 INT = 0x00 << 15 //  The interrupt request for corresponding channel is cleared
	INT15_1 INT = 0x01 << 15 //  The interrupt request for corresponding channel is active
	INT16   INT = 0x01 << 16 //+ Interrupt Request 16
	INT16_0 INT = 0x00 << 16 //  The interrupt request for corresponding channel is cleared
	INT16_1 INT = 0x01 << 16 //  The interrupt request for corresponding channel is active
	INT17   INT = 0x01 << 17 //+ Interrupt Request 17
	INT17_0 INT = 0x00 << 17 //  The interrupt request for corresponding channel is cleared
	INT17_1 INT = 0x01 << 17 //  The interrupt request for corresponding channel is active
	INT18   INT = 0x01 << 18 //+ Interrupt Request 18
	INT18_0 INT = 0x00 << 18 //  The interrupt request for corresponding channel is cleared
	INT18_1 INT = 0x01 << 18 //  The interrupt request for corresponding channel is active
	INT19   INT = 0x01 << 19 //+ Interrupt Request 19
	INT19_0 INT = 0x00 << 19 //  The interrupt request for corresponding channel is cleared
	INT19_1 INT = 0x01 << 19 //  The interrupt request for corresponding channel is active
	INT20   INT = 0x01 << 20 //+ Interrupt Request 20
	INT20_0 INT = 0x00 << 20 //  The interrupt request for corresponding channel is cleared
	INT20_1 INT = 0x01 << 20 //  The interrupt request for corresponding channel is active
	INT21   INT = 0x01 << 21 //+ Interrupt Request 21
	INT21_0 INT = 0x00 << 21 //  The interrupt request for corresponding channel is cleared
	INT21_1 INT = 0x01 << 21 //  The interrupt request for corresponding channel is active
	INT22   INT = 0x01 << 22 //+ Interrupt Request 22
	INT22_0 INT = 0x00 << 22 //  The interrupt request for corresponding channel is cleared
	INT22_1 INT = 0x01 << 22 //  The interrupt request for corresponding channel is active
	INT23   INT = 0x01 << 23 //+ Interrupt Request 23
	INT23_0 INT = 0x00 << 23 //  The interrupt request for corresponding channel is cleared
	INT23_1 INT = 0x01 << 23 //  The interrupt request for corresponding channel is active
	INT24   INT = 0x01 << 24 //+ Interrupt Request 24
	INT24_0 INT = 0x00 << 24 //  The interrupt request for corresponding channel is cleared
	INT24_1 INT = 0x01 << 24 //  The interrupt request for corresponding channel is active
	INT25   INT = 0x01 << 25 //+ Interrupt Request 25
	INT25_0 INT = 0x00 << 25 //  The interrupt request for corresponding channel is cleared
	INT25_1 INT = 0x01 << 25 //  The interrupt request for corresponding channel is active
	INT26   INT = 0x01 << 26 //+ Interrupt Request 26
	INT26_0 INT = 0x00 << 26 //  The interrupt request for corresponding channel is cleared
	INT26_1 INT = 0x01 << 26 //  The interrupt request for corresponding channel is active
	INT27   INT = 0x01 << 27 //+ Interrupt Request 27
	INT27_0 INT = 0x00 << 27 //  The interrupt request for corresponding channel is cleared
	INT27_1 INT = 0x01 << 27 //  The interrupt request for corresponding channel is active
	INT28   INT = 0x01 << 28 //+ Interrupt Request 28
	INT28_0 INT = 0x00 << 28 //  The interrupt request for corresponding channel is cleared
	INT28_1 INT = 0x01 << 28 //  The interrupt request for corresponding channel is active
	INT29   INT = 0x01 << 29 //+ Interrupt Request 29
	INT29_0 INT = 0x00 << 29 //  The interrupt request for corresponding channel is cleared
	INT29_1 INT = 0x01 << 29 //  The interrupt request for corresponding channel is active
	INT30   INT = 0x01 << 30 //+ Interrupt Request 30
	INT30_0 INT = 0x00 << 30 //  The interrupt request for corresponding channel is cleared
	INT30_1 INT = 0x01 << 30 //  The interrupt request for corresponding channel is active
	INT31   INT = 0x01 << 31 //+ Interrupt Request 31
	INT31_0 INT = 0x00 << 31 //  The interrupt request for corresponding channel is cleared
	INT31_1 INT = 0x01 << 31 //  The interrupt request for corresponding channel is active
)

const (
	INT0n  = 0
	INT1n  = 1
	INT2n  = 2
	INT3n  = 3
	INT4n  = 4
	INT5n  = 5
	INT6n  = 6
	INT7n  = 7
	INT8n  = 8
	INT9n  = 9
	INT10n = 10
	INT11n = 11
	INT12n = 12
	INT13n = 13
	INT14n = 14
	INT15n = 15
	INT16n = 16
	INT17n = 17
	INT18n = 18
	INT19n = 19
	INT20n = 20
	INT21n = 21
	INT22n = 22
	INT23n = 23
	INT24n = 24
	INT25n = 25
	INT26n = 26
	INT27n = 27
	INT28n = 28
	INT29n = 29
	INT30n = 30
	INT31n = 31
)

const (
	ERR0    ERR = 0x01 << 0  //+ Error In Channel 0
	ERR0_0  ERR = 0x00 << 0  //  An error in this channel has not occurred
	ERR0_1  ERR = 0x01 << 0  //  An error in this channel has occurred
	ERR1    ERR = 0x01 << 1  //+ Error In Channel 1
	ERR1_0  ERR = 0x00 << 1  //  An error in this channel has not occurred
	ERR1_1  ERR = 0x01 << 1  //  An error in this channel has occurred
	ERR2    ERR = 0x01 << 2  //+ Error In Channel 2
	ERR2_0  ERR = 0x00 << 2  //  An error in this channel has not occurred
	ERR2_1  ERR = 0x01 << 2  //  An error in this channel has occurred
	ERR3    ERR = 0x01 << 3  //+ Error In Channel 3
	ERR3_0  ERR = 0x00 << 3  //  An error in this channel has not occurred
	ERR3_1  ERR = 0x01 << 3  //  An error in this channel has occurred
	ERR4    ERR = 0x01 << 4  //+ Error In Channel 4
	ERR4_0  ERR = 0x00 << 4  //  An error in this channel has not occurred
	ERR4_1  ERR = 0x01 << 4  //  An error in this channel has occurred
	ERR5    ERR = 0x01 << 5  //+ Error In Channel 5
	ERR5_0  ERR = 0x00 << 5  //  An error in this channel has not occurred
	ERR5_1  ERR = 0x01 << 5  //  An error in this channel has occurred
	ERR6    ERR = 0x01 << 6  //+ Error In Channel 6
	ERR6_0  ERR = 0x00 << 6  //  An error in this channel has not occurred
	ERR6_1  ERR = 0x01 << 6  //  An error in this channel has occurred
	ERR7    ERR = 0x01 << 7  //+ Error In Channel 7
	ERR7_0  ERR = 0x00 << 7  //  An error in this channel has not occurred
	ERR7_1  ERR = 0x01 << 7  //  An error in this channel has occurred
	ERR8    ERR = 0x01 << 8  //+ Error In Channel 8
	ERR8_0  ERR = 0x00 << 8  //  An error in this channel has not occurred
	ERR8_1  ERR = 0x01 << 8  //  An error in this channel has occurred
	ERR9    ERR = 0x01 << 9  //+ Error In Channel 9
	ERR9_0  ERR = 0x00 << 9  //  An error in this channel has not occurred
	ERR9_1  ERR = 0x01 << 9  //  An error in this channel has occurred
	ERR10   ERR = 0x01 << 10 //+ Error In Channel 10
	ERR10_0 ERR = 0x00 << 10 //  An error in this channel has not occurred
	ERR10_1 ERR = 0x01 << 10 //  An error in this channel has occurred
	ERR11   ERR = 0x01 << 11 //+ Error In Channel 11
	ERR11_0 ERR = 0x00 << 11 //  An error in this channel has not occurred
	ERR11_1 ERR = 0x01 << 11 //  An error in this channel has occurred
	ERR12   ERR = 0x01 << 12 //+ Error In Channel 12
	ERR12_0 ERR = 0x00 << 12 //  An error in this channel has not occurred
	ERR12_1 ERR = 0x01 << 12 //  An error in this channel has occurred
	ERR13   ERR = 0x01 << 13 //+ Error In Channel 13
	ERR13_0 ERR = 0x00 << 13 //  An error in this channel has not occurred
	ERR13_1 ERR = 0x01 << 13 //  An error in this channel has occurred
	ERR14   ERR = 0x01 << 14 //+ Error In Channel 14
	ERR14_0 ERR = 0x00 << 14 //  An error in this channel has not occurred
	ERR14_1 ERR = 0x01 << 14 //  An error in this channel has occurred
	ERR15   ERR = 0x01 << 15 //+ Error In Channel 15
	ERR15_0 ERR = 0x00 << 15 //  An error in this channel has not occurred
	ERR15_1 ERR = 0x01 << 15 //  An error in this channel has occurred
	ERR16   ERR = 0x01 << 16 //+ Error In Channel 16
	ERR16_0 ERR = 0x00 << 16 //  An error in this channel has not occurred
	ERR16_1 ERR = 0x01 << 16 //  An error in this channel has occurred
	ERR17   ERR = 0x01 << 17 //+ Error In Channel 17
	ERR17_0 ERR = 0x00 << 17 //  An error in this channel has not occurred
	ERR17_1 ERR = 0x01 << 17 //  An error in this channel has occurred
	ERR18   ERR = 0x01 << 18 //+ Error In Channel 18
	ERR18_0 ERR = 0x00 << 18 //  An error in this channel has not occurred
	ERR18_1 ERR = 0x01 << 18 //  An error in this channel has occurred
	ERR19   ERR = 0x01 << 19 //+ Error In Channel 19
	ERR19_0 ERR = 0x00 << 19 //  An error in this channel has not occurred
	ERR19_1 ERR = 0x01 << 19 //  An error in this channel has occurred
	ERR20   ERR = 0x01 << 20 //+ Error In Channel 20
	ERR20_0 ERR = 0x00 << 20 //  An error in this channel has not occurred
	ERR20_1 ERR = 0x01 << 20 //  An error in this channel has occurred
	ERR21   ERR = 0x01 << 21 //+ Error In Channel 21
	ERR21_0 ERR = 0x00 << 21 //  An error in this channel has not occurred
	ERR21_1 ERR = 0x01 << 21 //  An error in this channel has occurred
	ERR22   ERR = 0x01 << 22 //+ Error In Channel 22
	ERR22_0 ERR = 0x00 << 22 //  An error in this channel has not occurred
	ERR22_1 ERR = 0x01 << 22 //  An error in this channel has occurred
	ERR23   ERR = 0x01 << 23 //+ Error In Channel 23
	ERR23_0 ERR = 0x00 << 23 //  An error in this channel has not occurred
	ERR23_1 ERR = 0x01 << 23 //  An error in this channel has occurred
	ERR24   ERR = 0x01 << 24 //+ Error In Channel 24
	ERR24_0 ERR = 0x00 << 24 //  An error in this channel has not occurred
	ERR24_1 ERR = 0x01 << 24 //  An error in this channel has occurred
	ERR25   ERR = 0x01 << 25 //+ Error In Channel 25
	ERR25_0 ERR = 0x00 << 25 //  An error in this channel has not occurred
	ERR25_1 ERR = 0x01 << 25 //  An error in this channel has occurred
	ERR26   ERR = 0x01 << 26 //+ Error In Channel 26
	ERR26_0 ERR = 0x00 << 26 //  An error in this channel has not occurred
	ERR26_1 ERR = 0x01 << 26 //  An error in this channel has occurred
	ERR27   ERR = 0x01 << 27 //+ Error In Channel 27
	ERR27_0 ERR = 0x00 << 27 //  An error in this channel has not occurred
	ERR27_1 ERR = 0x01 << 27 //  An error in this channel has occurred
	ERR28   ERR = 0x01 << 28 //+ Error In Channel 28
	ERR28_0 ERR = 0x00 << 28 //  An error in this channel has not occurred
	ERR28_1 ERR = 0x01 << 28 //  An error in this channel has occurred
	ERR29   ERR = 0x01 << 29 //+ Error In Channel 29
	ERR29_0 ERR = 0x00 << 29 //  An error in this channel has not occurred
	ERR29_1 ERR = 0x01 << 29 //  An error in this channel has occurred
	ERR30   ERR = 0x01 << 30 //+ Error In Channel 30
	ERR30_0 ERR = 0x00 << 30 //  An error in this channel has not occurred
	ERR30_1 ERR = 0x01 << 30 //  An error in this channel has occurred
	ERR31   ERR = 0x01 << 31 //+ Error In Channel 31
	ERR31_0 ERR = 0x00 << 31 //  An error in this channel has not occurred
	ERR31_1 ERR = 0x01 << 31 //  An error in this channel has occurred
)

const (
	ERR0n  = 0
	ERR1n  = 1
	ERR2n  = 2
	ERR3n  = 3
	ERR4n  = 4
	ERR5n  = 5
	ERR6n  = 6
	ERR7n  = 7
	ERR8n  = 8
	ERR9n  = 9
	ERR10n = 10
	ERR11n = 11
	ERR12n = 12
	ERR13n = 13
	ERR14n = 14
	ERR15n = 15
	ERR16n = 16
	ERR17n = 17
	ERR18n = 18
	ERR19n = 19
	ERR20n = 20
	ERR21n = 21
	ERR22n = 22
	ERR23n = 23
	ERR24n = 24
	ERR25n = 25
	ERR26n = 26
	ERR27n = 27
	ERR28n = 28
	ERR29n = 29
	ERR30n = 30
	ERR31n = 31
)

const (
	HRS0    HRS = 0x01 << 0  //+ Hardware Request Status Channel 0
	HRS0_0  HRS = 0x00 << 0  //  A hardware service request for channel 0 is not present
	HRS0_1  HRS = 0x01 << 0  //  A hardware service request for channel 0 is present
	HRS1    HRS = 0x01 << 1  //+ Hardware Request Status Channel 1
	HRS1_0  HRS = 0x00 << 1  //  A hardware service request for channel 1 is not present
	HRS1_1  HRS = 0x01 << 1  //  A hardware service request for channel 1 is present
	HRS2    HRS = 0x01 << 2  //+ Hardware Request Status Channel 2
	HRS2_0  HRS = 0x00 << 2  //  A hardware service request for channel 2 is not present
	HRS2_1  HRS = 0x01 << 2  //  A hardware service request for channel 2 is present
	HRS3    HRS = 0x01 << 3  //+ Hardware Request Status Channel 3
	HRS3_0  HRS = 0x00 << 3  //  A hardware service request for channel 3 is not present
	HRS3_1  HRS = 0x01 << 3  //  A hardware service request for channel 3 is present
	HRS4    HRS = 0x01 << 4  //+ Hardware Request Status Channel 4
	HRS4_0  HRS = 0x00 << 4  //  A hardware service request for channel 4 is not present
	HRS4_1  HRS = 0x01 << 4  //  A hardware service request for channel 4 is present
	HRS5    HRS = 0x01 << 5  //+ Hardware Request Status Channel 5
	HRS5_0  HRS = 0x00 << 5  //  A hardware service request for channel 5 is not present
	HRS5_1  HRS = 0x01 << 5  //  A hardware service request for channel 5 is present
	HRS6    HRS = 0x01 << 6  //+ Hardware Request Status Channel 6
	HRS6_0  HRS = 0x00 << 6  //  A hardware service request for channel 6 is not present
	HRS6_1  HRS = 0x01 << 6  //  A hardware service request for channel 6 is present
	HRS7    HRS = 0x01 << 7  //+ Hardware Request Status Channel 7
	HRS7_0  HRS = 0x00 << 7  //  A hardware service request for channel 7 is not present
	HRS7_1  HRS = 0x01 << 7  //  A hardware service request for channel 7 is present
	HRS8    HRS = 0x01 << 8  //+ Hardware Request Status Channel 8
	HRS8_0  HRS = 0x00 << 8  //  A hardware service request for channel 8 is not present
	HRS8_1  HRS = 0x01 << 8  //  A hardware service request for channel 8 is present
	HRS9    HRS = 0x01 << 9  //+ Hardware Request Status Channel 9
	HRS9_0  HRS = 0x00 << 9  //  A hardware service request for channel 9 is not present
	HRS9_1  HRS = 0x01 << 9  //  A hardware service request for channel 9 is present
	HRS10   HRS = 0x01 << 10 //+ Hardware Request Status Channel 10
	HRS10_0 HRS = 0x00 << 10 //  A hardware service request for channel 10 is not present
	HRS10_1 HRS = 0x01 << 10 //  A hardware service request for channel 10 is present
	HRS11   HRS = 0x01 << 11 //+ Hardware Request Status Channel 11
	HRS11_0 HRS = 0x00 << 11 //  A hardware service request for channel 11 is not present
	HRS11_1 HRS = 0x01 << 11 //  A hardware service request for channel 11 is present
	HRS12   HRS = 0x01 << 12 //+ Hardware Request Status Channel 12
	HRS12_0 HRS = 0x00 << 12 //  A hardware service request for channel 12 is not present
	HRS12_1 HRS = 0x01 << 12 //  A hardware service request for channel 12 is present
	HRS13   HRS = 0x01 << 13 //+ Hardware Request Status Channel 13
	HRS13_0 HRS = 0x00 << 13 //  A hardware service request for channel 13 is not present
	HRS13_1 HRS = 0x01 << 13 //  A hardware service request for channel 13 is present
	HRS14   HRS = 0x01 << 14 //+ Hardware Request Status Channel 14
	HRS14_0 HRS = 0x00 << 14 //  A hardware service request for channel 14 is not present
	HRS14_1 HRS = 0x01 << 14 //  A hardware service request for channel 14 is present
	HRS15   HRS = 0x01 << 15 //+ Hardware Request Status Channel 15
	HRS15_0 HRS = 0x00 << 15 //  A hardware service request for channel 15 is not present
	HRS15_1 HRS = 0x01 << 15 //  A hardware service request for channel 15 is present
	HRS16   HRS = 0x01 << 16 //+ Hardware Request Status Channel 16
	HRS16_0 HRS = 0x00 << 16 //  A hardware service request for channel 16 is not present
	HRS16_1 HRS = 0x01 << 16 //  A hardware service request for channel 16 is present
	HRS17   HRS = 0x01 << 17 //+ Hardware Request Status Channel 17
	HRS17_0 HRS = 0x00 << 17 //  A hardware service request for channel 17 is not present
	HRS17_1 HRS = 0x01 << 17 //  A hardware service request for channel 17 is present
	HRS18   HRS = 0x01 << 18 //+ Hardware Request Status Channel 18
	HRS18_0 HRS = 0x00 << 18 //  A hardware service request for channel 18 is not present
	HRS18_1 HRS = 0x01 << 18 //  A hardware service request for channel 18 is present
	HRS19   HRS = 0x01 << 19 //+ Hardware Request Status Channel 19
	HRS19_0 HRS = 0x00 << 19 //  A hardware service request for channel 19 is not present
	HRS19_1 HRS = 0x01 << 19 //  A hardware service request for channel 19 is present
	HRS20   HRS = 0x01 << 20 //+ Hardware Request Status Channel 20
	HRS20_0 HRS = 0x00 << 20 //  A hardware service request for channel 20 is not present
	HRS20_1 HRS = 0x01 << 20 //  A hardware service request for channel 20 is present
	HRS21   HRS = 0x01 << 21 //+ Hardware Request Status Channel 21
	HRS21_0 HRS = 0x00 << 21 //  A hardware service request for channel 21 is not present
	HRS21_1 HRS = 0x01 << 21 //  A hardware service request for channel 21 is present
	HRS22   HRS = 0x01 << 22 //+ Hardware Request Status Channel 22
	HRS22_0 HRS = 0x00 << 22 //  A hardware service request for channel 22 is not present
	HRS22_1 HRS = 0x01 << 22 //  A hardware service request for channel 22 is present
	HRS23   HRS = 0x01 << 23 //+ Hardware Request Status Channel 23
	HRS23_0 HRS = 0x00 << 23 //  A hardware service request for channel 23 is not present
	HRS23_1 HRS = 0x01 << 23 //  A hardware service request for channel 23 is present
	HRS24   HRS = 0x01 << 24 //+ Hardware Request Status Channel 24
	HRS24_0 HRS = 0x00 << 24 //  A hardware service request for channel 24 is not present
	HRS24_1 HRS = 0x01 << 24 //  A hardware service request for channel 24 is present
	HRS25   HRS = 0x01 << 25 //+ Hardware Request Status Channel 25
	HRS25_0 HRS = 0x00 << 25 //  A hardware service request for channel 25 is not present
	HRS25_1 HRS = 0x01 << 25 //  A hardware service request for channel 25 is present
	HRS26   HRS = 0x01 << 26 //+ Hardware Request Status Channel 26
	HRS26_0 HRS = 0x00 << 26 //  A hardware service request for channel 26 is not present
	HRS26_1 HRS = 0x01 << 26 //  A hardware service request for channel 26 is present
	HRS27   HRS = 0x01 << 27 //+ Hardware Request Status Channel 27
	HRS27_0 HRS = 0x00 << 27 //  A hardware service request for channel 27 is not present
	HRS27_1 HRS = 0x01 << 27 //  A hardware service request for channel 27 is present
	HRS28   HRS = 0x01 << 28 //+ Hardware Request Status Channel 28
	HRS28_0 HRS = 0x00 << 28 //  A hardware service request for channel 28 is not present
	HRS28_1 HRS = 0x01 << 28 //  A hardware service request for channel 28 is present
	HRS29   HRS = 0x01 << 29 //+ Hardware Request Status Channel 29
	HRS29_0 HRS = 0x00 << 29 //  A hardware service request for channel 29 is not preset
	HRS29_1 HRS = 0x01 << 29 //  A hardware service request for channel 29 is present
	HRS30   HRS = 0x01 << 30 //+ Hardware Request Status Channel 30
	HRS30_0 HRS = 0x00 << 30 //  A hardware service request for channel 30 is not present
	HRS30_1 HRS = 0x01 << 30 //  A hardware service request for channel 30 is present
	HRS31   HRS = 0x01 << 31 //+ Hardware Request Status Channel 31
	HRS31_0 HRS = 0x00 << 31 //  A hardware service request for channel 31 is not present
	HRS31_1 HRS = 0x01 << 31 //  A hardware service request for channel 31 is present
)

const (
	HRS0n  = 0
	HRS1n  = 1
	HRS2n  = 2
	HRS3n  = 3
	HRS4n  = 4
	HRS5n  = 5
	HRS6n  = 6
	HRS7n  = 7
	HRS8n  = 8
	HRS9n  = 9
	HRS10n = 10
	HRS11n = 11
	HRS12n = 12
	HRS13n = 13
	HRS14n = 14
	HRS15n = 15
	HRS16n = 16
	HRS17n = 17
	HRS18n = 18
	HRS19n = 19
	HRS20n = 20
	HRS21n = 21
	HRS22n = 22
	HRS23n = 23
	HRS24n = 24
	HRS25n = 25
	HRS26n = 26
	HRS27n = 27
	HRS28n = 28
	HRS29n = 29
	HRS30n = 30
	HRS31n = 31
)

const (
	EDREQ_0    EARS = 0x01 << 0  //+ Enable asynchronous DMA request in stop mode for channel 0.
	EDREQ_0_0  EARS = 0x00 << 0  //  Disable asynchronous DMA request for channel 0.
	EDREQ_0_1  EARS = 0x01 << 0  //  Enable asynchronous DMA request for channel 0.
	EDREQ_1    EARS = 0x01 << 1  //+ Enable asynchronous DMA request in stop mode for channel 1.
	EDREQ_1_0  EARS = 0x00 << 1  //  Disable asynchronous DMA request for channel 1
	EDREQ_1_1  EARS = 0x01 << 1  //  Enable asynchronous DMA request for channel 1.
	EDREQ_2    EARS = 0x01 << 2  //+ Enable asynchronous DMA request in stop mode for channel 2.
	EDREQ_2_0  EARS = 0x00 << 2  //  Disable asynchronous DMA request for channel 2.
	EDREQ_2_1  EARS = 0x01 << 2  //  Enable asynchronous DMA request for channel 2.
	EDREQ_3    EARS = 0x01 << 3  //+ Enable asynchronous DMA request in stop mode for channel 3.
	EDREQ_3_0  EARS = 0x00 << 3  //  Disable asynchronous DMA request for channel 3.
	EDREQ_3_1  EARS = 0x01 << 3  //  Enable asynchronous DMA request for channel 3.
	EDREQ_4    EARS = 0x01 << 4  //+ Enable asynchronous DMA request in stop mode for channel 4
	EDREQ_4_0  EARS = 0x00 << 4  //  Disable asynchronous DMA request for channel 4.
	EDREQ_4_1  EARS = 0x01 << 4  //  Enable asynchronous DMA request for channel 4.
	EDREQ_5    EARS = 0x01 << 5  //+ Enable asynchronous DMA request in stop mode for channel 5
	EDREQ_5_0  EARS = 0x00 << 5  //  Disable asynchronous DMA request for channel 5.
	EDREQ_5_1  EARS = 0x01 << 5  //  Enable asynchronous DMA request for channel 5.
	EDREQ_6    EARS = 0x01 << 6  //+ Enable asynchronous DMA request in stop mode for channel 6
	EDREQ_6_0  EARS = 0x00 << 6  //  Disable asynchronous DMA request for channel 6.
	EDREQ_6_1  EARS = 0x01 << 6  //  Enable asynchronous DMA request for channel 6.
	EDREQ_7    EARS = 0x01 << 7  //+ Enable asynchronous DMA request in stop mode for channel 7
	EDREQ_7_0  EARS = 0x00 << 7  //  Disable asynchronous DMA request for channel 7.
	EDREQ_7_1  EARS = 0x01 << 7  //  Enable asynchronous DMA request for channel 7.
	EDREQ_8    EARS = 0x01 << 8  //+ Enable asynchronous DMA request in stop mode for channel 8
	EDREQ_8_0  EARS = 0x00 << 8  //  Disable asynchronous DMA request for channel 8.
	EDREQ_8_1  EARS = 0x01 << 8  //  Enable asynchronous DMA request for channel 8.
	EDREQ_9    EARS = 0x01 << 9  //+ Enable asynchronous DMA request in stop mode for channel 9
	EDREQ_9_0  EARS = 0x00 << 9  //  Disable asynchronous DMA request for channel 9.
	EDREQ_9_1  EARS = 0x01 << 9  //  Enable asynchronous DMA request for channel 9.
	EDREQ_10   EARS = 0x01 << 10 //+ Enable asynchronous DMA request in stop mode for channel 10
	EDREQ_10_0 EARS = 0x00 << 10 //  Disable asynchronous DMA request for channel 10.
	EDREQ_10_1 EARS = 0x01 << 10 //  Enable asynchronous DMA request for channel 10.
	EDREQ_11   EARS = 0x01 << 11 //+ Enable asynchronous DMA request in stop mode for channel 11
	EDREQ_11_0 EARS = 0x00 << 11 //  Disable asynchronous DMA request for channel 11.
	EDREQ_11_1 EARS = 0x01 << 11 //  Enable asynchronous DMA request for channel 11.
	EDREQ_12   EARS = 0x01 << 12 //+ Enable asynchronous DMA request in stop mode for channel 12
	EDREQ_12_0 EARS = 0x00 << 12 //  Disable asynchronous DMA request for channel 12.
	EDREQ_12_1 EARS = 0x01 << 12 //  Enable asynchronous DMA request for channel 12.
	EDREQ_13   EARS = 0x01 << 13 //+ Enable asynchronous DMA request in stop mode for channel 13
	EDREQ_13_0 EARS = 0x00 << 13 //  Disable asynchronous DMA request for channel 13.
	EDREQ_13_1 EARS = 0x01 << 13 //  Enable asynchronous DMA request for channel 13.
	EDREQ_14   EARS = 0x01 << 14 //+ Enable asynchronous DMA request in stop mode for channel 14
	EDREQ_14_0 EARS = 0x00 << 14 //  Disable asynchronous DMA request for channel 14.
	EDREQ_14_1 EARS = 0x01 << 14 //  Enable asynchronous DMA request for channel 14.
	EDREQ_15   EARS = 0x01 << 15 //+ Enable asynchronous DMA request in stop mode for channel 15
	EDREQ_15_0 EARS = 0x00 << 15 //  Disable asynchronous DMA request for channel 15.
	EDREQ_15_1 EARS = 0x01 << 15 //  Enable asynchronous DMA request for channel 15.
	EDREQ_16   EARS = 0x01 << 16 //+ Enable asynchronous DMA request in stop mode for channel 16
	EDREQ_16_0 EARS = 0x00 << 16 //  Disable asynchronous DMA request for channel 16
	EDREQ_16_1 EARS = 0x01 << 16 //  Enable asynchronous DMA request for channel 16
	EDREQ_17   EARS = 0x01 << 17 //+ Enable asynchronous DMA request in stop mode for channel 17
	EDREQ_17_0 EARS = 0x00 << 17 //  Disable asynchronous DMA request for channel 17
	EDREQ_17_1 EARS = 0x01 << 17 //  Enable asynchronous DMA request for channel 17
	EDREQ_18   EARS = 0x01 << 18 //+ Enable asynchronous DMA request in stop mode for channel 18
	EDREQ_18_0 EARS = 0x00 << 18 //  Disable asynchronous DMA request for channel 18
	EDREQ_18_1 EARS = 0x01 << 18 //  Enable asynchronous DMA request for channel 18
	EDREQ_19   EARS = 0x01 << 19 //+ Enable asynchronous DMA request in stop mode for channel 19
	EDREQ_19_0 EARS = 0x00 << 19 //  Disable asynchronous DMA request for channel 19
	EDREQ_19_1 EARS = 0x01 << 19 //  Enable asynchronous DMA request for channel 19
	EDREQ_20   EARS = 0x01 << 20 //+ Enable asynchronous DMA request in stop mode for channel 20
	EDREQ_20_0 EARS = 0x00 << 20 //  Disable asynchronous DMA request for channel 20
	EDREQ_20_1 EARS = 0x01 << 20 //  Enable asynchronous DMA request for channel 20
	EDREQ_21   EARS = 0x01 << 21 //+ Enable asynchronous DMA request in stop mode for channel 21
	EDREQ_21_0 EARS = 0x00 << 21 //  Disable asynchronous DMA request for channel 21
	EDREQ_21_1 EARS = 0x01 << 21 //  Enable asynchronous DMA request for channel 21
	EDREQ_22   EARS = 0x01 << 22 //+ Enable asynchronous DMA request in stop mode for channel 22
	EDREQ_22_0 EARS = 0x00 << 22 //  Disable asynchronous DMA request for channel 22
	EDREQ_22_1 EARS = 0x01 << 22 //  Enable asynchronous DMA request for channel 22
	EDREQ_23   EARS = 0x01 << 23 //+ Enable asynchronous DMA request in stop mode for channel 23
	EDREQ_23_0 EARS = 0x00 << 23 //  Disable asynchronous DMA request for channel 23
	EDREQ_23_1 EARS = 0x01 << 23 //  Enable asynchronous DMA request for channel 23
	EDREQ_24   EARS = 0x01 << 24 //+ Enable asynchronous DMA request in stop mode for channel 24
	EDREQ_24_0 EARS = 0x00 << 24 //  Disable asynchronous DMA request for channel 24
	EDREQ_24_1 EARS = 0x01 << 24 //  Enable asynchronous DMA request for channel 24
	EDREQ_25   EARS = 0x01 << 25 //+ Enable asynchronous DMA request in stop mode for channel 25
	EDREQ_25_0 EARS = 0x00 << 25 //  Disable asynchronous DMA request for channel 25
	EDREQ_25_1 EARS = 0x01 << 25 //  Enable asynchronous DMA request for channel 25
	EDREQ_26   EARS = 0x01 << 26 //+ Enable asynchronous DMA request in stop mode for channel 26
	EDREQ_26_0 EARS = 0x00 << 26 //  Disable asynchronous DMA request for channel 26
	EDREQ_26_1 EARS = 0x01 << 26 //  Enable asynchronous DMA request for channel 26
	EDREQ_27   EARS = 0x01 << 27 //+ Enable asynchronous DMA request in stop mode for channel 27
	EDREQ_27_0 EARS = 0x00 << 27 //  Disable asynchronous DMA request for channel 27
	EDREQ_27_1 EARS = 0x01 << 27 //  Enable asynchronous DMA request for channel 27
	EDREQ_28   EARS = 0x01 << 28 //+ Enable asynchronous DMA request in stop mode for channel 28
	EDREQ_28_0 EARS = 0x00 << 28 //  Disable asynchronous DMA request for channel 28
	EDREQ_28_1 EARS = 0x01 << 28 //  Enable asynchronous DMA request for channel 28
	EDREQ_29   EARS = 0x01 << 29 //+ Enable asynchronous DMA request in stop mode for channel 29
	EDREQ_29_0 EARS = 0x00 << 29 //  Disable asynchronous DMA request for channel 29
	EDREQ_29_1 EARS = 0x01 << 29 //  Enable asynchronous DMA request for channel 29
	EDREQ_30   EARS = 0x01 << 30 //+ Enable asynchronous DMA request in stop mode for channel 30
	EDREQ_30_0 EARS = 0x00 << 30 //  Disable asynchronous DMA request for channel 30
	EDREQ_30_1 EARS = 0x01 << 30 //  Enable asynchronous DMA request for channel 30
	EDREQ_31   EARS = 0x01 << 31 //+ Enable asynchronous DMA request in stop mode for channel 31
	EDREQ_31_0 EARS = 0x00 << 31 //  Disable asynchronous DMA request for channel 31
	EDREQ_31_1 EARS = 0x01 << 31 //  Enable asynchronous DMA request for channel 31
)

const (
	EDREQ_0n  = 0
	EDREQ_1n  = 1
	EDREQ_2n  = 2
	EDREQ_3n  = 3
	EDREQ_4n  = 4
	EDREQ_5n  = 5
	EDREQ_6n  = 6
	EDREQ_7n  = 7
	EDREQ_8n  = 8
	EDREQ_9n  = 9
	EDREQ_10n = 10
	EDREQ_11n = 11
	EDREQ_12n = 12
	EDREQ_13n = 13
	EDREQ_14n = 14
	EDREQ_15n = 15
	EDREQ_16n = 16
	EDREQ_17n = 17
	EDREQ_18n = 18
	EDREQ_19n = 19
	EDREQ_20n = 20
	EDREQ_21n = 21
	EDREQ_22n = 22
	EDREQ_23n = 23
	EDREQ_24n = 24
	EDREQ_25n = 25
	EDREQ_26n = 26
	EDREQ_27n = 27
	EDREQ_28n = 28
	EDREQ_29n = 29
	EDREQ_30n = 30
	EDREQ_31n = 31
)

const (
	CHPRI  DCHPRI3 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI3 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI3 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI3 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI3 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI3 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI3 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI3 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI2 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI2 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI2 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI2 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI2 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI2 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI2 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI2 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI1 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI1 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI1 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI1 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI1 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI1 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI1 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI1 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI0 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI0 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI0 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI0 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI0 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI0 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI0 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI0 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI7 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI7 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI7 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI7 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI7 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI7 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI7 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI7 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI6 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI6 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI6 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI6 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI6 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI6 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI6 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI6 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI5 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI5 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI5 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI5 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI5 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI5 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI5 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI5 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI4 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI4 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI4 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI4 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI4 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI4 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI4 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI4 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI11 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI11 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI11 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI11 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI11 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI11 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI11 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI11 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI10 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI10 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI10 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI10 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI10 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI10 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI10 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI10 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI9 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI9 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI9 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI9 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI9 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI9 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI9 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI9 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI8 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI8 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI8 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI8 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI8 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI8 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI8 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI8 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI15 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI15 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI15 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI15 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI15 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI15 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI15 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI15 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI14 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI14 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI14 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI14 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI14 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI14 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI14 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI14 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI13 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI13 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI13 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI13 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI13 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI13 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI13 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI13 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI12 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI12 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI12 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI12 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI12 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI12 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI12 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI12 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI19 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI19 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI19 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI19 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI19 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI19 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI19 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI19 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI18 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI18 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI18 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI18 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI18 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI18 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI18 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI18 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI17 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI17 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI17 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI17 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI17 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI17 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI17 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI17 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI16 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI16 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI16 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI16 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI16 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI16 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI16 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI16 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI23 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI23 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI23 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI23 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI23 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI23 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI23 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI23 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI22 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI22 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI22 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI22 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI22 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI22 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI22 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI22 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI21 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI21 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI21 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI21 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI21 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI21 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI21 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI21 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI20 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI20 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI20 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI20 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI20 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI20 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI20 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI20 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI27 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI27 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI27 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI27 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI27 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI27 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI27 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI27 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI26 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI26 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI26 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI26 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI26 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI26 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI26 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI26 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI25 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI25 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI25 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI25 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI25 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI25 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI25 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI25 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI24 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI24 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI24 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI24 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI24 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI24 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI24 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI24 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI31 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI31 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI31 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI31 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI31 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI31 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI31 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI31 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI30 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI30 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI30 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI30 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI30 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI30 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI30 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI30 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI29 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI29 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI29 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI29 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI29 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI29 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI29 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI29 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	CHPRI  DCHPRI28 = 0x0F << 0 //+ Channel n Arbitration Priority
	GRPPRI DCHPRI28 = 0x03 << 4 //+ Channel n Current Group Priority
	DPA    DCHPRI28 = 0x01 << 6 //+ Disable Preempt Ability. This field resets to 0.
	DPA_0  DCHPRI28 = 0x00 << 6 //  Channel n can suspend a lower priority channel.
	DPA_1  DCHPRI28 = 0x01 << 6 //  Channel n cannot suspend any channel, regardless of channel priority.
	ECP    DCHPRI28 = 0x01 << 7 //+ Enable Channel Preemption. This field resets to 0.
	ECP_0  DCHPRI28 = 0x00 << 7 //  Channel n cannot be suspended by a higher priority channel's service request.
	ECP_1  DCHPRI28 = 0x01 << 7 //  Channel n can be temporarily suspended by the service request of a higher priority channel.
)

const (
	CHPRIn  = 0
	GRPPRIn = 4
	DPAn    = 6
	ECPn    = 7
)

const (
	SADDR TCD0_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD0_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD0_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD0_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD0_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD0_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD0_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD0_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD0_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD0_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD0_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD0_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD0_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD0_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD0_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD0_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD0_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD0_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD0_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD0_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD0_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD0_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD0_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD0_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD0_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD0_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD0_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD0_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD0_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD0_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD0_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD0_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD0_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD0_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD0_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD0_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD0_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD0_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD0_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD0_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD0_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD0_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD0_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD0_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD0_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD0_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD0_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD0_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD0_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD0_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD0_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD0_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD0_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD0_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD0_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD0_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD0_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD0_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD0_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD0_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD0_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD0_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD0_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD0_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD0_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD0_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD0_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD0_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD0_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD0_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD0_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD0_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD0_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD0_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD0_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD0_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD0_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD0_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD0_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD0_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD0_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD0_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD0_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD0_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD1_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD1_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD1_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD1_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD1_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD1_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD1_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD1_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD1_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD1_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD1_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD1_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD1_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD1_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD1_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD1_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD1_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD1_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD1_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD1_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD1_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD1_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD1_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD1_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD1_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD1_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD1_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD1_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD1_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD1_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD1_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD1_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD1_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD1_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD1_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD1_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD1_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD1_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD1_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD1_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD1_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD1_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD1_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD1_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD1_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD1_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD1_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD1_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD1_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD1_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD1_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD1_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD1_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD1_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD1_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD1_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD1_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD1_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD1_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD1_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD1_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD1_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD1_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD1_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD1_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD1_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD1_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD1_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD1_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD1_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD1_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD1_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD1_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD1_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD1_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD1_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD1_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD1_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD1_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD1_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD1_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD1_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD1_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD1_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD2_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD2_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD2_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD2_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD2_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD2_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD2_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD2_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD2_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD2_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD2_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD2_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD2_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD2_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD2_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD2_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD2_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD2_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD2_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD2_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD2_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD2_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD2_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD2_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD2_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD2_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD2_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD2_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD2_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD2_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD2_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD2_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD2_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD2_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD2_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD2_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD2_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD2_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD2_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD2_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD2_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD2_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD2_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD2_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD2_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD2_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD2_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD2_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD2_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD2_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD2_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD2_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD2_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD2_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD2_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD2_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD2_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD2_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD2_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD2_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD2_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD2_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD2_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD2_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD2_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD2_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD2_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD2_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD2_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD2_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD2_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD2_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD2_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD2_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD2_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD2_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD2_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD2_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD2_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD2_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD2_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD2_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD2_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD2_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD3_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD3_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD3_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD3_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD3_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD3_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD3_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD3_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD3_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD3_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD3_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD3_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD3_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD3_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD3_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD3_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD3_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD3_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD3_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD3_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD3_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD3_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD3_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD3_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD3_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD3_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD3_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD3_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD3_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD3_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD3_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD3_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD3_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD3_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD3_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD3_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD3_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD3_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD3_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD3_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD3_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD3_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD3_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD3_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD3_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD3_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD3_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD3_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD3_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD3_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD3_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD3_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD3_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD3_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD3_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD3_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD3_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD3_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD3_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD3_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD3_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD3_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD3_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD3_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD3_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD3_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD3_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD3_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD3_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD3_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD3_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD3_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD3_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD3_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD3_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD3_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD3_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD3_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD3_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD3_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD3_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD3_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD3_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD3_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD4_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD4_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD4_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD4_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD4_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD4_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD4_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD4_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD4_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD4_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD4_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD4_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD4_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD4_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD4_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD4_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD4_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD4_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD4_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD4_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD4_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD4_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD4_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD4_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD4_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD4_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD4_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD4_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD4_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD4_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD4_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD4_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD4_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD4_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD4_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD4_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD4_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD4_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD4_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD4_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD4_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD4_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD4_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD4_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD4_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER   TCD4_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD4_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD4_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD4_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD4_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD4_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD4_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD4_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD4_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD4_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD4_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD4_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD4_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD4_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD4_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD4_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD4_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD4_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD4_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD4_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD4_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD4_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD4_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD4_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD4_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD4_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD4_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD4_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD4_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD4_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD4_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD4_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD4_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD4_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD4_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD4_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD4_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD4_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD4_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD5_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD5_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD5_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD5_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD5_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD5_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD5_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD5_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD5_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD5_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD5_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD5_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD5_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD5_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD5_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD5_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD5_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD5_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD5_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD5_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD5_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD5_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD5_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD5_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD5_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD5_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD5_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD5_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD5_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD5_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD5_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD5_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD5_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD5_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD5_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD5_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD5_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD5_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD5_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD5_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD5_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD5_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD5_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD5_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD5_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER   TCD5_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD5_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD5_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD5_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD5_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD5_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD5_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD5_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD5_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD5_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD5_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD5_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD5_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD5_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD5_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD5_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD5_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD5_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD5_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD5_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD5_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD5_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD5_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD5_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD5_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD5_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD5_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD5_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD5_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD5_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD5_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD5_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD5_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD5_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD5_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD5_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD5_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD5_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD5_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD6_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD6_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD6_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD6_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD6_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD6_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD6_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD6_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD6_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD6_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD6_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD6_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD6_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD6_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD6_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD6_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD6_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD6_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD6_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD6_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD6_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD6_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD6_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD6_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD6_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD6_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD6_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD6_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD6_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD6_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD6_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD6_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD6_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD6_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD6_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD6_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD6_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD6_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD6_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD6_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD6_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD6_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD6_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD6_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD6_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD6_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD6_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD6_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD6_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD6_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD6_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD6_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD6_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD6_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD6_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD6_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD6_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD6_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD6_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD6_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD6_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD6_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD6_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD6_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD6_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD6_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD6_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD6_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD6_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD6_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD6_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD6_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD6_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD6_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD6_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD6_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD6_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD6_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD6_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD6_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD6_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD6_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD6_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD6_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD7_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD7_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD7_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD7_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD7_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD7_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD7_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD7_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD7_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD7_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD7_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD7_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD7_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD7_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD7_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD7_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD7_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD7_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD7_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD7_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD7_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD7_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD7_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD7_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD7_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD7_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD7_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD7_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD7_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD7_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD7_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD7_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD7_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD7_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD7_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD7_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD7_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD7_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD7_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD7_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD7_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD7_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD7_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD7_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD7_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD7_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD7_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD7_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD7_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD7_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD7_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD7_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD7_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD7_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD7_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD7_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD7_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD7_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD7_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD7_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD7_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD7_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD7_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD7_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD7_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD7_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD7_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD7_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD7_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD7_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD7_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD7_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD7_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD7_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD7_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD7_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD7_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD7_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD7_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD7_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD7_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD7_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD7_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD7_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD8_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD8_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD8_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD8_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD8_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD8_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD8_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD8_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD8_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD8_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD8_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD8_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD8_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD8_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD8_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD8_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD8_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD8_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD8_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD8_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD8_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD8_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD8_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD8_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD8_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD8_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD8_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD8_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD8_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD8_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD8_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD8_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD8_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD8_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD8_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD8_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD8_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD8_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD8_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD8_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD8_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD8_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD8_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD8_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD8_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD8_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD8_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD8_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD8_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD8_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD8_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD8_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD8_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD8_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD8_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD8_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD8_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD8_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD8_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD8_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD8_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD8_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD8_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD8_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD8_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD8_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD8_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD8_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD8_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD8_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD8_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD8_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD8_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD8_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD8_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD8_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD8_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD8_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD8_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD8_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD8_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD8_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD8_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD8_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD9_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD9_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD9_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD9_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD9_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD9_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD9_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD9_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD9_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD9_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD9_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD9_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD9_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD9_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD9_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD9_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD9_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD9_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD9_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD9_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD9_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD9_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD9_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD9_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD9_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD9_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD9_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD9_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD9_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD9_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD9_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD9_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD9_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD9_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD9_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD9_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD9_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD9_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD9_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD9_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD9_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD9_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD9_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD9_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD9_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER   TCD9_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD9_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD9_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD9_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD9_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD9_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD9_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD9_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD9_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD9_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD9_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD9_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD9_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD9_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD9_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD9_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD9_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD9_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD9_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD9_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD9_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD9_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD9_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD9_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD9_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD9_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD9_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD9_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD9_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD9_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD9_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD9_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD9_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD9_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD9_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD9_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD9_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD9_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD9_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD10_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD10_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD10_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD10_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD10_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD10_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD10_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD10_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD10_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD10_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD10_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD10_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD10_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD10_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD10_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD10_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD10_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD10_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD10_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD10_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD10_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD10_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD10_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD10_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD10_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD10_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD10_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD10_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD10_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD10_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD10_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD10_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD10_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD10_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD10_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD10_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD10_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD10_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD10_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD10_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD10_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD10_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD10_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD10_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD10_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD10_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD10_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD10_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD10_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD10_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD10_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD10_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD10_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD10_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD10_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD10_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD10_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD10_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD10_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD10_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD10_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD10_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD10_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD10_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD10_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD10_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD10_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD10_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD10_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD10_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD10_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD10_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD10_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD10_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD10_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD10_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD10_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD10_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD10_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD10_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD10_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD10_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD10_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD10_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD11_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD11_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD11_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD11_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD11_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD11_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD11_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD11_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD11_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD11_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD11_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD11_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD11_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD11_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD11_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD11_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD11_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD11_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD11_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD11_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD11_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD11_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD11_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD11_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD11_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD11_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD11_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD11_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD11_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD11_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD11_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD11_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD11_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD11_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD11_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD11_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD11_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD11_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD11_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD11_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD11_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD11_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD11_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD11_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD11_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD11_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD11_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD11_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD11_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD11_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD11_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD11_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD11_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD11_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD11_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD11_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD11_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD11_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD11_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD11_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD11_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD11_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD11_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD11_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD11_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD11_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD11_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD11_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD11_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD11_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD11_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD11_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD11_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD11_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD11_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD11_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD11_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD11_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD11_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD11_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD11_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD11_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD11_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD11_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD12_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD12_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD12_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD12_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD12_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD12_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD12_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD12_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD12_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD12_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD12_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD12_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD12_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD12_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD12_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD12_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD12_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD12_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD12_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD12_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD12_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD12_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD12_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD12_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD12_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD12_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD12_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD12_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD12_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD12_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD12_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD12_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD12_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD12_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD12_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD12_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD12_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD12_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD12_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD12_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD12_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD12_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD12_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD12_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD12_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD12_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD12_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD12_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD12_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD12_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD12_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD12_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD12_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD12_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD12_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD12_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD12_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD12_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD12_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD12_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD12_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD12_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD12_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD12_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD12_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD12_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD12_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD12_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD12_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD12_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD12_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD12_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD12_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD12_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD12_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD12_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD12_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD12_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD12_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD12_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD12_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD12_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD12_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD12_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD13_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD13_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD13_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD13_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD13_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD13_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD13_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD13_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD13_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD13_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD13_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD13_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD13_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD13_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD13_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD13_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD13_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD13_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD13_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD13_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD13_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD13_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD13_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD13_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD13_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD13_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD13_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD13_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD13_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD13_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD13_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD13_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD13_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD13_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD13_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD13_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD13_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD13_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD13_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD13_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD13_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD13_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD13_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD13_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD13_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD13_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD13_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD13_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD13_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD13_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD13_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD13_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD13_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD13_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD13_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD13_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD13_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD13_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD13_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD13_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD13_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD13_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD13_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD13_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD13_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD13_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD13_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD13_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD13_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD13_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD13_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD13_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD13_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD13_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD13_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD13_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD13_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD13_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD13_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD13_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD13_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD13_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD13_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD13_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD14_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD14_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD14_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD14_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD14_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD14_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD14_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD14_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD14_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD14_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD14_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD14_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD14_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD14_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD14_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD14_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD14_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD14_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD14_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD14_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD14_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD14_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD14_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD14_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD14_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD14_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD14_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD14_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD14_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD14_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD14_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD14_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD14_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD14_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD14_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD14_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD14_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD14_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD14_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD14_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD14_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD14_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD14_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD14_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD14_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD14_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD14_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD14_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD14_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD14_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD14_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD14_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD14_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD14_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD14_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD14_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD14_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD14_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD14_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD14_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD14_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD14_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD14_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD14_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD14_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD14_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD14_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD14_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD14_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD14_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD14_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD14_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD14_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD14_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD14_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD14_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD14_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD14_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD14_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD14_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD14_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD14_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD14_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD14_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD15_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD15_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD15_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD15_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD15_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD15_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD15_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD15_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD15_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD15_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD15_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD15_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD15_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD15_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD15_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD15_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD15_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD15_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD15_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD15_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD15_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD15_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD15_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD15_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD15_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD15_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD15_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD15_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD15_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD15_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD15_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD15_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD15_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD15_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD15_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD15_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD15_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD15_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD15_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD15_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD15_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD15_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD15_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD15_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD15_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD15_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD15_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD15_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD15_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD15_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD15_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD15_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD15_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD15_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD15_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD15_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD15_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD15_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD15_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD15_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD15_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD15_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD15_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD15_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD15_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD15_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD15_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD15_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD15_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD15_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD15_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD15_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD15_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD15_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD15_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD15_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD15_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD15_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD15_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD15_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD15_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD15_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD15_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD15_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD16_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD16_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD16_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD16_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD16_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD16_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD16_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD16_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD16_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD16_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD16_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD16_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD16_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD16_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD16_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD16_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD16_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD16_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD16_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD16_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD16_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD16_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD16_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD16_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD16_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD16_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD16_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD16_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD16_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD16_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD16_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD16_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD16_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD16_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD16_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD16_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD16_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD16_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD16_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD16_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD16_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD16_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD16_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD16_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD16_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD16_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD16_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD16_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD16_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD16_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD16_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD16_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD16_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD16_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD16_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD16_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD16_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD16_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD16_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD16_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD16_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD16_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD16_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD16_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD16_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD16_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD16_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD16_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD16_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD16_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD16_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD16_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD16_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD16_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD16_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD16_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD16_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD16_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD16_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD16_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD16_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD16_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD16_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD16_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD17_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD17_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD17_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD17_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD17_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD17_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD17_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD17_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD17_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD17_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD17_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD17_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD17_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD17_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD17_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD17_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD17_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD17_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD17_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD17_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD17_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD17_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD17_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD17_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD17_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD17_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD17_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD17_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD17_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD17_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD17_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD17_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD17_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD17_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD17_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD17_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD17_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD17_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD17_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD17_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD17_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD17_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD17_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD17_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD17_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD17_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD17_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD17_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD17_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD17_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD17_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD17_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD17_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD17_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD17_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD17_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD17_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD17_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD17_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD17_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD17_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD17_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD17_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD17_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD17_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD17_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD17_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD17_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD17_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD17_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD17_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD17_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD17_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD17_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD17_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD17_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD17_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD17_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD17_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD17_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD17_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD17_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD17_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD17_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD18_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD18_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD18_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD18_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD18_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD18_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD18_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD18_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD18_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD18_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD18_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD18_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD18_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD18_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD18_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD18_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD18_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD18_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD18_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD18_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD18_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD18_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD18_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD18_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD18_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD18_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD18_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD18_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD18_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD18_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD18_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD18_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD18_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD18_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD18_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD18_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD18_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD18_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD18_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD18_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD18_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD18_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD18_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD18_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD18_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD18_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD18_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD18_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD18_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD18_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD18_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD18_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD18_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD18_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD18_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD18_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD18_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD18_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD18_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD18_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD18_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD18_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD18_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD18_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD18_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD18_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD18_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD18_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD18_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD18_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD18_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD18_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD18_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD18_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD18_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD18_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD18_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD18_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD18_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD18_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD18_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD18_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD18_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD18_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD19_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD19_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD19_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD19_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD19_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD19_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD19_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD19_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD19_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD19_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD19_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD19_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD19_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD19_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD19_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD19_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD19_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD19_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD19_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD19_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD19_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD19_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD19_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD19_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD19_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD19_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD19_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD19_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD19_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD19_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD19_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD19_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD19_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD19_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD19_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD19_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD19_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD19_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD19_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD19_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD19_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD19_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD19_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD19_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD19_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD19_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD19_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD19_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD19_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD19_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD19_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD19_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD19_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD19_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD19_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD19_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD19_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD19_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD19_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD19_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD19_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD19_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD19_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD19_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD19_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD19_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD19_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD19_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD19_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD19_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD19_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD19_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD19_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD19_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD19_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD19_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD19_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD19_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD19_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD19_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD19_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD19_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD19_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD19_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD20_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD20_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD20_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD20_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD20_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD20_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD20_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD20_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD20_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD20_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD20_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD20_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD20_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD20_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD20_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD20_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD20_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD20_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD20_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD20_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD20_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD20_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD20_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD20_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD20_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD20_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD20_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD20_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD20_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD20_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD20_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD20_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD20_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD20_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD20_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD20_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD20_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD20_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD20_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD20_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD20_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD20_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD20_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD20_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD20_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER   TCD20_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD20_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD20_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD20_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD20_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD20_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD20_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD20_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD20_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD20_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD20_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD20_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD20_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD20_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD20_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD20_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD20_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD20_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD20_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD20_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD20_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD20_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD20_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD20_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD20_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD20_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD20_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD20_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD20_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD20_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD20_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD20_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD20_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD20_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD20_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD20_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD20_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD20_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD20_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD21_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD21_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD21_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD21_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD21_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD21_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD21_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD21_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD21_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD21_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD21_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD21_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD21_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD21_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD21_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD21_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD21_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD21_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD21_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD21_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD21_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD21_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD21_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD21_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD21_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD21_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD21_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD21_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD21_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD21_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD21_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD21_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD21_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD21_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD21_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD21_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD21_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD21_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD21_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD21_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD21_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD21_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD21_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD21_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD21_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD21_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD21_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD21_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD21_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD21_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD21_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD21_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD21_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD21_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD21_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD21_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD21_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD21_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD21_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD21_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD21_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD21_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD21_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD21_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD21_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD21_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD21_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD21_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD21_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD21_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD21_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD21_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD21_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD21_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD21_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD21_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD21_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD21_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD21_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD21_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD21_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD21_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD21_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD21_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD22_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD22_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD22_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD22_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD22_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD22_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD22_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD22_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD22_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD22_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD22_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD22_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD22_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD22_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD22_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD22_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD22_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD22_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD22_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD22_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD22_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD22_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD22_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD22_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD22_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD22_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD22_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD22_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD22_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD22_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD22_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD22_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD22_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD22_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD22_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD22_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD22_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD22_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD22_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD22_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD22_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD22_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD22_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD22_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD22_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD22_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD22_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD22_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD22_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD22_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD22_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD22_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD22_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD22_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD22_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD22_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD22_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD22_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD22_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD22_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD22_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD22_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD22_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD22_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD22_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD22_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD22_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD22_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD22_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD22_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD22_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD22_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD22_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD22_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD22_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD22_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD22_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD22_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD22_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD22_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD22_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD22_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD22_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD22_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD23_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD23_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD23_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD23_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD23_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD23_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD23_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD23_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD23_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD23_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD23_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD23_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD23_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD23_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD23_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD23_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD23_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD23_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD23_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD23_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD23_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD23_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD23_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD23_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD23_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD23_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD23_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD23_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD23_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD23_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD23_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD23_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD23_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD23_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD23_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD23_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD23_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	SLAST TCD23_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD23_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD23_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD23_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD23_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD23_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD23_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD23_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD23_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD23_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD23_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD23_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD23_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD23_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD23_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD23_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD23_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD23_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD23_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD23_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD23_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD23_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD23_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD23_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD23_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD23_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD23_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD23_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD23_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD23_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD23_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD23_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD23_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD23_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD23_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD23_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD23_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD23_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD23_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD23_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD23_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD23_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD23_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD23_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD23_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD23_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD23_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD24_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD24_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD24_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD24_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD24_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD24_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD24_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD24_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD24_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD24_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD24_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD24_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD24_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD24_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD24_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD24_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD24_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD24_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD24_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD24_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD24_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD24_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD24_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD24_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD24_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD24_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD24_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD24_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD24_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD24_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD24_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD24_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD24_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD24_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD24_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD24_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD24_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD24_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD24_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD24_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD24_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD24_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD24_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD24_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD24_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD24_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD24_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD24_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD24_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD24_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD24_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD24_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD24_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD24_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD24_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD24_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD24_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD24_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD24_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD24_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD24_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD24_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD24_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD24_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD24_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD24_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD24_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD24_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD24_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD24_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD24_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD24_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD24_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD24_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD24_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD24_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD24_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD24_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD24_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD24_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD24_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD24_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD24_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD24_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD25_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD25_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD25_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD25_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD25_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD25_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD25_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD25_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD25_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD25_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD25_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD25_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD25_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD25_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD25_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD25_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD25_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD25_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD25_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD25_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD25_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD25_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD25_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD25_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD25_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD25_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD25_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD25_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD25_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD25_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD25_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD25_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD25_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD25_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD25_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD25_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD25_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD25_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD25_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD25_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD25_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD25_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD25_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD25_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD25_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD25_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD25_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD25_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD25_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD25_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD25_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD25_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD25_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD25_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD25_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD25_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD25_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD25_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD25_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD25_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD25_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD25_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD25_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD25_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD25_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD25_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD25_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD25_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD25_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD25_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD25_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD25_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD25_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD25_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD25_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD25_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD25_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD25_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD25_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD25_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD25_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD25_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD25_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD25_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD26_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD26_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD26_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD26_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD26_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD26_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD26_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD26_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD26_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD26_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD26_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD26_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD26_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD26_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD26_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD26_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD26_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD26_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD26_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD26_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD26_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD26_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD26_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD26_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD26_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD26_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD26_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD26_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD26_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD26_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD26_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD26_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD26_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD26_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD26_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD26_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD26_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD26_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD26_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD26_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD26_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD26_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD26_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD26_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD26_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	CITER   TCD26_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD26_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD26_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD26_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	DLASTSGA TCD26_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD26_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD26_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD26_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD26_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD26_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD26_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD26_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD26_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD26_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD26_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD26_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD26_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD26_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD26_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD26_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD26_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD26_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD26_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD26_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD26_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD26_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD26_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD26_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD26_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD26_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD26_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD26_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD26_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD26_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD26_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD26_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD26_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD26_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD26_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD27_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD27_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD27_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD27_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD27_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD27_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD27_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD27_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD27_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD27_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD27_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD27_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD27_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD27_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD27_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD27_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD27_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD27_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD27_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD27_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD27_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD27_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD27_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD27_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD27_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD27_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD27_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD27_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD27_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD27_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD27_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD27_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD27_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD27_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD27_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD27_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD27_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD27_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD27_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD27_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD27_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD27_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD27_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD27_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD27_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD27_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD27_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD27_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD27_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD27_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD27_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD27_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD27_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD27_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD27_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD27_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD27_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD27_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD27_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD27_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD27_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD27_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD27_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD27_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD27_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD27_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD27_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD27_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD27_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD27_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD27_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD27_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD27_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD27_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD27_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD27_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD27_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD27_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD27_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD27_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD27_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD27_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD27_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD27_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD28_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD28_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD28_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD28_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD28_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD28_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD28_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD28_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD28_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD28_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD28_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD28_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD28_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD28_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD28_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD28_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD28_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD28_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD28_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD28_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD28_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES  TCD28_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD28_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD28_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD28_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD28_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD28_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD28_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD28_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES TCD28_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD28_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD28_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD28_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD28_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD28_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD28_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD28_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD28_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD28_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD28_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD28_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD28_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD28_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD28_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD28_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD28_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD28_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD28_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD28_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD28_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD28_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD28_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD28_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD28_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD28_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD28_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD28_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD28_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD28_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD28_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD28_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD28_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD28_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD28_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD28_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD28_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD28_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD28_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD28_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD28_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD28_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD28_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD28_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD28_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD28_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD28_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD28_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD28_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD28_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD28_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD28_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD28_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD28_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD28_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD29_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD29_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD29_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD29_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD29_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD29_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD29_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD29_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD29_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD29_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD29_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD29_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD29_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD29_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD29_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD29_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD29_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD29_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD29_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD29_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD29_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD29_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD29_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD29_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD29_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD29_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD29_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD29_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD29_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD29_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD29_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD29_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD29_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD29_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD29_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD29_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD29_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD29_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD29_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD29_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD29_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD29_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD29_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD29_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD29_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD29_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD29_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD29_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD29_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD29_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD29_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD29_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD29_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD29_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD29_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD29_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD29_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD29_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD29_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD29_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD29_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD29_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD29_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD29_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD29_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD29_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD29_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD29_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD29_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD29_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD29_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD29_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD29_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD29_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD29_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD29_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD29_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD29_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD29_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD29_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	BITER   TCD29_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD29_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD29_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD29_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	SADDR TCD30_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD30_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD30_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD30_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD30_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD30_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD30_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD30_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD30_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD30_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD30_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD30_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD30_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD30_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD30_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD30_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD30_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD30_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD30_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD30_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD30_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD30_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD30_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD30_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD30_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD30_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD30_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD30_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD30_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD30_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD30_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD30_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD30_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD30_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD30_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD30_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD30_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD30_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD30_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD30_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD30_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD30_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD30_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD30_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD30_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD30_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD30_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD30_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD30_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD30_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD30_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD30_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD30_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD30_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD30_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD30_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD30_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD30_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD30_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD30_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD30_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD30_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD30_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD30_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD30_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD30_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD30_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD30_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD30_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD30_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD30_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD30_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD30_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD30_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD30_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD30_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD30_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD30_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD30_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD30_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD30_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD30_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD30_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD30_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	SADDR TCD31_SADDR = 0xFFFFFFFF << 0 //+ Source Address
)

const (
	SADDRn = 0
)

const (
	SOFF TCD31_SOFF = 0xFFFF << 0 //+ Source address signed offset
)

const (
	SOFFn = 0
)

const (
	DSIZE   TCD31_ATTR = 0x07 << 0  //+ Destination data transfer size
	DMOD    TCD31_ATTR = 0x1F << 3  //+ Destination Address Modulo
	SSIZE   TCD31_ATTR = 0x07 << 8  //+ Source data transfer size
	SSIZE_0 TCD31_ATTR = 0x00 << 8  //  8-bit
	SSIZE_1 TCD31_ATTR = 0x01 << 8  //  16-bit
	SSIZE_2 TCD31_ATTR = 0x02 << 8  //  32-bit
	SSIZE_3 TCD31_ATTR = 0x03 << 8  //  64-bit
	SSIZE_5 TCD31_ATTR = 0x05 << 8  //  32-byte burst (4 beats of 64 bits)
	SMOD    TCD31_ATTR = 0x1F << 11 //+ Source Address Modulo
	SMOD_0  TCD31_ATTR = 0x00 << 11 //  Source address modulo feature is disabled
	SMOD_1  TCD31_ATTR = 0x01 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_2  TCD31_ATTR = 0x02 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_3  TCD31_ATTR = 0x03 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_4  TCD31_ATTR = 0x04 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_5  TCD31_ATTR = 0x05 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_6  TCD31_ATTR = 0x06 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_7  TCD31_ATTR = 0x07 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_8  TCD31_ATTR = 0x08 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	SMOD_9  TCD31_ATTR = 0x09 << 11 //  This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
)

const (
	DSIZEn = 0
	DMODn  = 3
	SSIZEn = 8
	SMODn  = 11
)

const (
	NBYTES TCD31_NBYTES_MLNO = 0xFFFFFFFF << 0 //+ Minor Byte Transfer Count
)

const (
	NBYTESn = 0
)

const (
	NBYTES  TCD31_NBYTES_MLOFFNO = 0x3FFFFFFF << 0 //+ Minor Byte Transfer Count
	DMLOE   TCD31_NBYTES_MLOFFNO = 0x01 << 30      //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD31_NBYTES_MLOFFNO = 0x00 << 30      //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD31_NBYTES_MLOFFNO = 0x01 << 30      //  The minor loop offset is applied to the DADDR
	SMLOE   TCD31_NBYTES_MLOFFNO = 0x01 << 31      //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD31_NBYTES_MLOFFNO = 0x00 << 31      //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD31_NBYTES_MLOFFNO = 0x01 << 31      //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	NBYTES  TCD31_NBYTES_MLOFFYES = 0x3FF << 0    //+ Minor Byte Transfer Count
	MLOFF   TCD31_NBYTES_MLOFFYES = 0xFFFFF << 10 //+ If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
	DMLOE   TCD31_NBYTES_MLOFFYES = 0x01 << 30    //+ Destination Minor Loop Offset enable
	DMLOE_0 TCD31_NBYTES_MLOFFYES = 0x00 << 30    //  The minor loop offset is not applied to the DADDR
	DMLOE_1 TCD31_NBYTES_MLOFFYES = 0x01 << 30    //  The minor loop offset is applied to the DADDR
	SMLOE   TCD31_NBYTES_MLOFFYES = 0x01 << 31    //+ Source Minor Loop Offset Enable
	SMLOE_0 TCD31_NBYTES_MLOFFYES = 0x00 << 31    //  The minor loop offset is not applied to the SADDR
	SMLOE_1 TCD31_NBYTES_MLOFFYES = 0x01 << 31    //  The minor loop offset is applied to the SADDR
)

const (
	NBYTESn = 0
	MLOFFn  = 10
	DMLOEn  = 30
	SMLOEn  = 31
)

const (
	SLAST TCD31_SLAST = 0xFFFFFFFF << 0 //+ Last Source Address Adjustment
)

const (
	SLASTn = 0
)

const (
	DADDR TCD31_DADDR = 0xFFFFFFFF << 0 //+ Destination Address
)

const (
	DADDRn = 0
)

const (
	DOFF TCD31_DOFF = 0xFFFF << 0 //+ Destination Address Signed Offset
)

const (
	DOFFn = 0
)

const (
	CITER   TCD31_CITER_ELINKNO = 0x7FFF << 0 //+ Current Major Iteration Count
	ELINK   TCD31_CITER_ELINKNO = 0x01 << 15  //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD31_CITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD31_CITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	CITERn = 0
	ELINKn = 15
)

const (
	CITER   TCD31_CITER_ELINKYES = 0x1FF << 0 //+ Current Major Iteration Count
	LINKCH  TCD31_CITER_ELINKYES = 0x1F << 9  //+ Minor Loop Link Channel Number
	ELINK   TCD31_CITER_ELINKYES = 0x01 << 15 //+ Enable channel-to-channel linking on minor-loop complete
	ELINK_0 TCD31_CITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD31_CITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	CITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)

const (
	DLASTSGA TCD31_DLASTSGA = 0xFFFFFFFF << 0 //+ DLASTSGA
)

const (
	DLASTSGAn = 0
)

const (
	START        TCD31_CSR = 0x01 << 0  //+ Channel Start
	START_0      TCD31_CSR = 0x00 << 0  //  The channel is not explicitly started.
	START_1      TCD31_CSR = 0x01 << 0  //  The channel is explicitly started via a software initiated service request.
	INTMAJOR     TCD31_CSR = 0x01 << 1  //+ Enable an interrupt when major iteration count completes.
	INTMAJOR_0   TCD31_CSR = 0x00 << 1  //  The end-of-major loop interrupt is disabled.
	INTMAJOR_1   TCD31_CSR = 0x01 << 1  //  The end-of-major loop interrupt is enabled.
	INTHALF      TCD31_CSR = 0x01 << 2  //+ Enable an interrupt when major counter is half complete.
	INTHALF_0    TCD31_CSR = 0x00 << 2  //  The half-point interrupt is disabled.
	INTHALF_1    TCD31_CSR = 0x01 << 2  //  The half-point interrupt is enabled.
	DREQ         TCD31_CSR = 0x01 << 3  //+ Disable Request
	DREQ_0       TCD31_CSR = 0x00 << 3  //  The channel's ERQ bit is not affected.
	DREQ_1       TCD31_CSR = 0x01 << 3  //  The channel's ERQ bit is cleared when the major loop is complete.
	ESG          TCD31_CSR = 0x01 << 4  //+ Enable Scatter/Gather Processing
	ESG_0        TCD31_CSR = 0x00 << 4  //  The current channel's TCD is normal format.
	ESG_1        TCD31_CSR = 0x01 << 4  //  The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	MAJORELINK   TCD31_CSR = 0x01 << 5  //+ Enable channel-to-channel linking on major loop complete
	MAJORELINK_0 TCD31_CSR = 0x00 << 5  //  The channel-to-channel linking is disabled.
	MAJORELINK_1 TCD31_CSR = 0x01 << 5  //  The channel-to-channel linking is enabled.
	ACTIVE       TCD31_CSR = 0x01 << 6  //+ Channel Active
	DONE         TCD31_CSR = 0x01 << 7  //+ Channel Done
	MAJORLINKCH  TCD31_CSR = 0x1F << 8  //+ Major Loop Link Channel Number
	BWC          TCD31_CSR = 0x03 << 14 //+ Bandwidth Control
	BWC_0        TCD31_CSR = 0x00 << 14 //  No eDMA engine stalls.
	BWC_2        TCD31_CSR = 0x02 << 14 //  eDMA engine stalls for 4 cycles after each R/W.
	BWC_3        TCD31_CSR = 0x03 << 14 //  eDMA engine stalls for 8 cycles after each R/W.
)

const (
	STARTn       = 0
	INTMAJORn    = 1
	INTHALFn     = 2
	DREQn        = 3
	ESGn         = 4
	MAJORELINKn  = 5
	ACTIVEn      = 6
	DONEn        = 7
	MAJORLINKCHn = 8
	BWCn         = 14
)

const (
	BITER   TCD31_BITER_ELINKNO = 0x7FFF << 0 //+ Starting Major Iteration Count
	ELINK   TCD31_BITER_ELINKNO = 0x01 << 15  //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD31_BITER_ELINKNO = 0x00 << 15  //  The channel-to-channel linking is disabled
	ELINK_1 TCD31_BITER_ELINKNO = 0x01 << 15  //  The channel-to-channel linking is enabled
)

const (
	BITERn = 0
	ELINKn = 15
)

const (
	BITER   TCD31_BITER_ELINKYES = 0x1FF << 0 //+ Starting major iteration count
	LINKCH  TCD31_BITER_ELINKYES = 0x1F << 9  //+ Link Channel Number
	ELINK   TCD31_BITER_ELINKYES = 0x01 << 15 //+ Enables channel-to-channel linking on minor loop complete
	ELINK_0 TCD31_BITER_ELINKYES = 0x00 << 15 //  The channel-to-channel linking is disabled
	ELINK_1 TCD31_BITER_ELINKYES = 0x01 << 15 //  The channel-to-channel linking is enabled
)

const (
	BITERn  = 0
	LINKCHn = 9
	ELINKn  = 15
)
