// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package trng provides access to the registers of the TRNG peripheral.
//
// Instances:
//
//	TRNG  TRNG_BASE  -  TRNG*
//
// Registers:
//
//	0x000 32  MCTL        Miscellaneous Control Register
//	0x004 32  SCMISC      Statistical Check Miscellaneous Register
//	0x008 32  PKRRNG      Poker Range Register
//	0x00C 32  PKRMAX      Poker Maximum Limit Register
//	0x00C 32  PKRSQ       Poker Square Calculation Result Register
//	0x010 32  SDCTL       Seed Control Register
//	0x014 32  SBLIM       Sparse Bit Limit Register
//	0x014 32  TOTSAM      Total Samples Register
//	0x018 32  FRQMIN      Frequency Count Minimum Limit Register
//	0x01C 32  FRQCNT      Frequency Count Register
//	0x01C 32  FRQMAX      Frequency Count Maximum Limit Register
//	0x020 32  SCMC        Statistical Check Monobit Count Register
//	0x020 32  SCML        Statistical Check Monobit Limit Register
//	0x024 32  SCR1C       Statistical Check Run Length 1 Count Register
//	0x024 32  SCR1L       Statistical Check Run Length 1 Limit Register
//	0x028 32  SCR2C       Statistical Check Run Length 2 Count Register
//	0x028 32  SCR2L       Statistical Check Run Length 2 Limit Register
//	0x02C 32  SCR3C       Statistical Check Run Length 3 Count Register
//	0x02C 32  SCR3L       Statistical Check Run Length 3 Limit Register
//	0x030 32  SCR4C       Statistical Check Run Length 4 Count Register
//	0x030 32  SCR4L       Statistical Check Run Length 4 Limit Register
//	0x034 32  SCR5C       Statistical Check Run Length 5 Count Register
//	0x034 32  SCR5L       Statistical Check Run Length 5 Limit Register
//	0x038 32  SCR6PC      Statistical Check Run Length 6+ Count Register
//	0x038 32  SCR6PL      Statistical Check Run Length 6+ Limit Register
//	0x03C 32  STATUS      Status Register
//	0x040 32  ENT[16]     Entropy Read Register
//	0x080 32  PKRCNT10    Statistical Check Poker Count 1 and 0 Register
//	0x084 32  PKRCNT32    Statistical Check Poker Count 3 and 2 Register
//	0x088 32  PKRCNT54    Statistical Check Poker Count 5 and 4 Register
//	0x08C 32  PKRCNT76    Statistical Check Poker Count 7 and 6 Register
//	0x090 32  PKRCNT98    Statistical Check Poker Count 9 and 8 Register
//	0x094 32  PKRCNTBA    Statistical Check Poker Count B and A Register
//	0x098 32  PKRCNTDC    Statistical Check Poker Count D and C Register
//	0x09C 32  PKRCNTFE    Statistical Check Poker Count F and E Register
//	0x0A0 32  SEC_CFG     Security Configuration Register
//	0x0A4 32  INT_CTRL    Interrupt Control Register
//	0x0A8 32  INT_MASK    Mask Register
//	0x0AC 32  INT_STATUS  Interrupt Status Register
//	0x0F0 32  VID1        Version ID Register (MS)
//	0x0F4 32  VID2        Version ID Register (LS)
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package trng

const (
	SAMP_MODE   MCTL = 0x03 << 0  //+ Sample Mode
	SAMP_MODE_0 MCTL = 0x00 << 0  //  use Von Neumann data into both Entropy shifter and Statistical Checker
	SAMP_MODE_1 MCTL = 0x01 << 0  //  use raw data into both Entropy shifter and Statistical Checker
	SAMP_MODE_2 MCTL = 0x02 << 0  //  use Von Neumann data into Entropy shifter. Use raw data into Statistical Checker
	SAMP_MODE_3 MCTL = 0x03 << 0  //  undefined/reserved.
	OSC_DIV     MCTL = 0x03 << 2  //+ Oscillator Divide
	OSC_DIV_0   MCTL = 0x00 << 2  //  use ring oscillator with no divide
	OSC_DIV_1   MCTL = 0x01 << 2  //  use ring oscillator divided-by-2
	OSC_DIV_2   MCTL = 0x02 << 2  //  use ring oscillator divided-by-4
	OSC_DIV_3   MCTL = 0x03 << 2  //  use ring oscillator divided-by-8
	UNUSED4     MCTL = 0x01 << 4  //+ This bit is unused. Always reads zero.
	UNUSED5     MCTL = 0x01 << 5  //+ This bit is unused. Always reads zero.
	RST_DEF     MCTL = 0x01 << 6  //+ Reset Defaults
	FOR_SCLK    MCTL = 0x01 << 7  //+ Force System Clock
	FCT_FAIL    MCTL = 0x01 << 8  //+ Read only: Frequency Count Fail
	FCT_VAL     MCTL = 0x01 << 9  //+ Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
	ENT_VAL     MCTL = 0x01 << 10 //+ Read only: Entropy Valid
	TST_OUT     MCTL = 0x01 << 11 //+ Read only: Test point inside ring oscillator.
	ERR         MCTL = 0x01 << 12 //+ Read: Error status
	TSTOP_OK    MCTL = 0x01 << 13 //+ TRNG_OK_TO_STOP
	LRUN_CONT   MCTL = 0x01 << 14 //+ Long run count continues between entropy generations
	PRGM        MCTL = 0x01 << 16 //+ Programming Mode Select
)

const (
	SAMP_MODEn = 0
	OSC_DIVn   = 2
	UNUSED4n   = 4
	UNUSED5n   = 5
	RST_DEFn   = 6
	FOR_SCLKn  = 7
	FCT_FAILn  = 8
	FCT_VALn   = 9
	ENT_VALn   = 10
	TST_OUTn   = 11
	ERRn       = 12
	TSTOP_OKn  = 13
	LRUN_CONTn = 14
	PRGMn      = 16
)

const (
	LRUN_MAX SCMISC = 0xFF << 0  //+ LONG RUN MAX LIMIT
	RTY_CT   SCMISC = 0x0F << 16 //+ RETRY COUNT
)

const (
	LRUN_MAXn = 0
	RTY_CTn   = 16
)

const (
	PKR_RNG PKRRNG = 0xFFFF << 0 //+ Poker Range
)

const (
	PKR_RNGn = 0
)

const (
	PKR_MAX PKRMAX = 0xFFFFFF << 0 //+ Poker Maximum Limit.
)

const (
	PKR_MAXn = 0
)

const (
	PKR_SQ PKRSQ = 0xFFFFFF << 0 //+ Poker Square Calculation Result.
)

const (
	PKR_SQn = 0
)

const (
	SAMP_SIZE SDCTL = 0xFFFF << 0  //+ Sample Size
	ENT_DLY   SDCTL = 0xFFFF << 16 //+ Entropy Delay
)

const (
	SAMP_SIZEn = 0
	ENT_DLYn   = 16
)

const (
	SB_LIM SBLIM = 0x3FF << 0 //+ Sparse Bit Limit
)

const (
	SB_LIMn = 0
)

const (
	TOT_SAM TOTSAM = 0xFFFFF << 0 //+ Total Samples
)

const (
	TOT_SAMn = 0
)

const (
	FRQ_MIN FRQMIN = 0x3FFFFF << 0 //+ Frequency Count Minimum Limit
)

const (
	FRQ_MINn = 0
)

const (
	FRQ_CT FRQCNT = 0x3FFFFF << 0 //+ Frequency Count
)

const (
	FRQ_CTn = 0
)

const (
	FRQ_MAX FRQMAX = 0x3FFFFF << 0 //+ Frequency Counter Maximum Limit
)

const (
	FRQ_MAXn = 0
)

const (
	MONO_CT SCMC = 0xFFFF << 0 //+ Monobit Count
)

const (
	MONO_CTn = 0
)

const (
	MONO_MAX SCML = 0xFFFF << 0  //+ Monobit Maximum Limit
	MONO_RNG SCML = 0xFFFF << 16 //+ Monobit Range
)

const (
	MONO_MAXn = 0
	MONO_RNGn = 16
)

const (
	R1_0_CT SCR1C = 0x7FFF << 0  //+ Runs of Zero, Length 1 Count
	R1_1_CT SCR1C = 0x7FFF << 16 //+ Runs of One, Length 1 Count
)

const (
	R1_0_CTn = 0
	R1_1_CTn = 16
)

const (
	RUN1_MAX SCR1L = 0x7FFF << 0  //+ Run Length 1 Maximum Limit
	RUN1_RNG SCR1L = 0x7FFF << 16 //+ Run Length 1 Range
)

const (
	RUN1_MAXn = 0
	RUN1_RNGn = 16
)

const (
	R2_0_CT SCR2C = 0x3FFF << 0  //+ Runs of Zero, Length 2 Count
	R2_1_CT SCR2C = 0x3FFF << 16 //+ Runs of One, Length 2 Count
)

const (
	R2_0_CTn = 0
	R2_1_CTn = 16
)

const (
	RUN2_MAX SCR2L = 0x3FFF << 0  //+ Run Length 2 Maximum Limit
	RUN2_RNG SCR2L = 0x3FFF << 16 //+ Run Length 2 Range
)

const (
	RUN2_MAXn = 0
	RUN2_RNGn = 16
)

const (
	R3_0_CT SCR3C = 0x1FFF << 0  //+ Runs of Zeroes, Length 3 Count
	R3_1_CT SCR3C = 0x1FFF << 16 //+ Runs of Ones, Length 3 Count
)

const (
	R3_0_CTn = 0
	R3_1_CTn = 16
)

const (
	RUN3_MAX SCR3L = 0x1FFF << 0  //+ Run Length 3 Maximum Limit
	RUN3_RNG SCR3L = 0x1FFF << 16 //+ Run Length 3 Range
)

const (
	RUN3_MAXn = 0
	RUN3_RNGn = 16
)

const (
	R4_0_CT SCR4C = 0xFFF << 0  //+ Runs of Zero, Length 4 Count
	R4_1_CT SCR4C = 0xFFF << 16 //+ Runs of One, Length 4 Count
)

const (
	R4_0_CTn = 0
	R4_1_CTn = 16
)

const (
	RUN4_MAX SCR4L = 0xFFF << 0  //+ Run Length 4 Maximum Limit
	RUN4_RNG SCR4L = 0xFFF << 16 //+ Run Length 4 Range
)

const (
	RUN4_MAXn = 0
	RUN4_RNGn = 16
)

const (
	R5_0_CT SCR5C = 0x7FF << 0  //+ Runs of Zero, Length 5 Count
	R5_1_CT SCR5C = 0x7FF << 16 //+ Runs of One, Length 5 Count
)

const (
	R5_0_CTn = 0
	R5_1_CTn = 16
)

const (
	RUN5_MAX SCR5L = 0x7FF << 0  //+ Run Length 5 Maximum Limit
	RUN5_RNG SCR5L = 0x7FF << 16 //+ Run Length 5 Range
)

const (
	RUN5_MAXn = 0
	RUN5_RNGn = 16
)

const (
	R6P_0_CT SCR6PC = 0x7FF << 0  //+ Runs of Zero, Length 6+ Count
	R6P_1_CT SCR6PC = 0x7FF << 16 //+ Runs of One, Length 6+ Count
)

const (
	R6P_0_CTn = 0
	R6P_1_CTn = 16
)

const (
	RUN6P_MAX SCR6PL = 0x7FF << 0  //+ Run Length 6+ Maximum Limit
	RUN6P_RNG SCR6PL = 0x7FF << 16 //+ Run Length 6+ Range
)

const (
	RUN6P_MAXn = 0
	RUN6P_RNGn = 16
)

const (
	TF1BR0   STATUS = 0x01 << 0  //+ Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
	TF1BR1   STATUS = 0x01 << 1  //+ Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
	TF2BR0   STATUS = 0x01 << 2  //+ Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
	TF2BR1   STATUS = 0x01 << 3  //+ Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
	TF3BR0   STATUS = 0x01 << 4  //+ Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
	TF3BR1   STATUS = 0x01 << 5  //+ Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
	TF4BR0   STATUS = 0x01 << 6  //+ Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
	TF4BR1   STATUS = 0x01 << 7  //+ Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
	TF5BR0   STATUS = 0x01 << 8  //+ Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
	TF5BR1   STATUS = 0x01 << 9  //+ Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
	TF6PBR0  STATUS = 0x01 << 10 //+ Test Fail, 6 Plus Bit Run, Sampling 0s
	TF6PBR1  STATUS = 0x01 << 11 //+ Test Fail, 6 Plus Bit Run, Sampling 1s
	TFSB     STATUS = 0x01 << 12 //+ Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
	TFLR     STATUS = 0x01 << 13 //+ Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
	TFP      STATUS = 0x01 << 14 //+ Test Fail, Poker. If TFP=1, the Poker Test has failed.
	TFMB     STATUS = 0x01 << 15 //+ Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
	RETRY_CT STATUS = 0x0F << 16 //+ RETRY COUNT
)

const (
	TF1BR0n   = 0
	TF1BR1n   = 1
	TF2BR0n   = 2
	TF2BR1n   = 3
	TF3BR0n   = 4
	TF3BR1n   = 5
	TF4BR0n   = 6
	TF4BR1n   = 7
	TF5BR0n   = 8
	TF5BR1n   = 9
	TF6PBR0n  = 10
	TF6PBR1n  = 11
	TFSBn     = 12
	TFLRn     = 13
	TFPn      = 14
	TFMBn     = 15
	RETRY_CTn = 16
)

const (
	ENT ENT = 0xFFFFFFFF << 0 //+ Entropy Value
)

const (
	ENTn = 0
)

const (
	PKR_0_CT PKRCNT10 = 0xFFFF << 0  //+ Poker 0h Count
	PKR_1_CT PKRCNT10 = 0xFFFF << 16 //+ Poker 1h Count
)

const (
	PKR_0_CTn = 0
	PKR_1_CTn = 16
)

const (
	PKR_2_CT PKRCNT32 = 0xFFFF << 0  //+ Poker 2h Count
	PKR_3_CT PKRCNT32 = 0xFFFF << 16 //+ Poker 3h Count
)

const (
	PKR_2_CTn = 0
	PKR_3_CTn = 16
)

const (
	PKR_4_CT PKRCNT54 = 0xFFFF << 0  //+ Poker 4h Count
	PKR_5_CT PKRCNT54 = 0xFFFF << 16 //+ Poker 5h Count
)

const (
	PKR_4_CTn = 0
	PKR_5_CTn = 16
)

const (
	PKR_6_CT PKRCNT76 = 0xFFFF << 0  //+ Poker 6h Count
	PKR_7_CT PKRCNT76 = 0xFFFF << 16 //+ Poker 7h Count
)

const (
	PKR_6_CTn = 0
	PKR_7_CTn = 16
)

const (
	PKR_8_CT PKRCNT98 = 0xFFFF << 0  //+ Poker 8h Count
	PKR_9_CT PKRCNT98 = 0xFFFF << 16 //+ Poker 9h Count
)

const (
	PKR_8_CTn = 0
	PKR_9_CTn = 16
)

const (
	PKR_A_CT PKRCNTBA = 0xFFFF << 0  //+ Poker Ah Count
	PKR_B_CT PKRCNTBA = 0xFFFF << 16 //+ Poker Bh Count
)

const (
	PKR_A_CTn = 0
	PKR_B_CTn = 16
)

const (
	PKR_C_CT PKRCNTDC = 0xFFFF << 0  //+ Poker Ch Count
	PKR_D_CT PKRCNTDC = 0xFFFF << 16 //+ Poker Dh Count
)

const (
	PKR_C_CTn = 0
	PKR_D_CTn = 16
)

const (
	PKR_E_CT PKRCNTFE = 0xFFFF << 0  //+ Poker Eh Count
	PKR_F_CT PKRCNTFE = 0xFFFF << 16 //+ Poker Fh Count
)

const (
	PKR_E_CTn = 0
	PKR_F_CTn = 16
)

const (
	UNUSED0 SEC_CFG = 0x01 << 0 //+ This bit is unused. Ignore.
	NO_PRGM SEC_CFG = 0x01 << 1 //+ If set, the TRNG registers cannot be programmed
	UNUSED2 SEC_CFG = 0x01 << 2 //+ This bit is unused. Ignore.
)

const (
	UNUSED0n = 0
	NO_PRGMn = 1
	UNUSED2n = 2
)

const (
	HW_ERR      INT_CTRL = 0x01 << 0 //+ Bit position that can be cleared if corresponding bit of INT_STATUS register has been asserted.
	ENT_VAL     INT_CTRL = 0x01 << 1 //+ Same behavior as bit 0 of this register.
	FRQ_CT_FAIL INT_CTRL = 0x01 << 2 //+ Same behavior as bit 0 of this register.
)

const (
	HW_ERRn      = 0
	ENT_VALn     = 1
	FRQ_CT_FAILn = 2
)

const (
	HW_ERR      INT_MASK = 0x01 << 0 //+ Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
	ENT_VAL     INT_MASK = 0x01 << 1 //+ Same behavior as bit 0 of this register.
	FRQ_CT_FAIL INT_MASK = 0x01 << 2 //+ Same behavior as bit 0 of this register.
)

const (
	HW_ERRn      = 0
	ENT_VALn     = 1
	FRQ_CT_FAILn = 2
)

const (
	HW_ERR      INT_STATUS = 0x01 << 0 //+ Read: Error status
	ENT_VAL     INT_STATUS = 0x01 << 1 //+ Read only: Entropy Valid
	FRQ_CT_FAIL INT_STATUS = 0x01 << 2 //+ Read only: Frequency Count Fail
)

const (
	HW_ERRn      = 0
	ENT_VALn     = 1
	FRQ_CT_FAILn = 2
)

const (
	MIN_REV   VID1 = 0xFF << 0    //+ Shows the IP's Minor revision of the TRNG.
	MIN_REV_0 VID1 = 0x00 << 0    //  Minor revision number for TRNG.
	MAJ_REV   VID1 = 0xFF << 8    //+ Shows the IP's Major revision of the TRNG.
	MAJ_REV_1 VID1 = 0x01 << 8    //  Major revision number for TRNG.
	IP_ID     VID1 = 0xFFFF << 16 //+ Shows the IP ID.
	IP_ID_48  VID1 = 0x30 << 16   //  ID for TRNG.
)

const (
	MIN_REVn = 0
	MAJ_REVn = 8
	IP_IDn   = 16
)

const (
	CONFIG_OPT   VID2 = 0xFF << 0  //+ Shows the IP's Configuaration options for the TRNG.
	CONFIG_OPT_0 VID2 = 0x00 << 0  //  TRNG_CONFIG_OPT for TRNG.
	ECO_REV      VID2 = 0xFF << 8  //+ Shows the IP's ECO revision of the TRNG.
	ECO_REV_0    VID2 = 0x00 << 8  //  TRNG_ECO_REV for TRNG.
	INTG_OPT     VID2 = 0xFF << 16 //+ Shows the integration options for the TRNG.
	INTG_OPT_0   VID2 = 0x00 << 16 //  INTG_OPT for TRNG.
	ERA          VID2 = 0xFF << 24 //+ Shows the compile options for the TRNG.
	ERA_0        VID2 = 0x00 << 24 //  COMPILE_OPT for TRNG.
)

const (
	CONFIG_OPTn = 0
	ECO_REVn    = 8
	INTG_OPTn   = 16
	ERAn        = 24
)
