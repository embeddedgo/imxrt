// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package lpuart provides access to the registers of the LPUART peripheral.
//
// Instances:
//  LPUART1  LPUART1_BASE  -  LPUART1*
//  LPUART2  LPUART2_BASE  -  LPUART2*
//  LPUART3  LPUART3_BASE  -  LPUART3*
//  LPUART4  LPUART4_BASE  -  LPUART4*
//  LPUART5  LPUART5_BASE  -  LPUART5*
//  LPUART6  LPUART6_BASE  -  LPUART6*
//  LPUART7  LPUART7_BASE  -  LPUART7*
//  LPUART8  LPUART8_BASE  -  LPUART8*
// Registers:
//  0x000 32  VERID   Version ID Register
//  0x004 32  PARAM   Parameter Register
//  0x008 32  GLOBAL  LPUART Global Register
//  0x00C 32  PINCFG  LPUART Pin Configuration Register
//  0x010 32  BAUD    LPUART Baud Rate Register
//  0x014 32  STAT    LPUART Status Register
//  0x018 32  CTRL    LPUART Control Register
//  0x01C 32  DATA    LPUART Data Register
//  0x020 32  MATCH   LPUART Match Address Register
//  0x024 32  MODIR   LPUART Modem IrDA Register
//  0x028 32  FIFO    LPUART FIFO Register
//  0x02C 32  WATER   LPUART Watermark Register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package lpuart

const (
	FEATURE   VERID = 0xFFFF << 0 //+ Feature Identification Number
	FEATURE_1 VERID = 0x01 << 0   //  Standard feature set.
	FEATURE_3 VERID = 0x03 << 0   //  Standard feature set with MODEM/IrDA support.
	MINOR     VERID = 0xFF << 16  //+ Minor Version Number
	MAJOR     VERID = 0xFF << 24  //+ Major Version Number
)

const (
	FEATUREn = 0
	MINORn   = 16
	MAJORn   = 24
)

const (
	TXFIFO PARAM = 0xFF << 0 //+ Transmit FIFO Size
	RXFIFO PARAM = 0xFF << 8 //+ Receive FIFO Size
)

const (
	TXFIFOn = 0
	RXFIFOn = 8
)

const (
	RST   GLOBAL = 0x01 << 1 //+ Software Reset
	RST_0 GLOBAL = 0x00 << 1 //  Module is not reset.
	RST_1 GLOBAL = 0x01 << 1 //  Module is reset.
)

const (
	RSTn = 1
)

const (
	TRGSEL   PINCFG = 0x03 << 0 //+ Trigger Select
	TRGSEL_0 PINCFG = 0x00 << 0 //  Input trigger is disabled.
	TRGSEL_1 PINCFG = 0x01 << 0 //  Input trigger is used instead of RXD pin input.
	TRGSEL_2 PINCFG = 0x02 << 0 //  Input trigger is used instead of CTS_B pin input.
	TRGSEL_3 PINCFG = 0x03 << 0 //  Input trigger is used to modulate the TXD pin output. The TXD pin output (after TXINV configuration) is ANDed with the input trigger.
)

const (
	TRGSELn = 0
)

const (
	SBR         BAUD = 0x1FFF << 0 //+ Baud Rate Modulo Divisor.
	SBNS        BAUD = 0x01 << 13  //+ Stop Bit Number Select
	SBNS_0      BAUD = 0x00 << 13  //  One stop bit.
	SBNS_1      BAUD = 0x01 << 13  //  Two stop bits.
	RXEDGIE     BAUD = 0x01 << 14  //+ RX Input Active Edge Interrupt Enable
	RXEDGIE_0   BAUD = 0x00 << 14  //  Hardware interrupts from STAT[RXEDGIF] are disabled.
	RXEDGIE_1   BAUD = 0x01 << 14  //  Hardware interrupt is requested when STAT[RXEDGIF] flag is 1.
	LBKDIE      BAUD = 0x01 << 15  //+ LIN Break Detect Interrupt Enable
	LBKDIE_0    BAUD = 0x00 << 15  //  Hardware interrupts from STAT[LBKDIF] flag are disabled (use polling).
	LBKDIE_1    BAUD = 0x01 << 15  //  Hardware interrupt requested when STAT[LBKDIF] flag is 1.
	RESYNCDIS   BAUD = 0x01 << 16  //+ Resynchronization Disable
	RESYNCDIS_0 BAUD = 0x00 << 16  //  Resynchronization during received data word is supported
	RESYNCDIS_1 BAUD = 0x01 << 16  //  Resynchronization during received data word is disabled
	BOTHEDGE    BAUD = 0x01 << 17  //+ Both Edge Sampling
	BOTHEDGE_0  BAUD = 0x00 << 17  //  Receiver samples input data using the rising edge of the baud rate clock.
	BOTHEDGE_1  BAUD = 0x01 << 17  //  Receiver samples input data using the rising and falling edge of the baud rate clock.
	MATCFG      BAUD = 0x03 << 18  //+ Match Configuration
	MATCFG_0    BAUD = 0x00 << 18  //  Address Match Wakeup
	MATCFG_1    BAUD = 0x01 << 18  //  Idle Match Wakeup
	MATCFG_2    BAUD = 0x02 << 18  //  Match On and Match Off
	MATCFG_3    BAUD = 0x03 << 18  //  Enables RWU on Data Match and Match On/Off for transmitter CTS input
	RIDMAE      BAUD = 0x01 << 20  //+ Receiver Idle DMA Enable
	RIDMAE_0    BAUD = 0x00 << 20  //  DMA request disabled.
	RIDMAE_1    BAUD = 0x01 << 20  //  DMA request enabled.
	RDMAE       BAUD = 0x01 << 21  //+ Receiver Full DMA Enable
	RDMAE_0     BAUD = 0x00 << 21  //  DMA request disabled.
	RDMAE_1     BAUD = 0x01 << 21  //  DMA request enabled.
	TDMAE       BAUD = 0x01 << 23  //+ Transmitter DMA Enable
	TDMAE_0     BAUD = 0x00 << 23  //  DMA request disabled.
	TDMAE_1     BAUD = 0x01 << 23  //  DMA request enabled.
	OSR         BAUD = 0x1F << 24  //+ Oversampling Ratio
	OSR_0       BAUD = 0x00 << 24  //  Writing 0 to this field will result in an oversampling ratio of 16
	OSR_3       BAUD = 0x03 << 24  //  Oversampling ratio of 4, requires BOTHEDGE to be set.
	OSR_4       BAUD = 0x04 << 24  //  Oversampling ratio of 5, requires BOTHEDGE to be set.
	OSR_5       BAUD = 0x05 << 24  //  Oversampling ratio of 6, requires BOTHEDGE to be set.
	OSR_6       BAUD = 0x06 << 24  //  Oversampling ratio of 7, requires BOTHEDGE to be set.
	OSR_7       BAUD = 0x07 << 24  //  Oversampling ratio of 8.
	OSR_8       BAUD = 0x08 << 24  //  Oversampling ratio of 9.
	OSR_9       BAUD = 0x09 << 24  //  Oversampling ratio of 10.
	OSR_10      BAUD = 0x0A << 24  //  Oversampling ratio of 11.
	OSR_11      BAUD = 0x0B << 24  //  Oversampling ratio of 12.
	OSR_12      BAUD = 0x0C << 24  //  Oversampling ratio of 13.
	OSR_13      BAUD = 0x0D << 24  //  Oversampling ratio of 14.
	OSR_14      BAUD = 0x0E << 24  //  Oversampling ratio of 15.
	OSR_15      BAUD = 0x0F << 24  //  Oversampling ratio of 16.
	OSR_16      BAUD = 0x10 << 24  //  Oversampling ratio of 17.
	OSR_17      BAUD = 0x11 << 24  //  Oversampling ratio of 18.
	OSR_18      BAUD = 0x12 << 24  //  Oversampling ratio of 19.
	OSR_19      BAUD = 0x13 << 24  //  Oversampling ratio of 20.
	OSR_20      BAUD = 0x14 << 24  //  Oversampling ratio of 21.
	OSR_21      BAUD = 0x15 << 24  //  Oversampling ratio of 22.
	OSR_22      BAUD = 0x16 << 24  //  Oversampling ratio of 23.
	OSR_23      BAUD = 0x17 << 24  //  Oversampling ratio of 24.
	OSR_24      BAUD = 0x18 << 24  //  Oversampling ratio of 25.
	OSR_25      BAUD = 0x19 << 24  //  Oversampling ratio of 26.
	OSR_26      BAUD = 0x1A << 24  //  Oversampling ratio of 27.
	OSR_27      BAUD = 0x1B << 24  //  Oversampling ratio of 28.
	OSR_28      BAUD = 0x1C << 24  //  Oversampling ratio of 29.
	OSR_29      BAUD = 0x1D << 24  //  Oversampling ratio of 30.
	OSR_30      BAUD = 0x1E << 24  //  Oversampling ratio of 31.
	OSR_31      BAUD = 0x1F << 24  //  Oversampling ratio of 32.
	M10         BAUD = 0x01 << 29  //+ 10-bit Mode select
	M10_0       BAUD = 0x00 << 29  //  Receiver and transmitter use 7-bit to 9-bit data characters.
	M10_1       BAUD = 0x01 << 29  //  Receiver and transmitter use 10-bit data characters.
	MAEN2       BAUD = 0x01 << 30  //+ Match Address Mode Enable 2
	MAEN2_0     BAUD = 0x00 << 30  //  Normal operation.
	MAEN2_1     BAUD = 0x01 << 30  //  Enables automatic address matching or data matching mode for MATCH[MA2].
	MAEN1       BAUD = 0x01 << 31  //+ Match Address Mode Enable 1
	MAEN1_0     BAUD = 0x00 << 31  //  Normal operation.
	MAEN1_1     BAUD = 0x01 << 31  //  Enables automatic address matching or data matching mode for MATCH[MA1].
)

const (
	SBRn       = 0
	SBNSn      = 13
	RXEDGIEn   = 14
	LBKDIEn    = 15
	RESYNCDISn = 16
	BOTHEDGEn  = 17
	MATCFGn    = 18
	RIDMAEn    = 20
	RDMAEn     = 21
	TDMAEn     = 23
	OSRn       = 24
	M10n       = 29
	MAEN2n     = 30
	MAEN1n     = 31
)

const (
	MA2F      STAT = 0x01 << 14 //+ Match 2 Flag
	MA2F_0    STAT = 0x00 << 14 //  Received data is not equal to MA2
	MA2F_1    STAT = 0x01 << 14 //  Received data is equal to MA2
	MA1F      STAT = 0x01 << 15 //+ Match 1 Flag
	MA1F_0    STAT = 0x00 << 15 //  Received data is not equal to MA1
	MA1F_1    STAT = 0x01 << 15 //  Received data is equal to MA1
	PF        STAT = 0x01 << 16 //+ Parity Error Flag
	PF_0      STAT = 0x00 << 16 //  No parity error.
	PF_1      STAT = 0x01 << 16 //  Parity error.
	FE        STAT = 0x01 << 17 //+ Framing Error Flag
	FE_0      STAT = 0x00 << 17 //  No framing error detected. This does not guarantee the framing is correct.
	FE_1      STAT = 0x01 << 17 //  Framing error.
	NF        STAT = 0x01 << 18 //+ Noise Flag
	NF_0      STAT = 0x00 << 18 //  No noise detected.
	NF_1      STAT = 0x01 << 18 //  Noise detected in the received character in the DATA register.
	OR        STAT = 0x01 << 19 //+ Receiver Overrun Flag
	OR_0      STAT = 0x00 << 19 //  No overrun.
	OR_1      STAT = 0x01 << 19 //  Receive overrun (new LPUART data lost).
	IDLE      STAT = 0x01 << 20 //+ Idle Line Flag
	IDLE_0    STAT = 0x00 << 20 //  No idle line detected.
	IDLE_1    STAT = 0x01 << 20 //  Idle line was detected.
	RDRF      STAT = 0x01 << 21 //+ Receive Data Register Full Flag
	RDRF_0    STAT = 0x00 << 21 //  Receive data buffer empty.
	RDRF_1    STAT = 0x01 << 21 //  Receive data buffer full.
	TC        STAT = 0x01 << 22 //+ Transmission Complete Flag
	TC_0      STAT = 0x00 << 22 //  Transmitter active (sending data, a preamble, or a break).
	TC_1      STAT = 0x01 << 22 //  Transmitter idle (transmission activity complete).
	TDRE      STAT = 0x01 << 23 //+ Transmit Data Register Empty Flag
	TDRE_0    STAT = 0x00 << 23 //  Transmit data buffer full.
	TDRE_1    STAT = 0x01 << 23 //  Transmit data buffer empty.
	RAF       STAT = 0x01 << 24 //+ Receiver Active Flag
	RAF_0     STAT = 0x00 << 24 //  LPUART receiver idle waiting for a start bit.
	RAF_1     STAT = 0x01 << 24 //  LPUART receiver active (RXD input not idle).
	LBKDE     STAT = 0x01 << 25 //+ LIN Break Detection Enable
	LBKDE_0   STAT = 0x00 << 25 //  LIN break detect is disabled, normal break character can be detected.
	LBKDE_1   STAT = 0x01 << 25 //  LIN break detect is enabled. LIN break character is detected at length of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
	BRK13     STAT = 0x01 << 26 //+ Break Character Generation Length
	BRK13_0   STAT = 0x00 << 26 //  Break character is transmitted with length of 9 to 13 bit times.
	BRK13_1   STAT = 0x01 << 26 //  Break character is transmitted with length of 12 to 15 bit times.
	RWUID     STAT = 0x01 << 27 //+ Receive Wake Up Idle Detect
	RWUID_0   STAT = 0x00 << 27 //  During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not set when an address does not match.
	RWUID_1   STAT = 0x01 << 27 //  During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does set when an address does not match.
	RXINV     STAT = 0x01 << 28 //+ Receive Data Inversion
	RXINV_0   STAT = 0x00 << 28 //  Receive data not inverted.
	RXINV_1   STAT = 0x01 << 28 //  Receive data inverted.
	MSBF      STAT = 0x01 << 29 //+ MSB First
	MSBF_0    STAT = 0x00 << 29 //  LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	MSBF_1    STAT = 0x01 << 29 //  MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
	RXEDGIF   STAT = 0x01 << 30 //+ RXD Pin Active Edge Interrupt Flag
	RXEDGIF_0 STAT = 0x00 << 30 //  No active edge on the receive pin has occurred.
	RXEDGIF_1 STAT = 0x01 << 30 //  An active edge on the receive pin has occurred.
	LBKDIF    STAT = 0x01 << 31 //+ LIN Break Detect Interrupt Flag
	LBKDIF_0  STAT = 0x00 << 31 //  No LIN break character has been detected.
	LBKDIF_1  STAT = 0x01 << 31 //  LIN break character has been detected.
)

const (
	MA2Fn    = 14
	MA1Fn    = 15
	PFn      = 16
	FEn      = 17
	NFn      = 18
	ORn      = 19
	IDLEn    = 20
	RDRFn    = 21
	TCn      = 22
	TDREn    = 23
	RAFn     = 24
	LBKDEn   = 25
	BRK13n   = 26
	RWUIDn   = 27
	RXINVn   = 28
	MSBFn    = 29
	RXEDGIFn = 30
	LBKDIFn  = 31
)

const (
	PT        CTRL = 0x01 << 0  //+ Parity Type
	PT_0      CTRL = 0x00 << 0  //  Even parity.
	PT_1      CTRL = 0x01 << 0  //  Odd parity.
	PE        CTRL = 0x01 << 1  //+ Parity Enable
	PE_0      CTRL = 0x00 << 1  //  No hardware parity generation or checking.
	PE_1      CTRL = 0x01 << 1  //  Parity enabled.
	ILT       CTRL = 0x01 << 2  //+ Idle Line Type Select
	ILT_0     CTRL = 0x00 << 2  //  Idle character bit count starts after start bit.
	ILT_1     CTRL = 0x01 << 2  //  Idle character bit count starts after stop bit.
	WAKE      CTRL = 0x01 << 3  //+ Receiver Wakeup Method Select
	WAKE_0    CTRL = 0x00 << 3  //  Configures RWU for idle-line wakeup.
	WAKE_1    CTRL = 0x01 << 3  //  Configures RWU with address-mark wakeup.
	M         CTRL = 0x01 << 4  //+ 9-Bit or 8-Bit Mode Select
	M_0       CTRL = 0x00 << 4  //  Receiver and transmitter use 8-bit data characters.
	M_1       CTRL = 0x01 << 4  //  Receiver and transmitter use 9-bit data characters.
	RSRC      CTRL = 0x01 << 5  //+ Receiver Source Select
	RSRC_0    CTRL = 0x00 << 5  //  Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the RXD pin.
	RSRC_1    CTRL = 0x01 << 5  //  Single-wire LPUART mode where the TXD pin is connected to the transmitter output and receiver input.
	DOZEEN    CTRL = 0x01 << 6  //+ Doze Enable
	DOZEEN_0  CTRL = 0x00 << 6  //  LPUART is enabled in Doze mode.
	DOZEEN_1  CTRL = 0x01 << 6  //  LPUART is disabled in Doze mode.
	LOOPS     CTRL = 0x01 << 7  //+ Loop Mode Select
	LOOPS_0   CTRL = 0x00 << 7  //  Normal operation - RXD and TXD use separate pins.
	LOOPS_1   CTRL = 0x01 << 7  //  Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
	IDLECFG   CTRL = 0x07 << 8  //+ Idle Configuration
	IDLECFG_0 CTRL = 0x00 << 8  //  1 idle character
	IDLECFG_1 CTRL = 0x01 << 8  //  2 idle characters
	IDLECFG_2 CTRL = 0x02 << 8  //  4 idle characters
	IDLECFG_3 CTRL = 0x03 << 8  //  8 idle characters
	IDLECFG_4 CTRL = 0x04 << 8  //  16 idle characters
	IDLECFG_5 CTRL = 0x05 << 8  //  32 idle characters
	IDLECFG_6 CTRL = 0x06 << 8  //  64 idle characters
	IDLECFG_7 CTRL = 0x07 << 8  //  128 idle characters
	M7        CTRL = 0x01 << 11 //+ 7-Bit Mode Select
	M7_0      CTRL = 0x00 << 11 //  Receiver and transmitter use 8-bit to 10-bit data characters.
	M7_1      CTRL = 0x01 << 11 //  Receiver and transmitter use 7-bit data characters.
	MA2IE     CTRL = 0x01 << 14 //+ Match 2 Interrupt Enable
	MA2IE_0   CTRL = 0x00 << 14 //  MA2F interrupt disabled
	MA2IE_1   CTRL = 0x01 << 14 //  MA2F interrupt enabled
	MA1IE     CTRL = 0x01 << 15 //+ Match 1 Interrupt Enable
	MA1IE_0   CTRL = 0x00 << 15 //  MA1F interrupt disabled
	MA1IE_1   CTRL = 0x01 << 15 //  MA1F interrupt enabled
	SBK       CTRL = 0x01 << 16 //+ Send Break
	SBK_0     CTRL = 0x00 << 16 //  Normal transmitter operation.
	SBK_1     CTRL = 0x01 << 16 //  Queue break character(s) to be sent.
	RWU       CTRL = 0x01 << 17 //+ Receiver Wakeup Control
	RWU_0     CTRL = 0x00 << 17 //  Normal receiver operation.
	RWU_1     CTRL = 0x01 << 17 //  LPUART receiver in standby waiting for wakeup condition.
	RE        CTRL = 0x01 << 18 //+ Receiver Enable
	RE_0      CTRL = 0x00 << 18 //  Receiver disabled.
	RE_1      CTRL = 0x01 << 18 //  Receiver enabled.
	TE        CTRL = 0x01 << 19 //+ Transmitter Enable
	TE_0      CTRL = 0x00 << 19 //  Transmitter disabled.
	TE_1      CTRL = 0x01 << 19 //  Transmitter enabled.
	ILIE      CTRL = 0x01 << 20 //+ Idle Line Interrupt Enable
	ILIE_0    CTRL = 0x00 << 20 //  Hardware interrupts from IDLE disabled; use polling.
	ILIE_1    CTRL = 0x01 << 20 //  Hardware interrupt requested when IDLE flag is 1.
	RIE       CTRL = 0x01 << 21 //+ Receiver Interrupt Enable
	RIE_0     CTRL = 0x00 << 21 //  Hardware interrupts from RDRF disabled; use polling.
	RIE_1     CTRL = 0x01 << 21 //  Hardware interrupt requested when RDRF flag is 1.
	TCIE      CTRL = 0x01 << 22 //+ Transmission Complete Interrupt Enable for
	TCIE_0    CTRL = 0x00 << 22 //  Hardware interrupts from TC disabled; use polling.
	TCIE_1    CTRL = 0x01 << 22 //  Hardware interrupt requested when TC flag is 1.
	TIE       CTRL = 0x01 << 23 //+ Transmit Interrupt Enable
	TIE_0     CTRL = 0x00 << 23 //  Hardware interrupts from TDRE disabled; use polling.
	TIE_1     CTRL = 0x01 << 23 //  Hardware interrupt requested when TDRE flag is 1.
	PEIE      CTRL = 0x01 << 24 //+ Parity Error Interrupt Enable
	PEIE_0    CTRL = 0x00 << 24 //  PF interrupts disabled; use polling).
	PEIE_1    CTRL = 0x01 << 24 //  Hardware interrupt requested when PF is set.
	FEIE      CTRL = 0x01 << 25 //+ Framing Error Interrupt Enable
	FEIE_0    CTRL = 0x00 << 25 //  FE interrupts disabled; use polling.
	FEIE_1    CTRL = 0x01 << 25 //  Hardware interrupt requested when FE is set.
	NEIE      CTRL = 0x01 << 26 //+ Noise Error Interrupt Enable
	NEIE_0    CTRL = 0x00 << 26 //  NF interrupts disabled; use polling.
	NEIE_1    CTRL = 0x01 << 26 //  Hardware interrupt requested when NF is set.
	ORIE      CTRL = 0x01 << 27 //+ Overrun Interrupt Enable
	ORIE_0    CTRL = 0x00 << 27 //  OR interrupts disabled; use polling.
	ORIE_1    CTRL = 0x01 << 27 //  Hardware interrupt requested when OR is set.
	TXINV     CTRL = 0x01 << 28 //+ Transmit Data Inversion
	TXINV_0   CTRL = 0x00 << 28 //  Transmit data not inverted.
	TXINV_1   CTRL = 0x01 << 28 //  Transmit data inverted.
	TXDIR     CTRL = 0x01 << 29 //+ TXD Pin Direction in Single-Wire Mode
	TXDIR_0   CTRL = 0x00 << 29 //  TXD pin is an input in single-wire mode.
	TXDIR_1   CTRL = 0x01 << 29 //  TXD pin is an output in single-wire mode.
	R9T8      CTRL = 0x01 << 30 //+ Receive Bit 9 / Transmit Bit 8
	R8T9      CTRL = 0x01 << 31 //+ Receive Bit 8 / Transmit Bit 9
)

const (
	PTn      = 0
	PEn      = 1
	ILTn     = 2
	WAKEn    = 3
	Mn       = 4
	RSRCn    = 5
	DOZEENn  = 6
	LOOPSn   = 7
	IDLECFGn = 8
	M7n      = 11
	MA2IEn   = 14
	MA1IEn   = 15
	SBKn     = 16
	RWUn     = 17
	REn      = 18
	TEn      = 19
	ILIEn    = 20
	RIEn     = 21
	TCIEn    = 22
	TIEn     = 23
	PEIEn    = 24
	FEIEn    = 25
	NEIEn    = 26
	ORIEn    = 27
	TXINVn   = 28
	TXDIRn   = 29
	R9T8n    = 30
	R8T9n    = 31
)

const (
	R0T0      DATA = 0x01 << 0  //+ R0T0
	R1T1      DATA = 0x01 << 1  //+ R1T1
	R2T2      DATA = 0x01 << 2  //+ R2T2
	R3T3      DATA = 0x01 << 3  //+ R3T3
	R4T4      DATA = 0x01 << 4  //+ R4T4
	R5T5      DATA = 0x01 << 5  //+ R5T5
	R6T6      DATA = 0x01 << 6  //+ R6T6
	R7T7      DATA = 0x01 << 7  //+ R7T7
	R8T8      DATA = 0x01 << 8  //+ R8T8
	R9T9      DATA = 0x01 << 9  //+ R9T9
	IDLINE    DATA = 0x01 << 11 //+ Idle Line
	IDLINE_0  DATA = 0x00 << 11 //  Receiver was not idle before receiving this character.
	IDLINE_1  DATA = 0x01 << 11 //  Receiver was idle before receiving this character.
	RXEMPT    DATA = 0x01 << 12 //+ Receive Buffer Empty
	RXEMPT_0  DATA = 0x00 << 12 //  Receive buffer contains valid data.
	RXEMPT_1  DATA = 0x01 << 12 //  Receive buffer is empty, data returned on read is not valid.
	FRETSC    DATA = 0x01 << 13 //+ Frame Error / Transmit Special Character
	FRETSC_0  DATA = 0x00 << 13 //  The dataword was received without a frame error on read, or transmit a normal character on write.
	FRETSC_1  DATA = 0x01 << 13 //  The dataword was received with a frame error, or transmit an idle or break character on transmit.
	PARITYE   DATA = 0x01 << 14 //+ PARITYE
	PARITYE_0 DATA = 0x00 << 14 //  The dataword was received without a parity error.
	PARITYE_1 DATA = 0x01 << 14 //  The dataword was received with a parity error.
	NOISY     DATA = 0x01 << 15 //+ NOISY
	NOISY_0   DATA = 0x00 << 15 //  The dataword was received without noise.
	NOISY_1   DATA = 0x01 << 15 //  The data was received with noise.
)

const (
	R0T0n    = 0
	R1T1n    = 1
	R2T2n    = 2
	R3T3n    = 3
	R4T4n    = 4
	R5T5n    = 5
	R6T6n    = 6
	R7T7n    = 7
	R8T8n    = 8
	R9T9n    = 9
	IDLINEn  = 11
	RXEMPTn  = 12
	FRETSCn  = 13
	PARITYEn = 14
	NOISYn   = 15
)

const (
	MA1 MATCH = 0x3FF << 0  //+ Match Address 1
	MA2 MATCH = 0x3FF << 16 //+ Match Address 2
)

const (
	MA1n = 0
	MA2n = 16
)

const (
	TXCTSE     MODIR = 0x01 << 0  //+ Transmitter clear-to-send enable
	TXCTSE_0   MODIR = 0x00 << 0  //  CTS has no effect on the transmitter.
	TXCTSE_1   MODIR = 0x01 << 0  //  Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	TXRTSE     MODIR = 0x01 << 1  //+ Transmitter request-to-send enable
	TXRTSE_0   MODIR = 0x00 << 1  //  The transmitter has no effect on RTS.
	TXRTSE_1   MODIR = 0x01 << 1  //  When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
	TXRTSPOL   MODIR = 0x01 << 2  //+ Transmitter request-to-send polarity
	TXRTSPOL_0 MODIR = 0x00 << 2  //  Transmitter RTS is active low.
	TXRTSPOL_1 MODIR = 0x01 << 2  //  Transmitter RTS is active high.
	RXRTSE     MODIR = 0x01 << 3  //+ Receiver request-to-send enable
	RXRTSE_0   MODIR = 0x00 << 3  //  The receiver has no effect on RTS.
	RXRTSE_1   MODIR = 0x01 << 3  //  RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.
	TXCTSC     MODIR = 0x01 << 4  //+ Transmit CTS Configuration
	TXCTSC_0   MODIR = 0x00 << 4  //  CTS input is sampled at the start of each character.
	TXCTSC_1   MODIR = 0x01 << 4  //  CTS input is sampled when the transmitter is idle.
	TXCTSSRC   MODIR = 0x01 << 5  //+ Transmit CTS Source
	TXCTSSRC_0 MODIR = 0x00 << 5  //  CTS input is the CTS_B pin.
	TXCTSSRC_1 MODIR = 0x01 << 5  //  CTS input is the inverted Receiver Match result.
	RTSWATER   MODIR = 0x03 << 8  //+ Receive RTS Configuration
	TNP        MODIR = 0x03 << 16 //+ Transmitter narrow pulse
	TNP_0      MODIR = 0x00 << 16 //  1/OSR.
	TNP_1      MODIR = 0x01 << 16 //  2/OSR.
	TNP_2      MODIR = 0x02 << 16 //  3/OSR.
	TNP_3      MODIR = 0x03 << 16 //  4/OSR.
	IREN       MODIR = 0x01 << 18 //+ Infrared enable
	IREN_0     MODIR = 0x00 << 18 //  IR disabled.
	IREN_1     MODIR = 0x01 << 18 //  IR enabled.
)

const (
	TXCTSEn   = 0
	TXRTSEn   = 1
	TXRTSPOLn = 2
	RXRTSEn   = 3
	TXCTSCn   = 4
	TXCTSSRCn = 5
	RTSWATERn = 8
	TNPn      = 16
	IRENn     = 18
)

const (
	RXFIFOSIZE   FIFO = 0x07 << 0  //+ Receive FIFO Buffer Depth
	RXFIFOSIZE_0 FIFO = 0x00 << 0  //  Receive FIFO/Buffer depth = 1 dataword.
	RXFIFOSIZE_1 FIFO = 0x01 << 0  //  Receive FIFO/Buffer depth = 4 datawords.
	RXFIFOSIZE_2 FIFO = 0x02 << 0  //  Receive FIFO/Buffer depth = 8 datawords.
	RXFIFOSIZE_3 FIFO = 0x03 << 0  //  Receive FIFO/Buffer depth = 16 datawords.
	RXFIFOSIZE_4 FIFO = 0x04 << 0  //  Receive FIFO/Buffer depth = 32 datawords.
	RXFIFOSIZE_5 FIFO = 0x05 << 0  //  Receive FIFO/Buffer depth = 64 datawords.
	RXFIFOSIZE_6 FIFO = 0x06 << 0  //  Receive FIFO/Buffer depth = 128 datawords.
	RXFIFOSIZE_7 FIFO = 0x07 << 0  //  Receive FIFO/Buffer depth = 256 datawords.
	RXFE         FIFO = 0x01 << 3  //+ Receive FIFO Enable
	RXFE_0       FIFO = 0x00 << 3  //  Receive FIFO is not enabled. Buffer is depth 1.
	RXFE_1       FIFO = 0x01 << 3  //  Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
	TXFIFOSIZE   FIFO = 0x07 << 4  //+ Transmit FIFO Buffer Depth
	TXFIFOSIZE_0 FIFO = 0x00 << 4  //  Transmit FIFO/Buffer depth = 1 dataword.
	TXFIFOSIZE_1 FIFO = 0x01 << 4  //  Transmit FIFO/Buffer depth = 4 datawords.
	TXFIFOSIZE_2 FIFO = 0x02 << 4  //  Transmit FIFO/Buffer depth = 8 datawords.
	TXFIFOSIZE_3 FIFO = 0x03 << 4  //  Transmit FIFO/Buffer depth = 16 datawords.
	TXFIFOSIZE_4 FIFO = 0x04 << 4  //  Transmit FIFO/Buffer depth = 32 datawords.
	TXFIFOSIZE_5 FIFO = 0x05 << 4  //  Transmit FIFO/Buffer depth = 64 datawords.
	TXFIFOSIZE_6 FIFO = 0x06 << 4  //  Transmit FIFO/Buffer depth = 128 datawords.
	TXFIFOSIZE_7 FIFO = 0x07 << 4  //  Transmit FIFO/Buffer depth = 256 datawords
	TXFE         FIFO = 0x01 << 7  //+ Transmit FIFO Enable
	TXFE_0       FIFO = 0x00 << 7  //  Transmit FIFO is not enabled. Buffer is depth 1.
	TXFE_1       FIFO = 0x01 << 7  //  Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
	RXUFE        FIFO = 0x01 << 8  //+ Receive FIFO Underflow Interrupt Enable
	RXUFE_0      FIFO = 0x00 << 8  //  RXUF flag does not generate an interrupt to the host.
	RXUFE_1      FIFO = 0x01 << 8  //  RXUF flag generates an interrupt to the host.
	TXOFE        FIFO = 0x01 << 9  //+ Transmit FIFO Overflow Interrupt Enable
	TXOFE_0      FIFO = 0x00 << 9  //  TXOF flag does not generate an interrupt to the host.
	TXOFE_1      FIFO = 0x01 << 9  //  TXOF flag generates an interrupt to the host.
	RXIDEN       FIFO = 0x07 << 10 //+ Receiver Idle Empty Enable
	RXIDEN_0     FIFO = 0x00 << 10 //  Disable RDRF assertion due to partially filled FIFO when receiver is idle.
	RXIDEN_1     FIFO = 0x01 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 1 character.
	RXIDEN_2     FIFO = 0x02 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 2 characters.
	RXIDEN_3     FIFO = 0x03 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 4 characters.
	RXIDEN_4     FIFO = 0x04 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 8 characters.
	RXIDEN_5     FIFO = 0x05 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 16 characters.
	RXIDEN_6     FIFO = 0x06 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 32 characters.
	RXIDEN_7     FIFO = 0x07 << 10 //  Enable RDRF assertion due to partially filled FIFO when receiver is idle for 64 characters.
	RXFLUSH      FIFO = 0x01 << 14 //+ Receive FIFO/Buffer Flush
	RXFLUSH_0    FIFO = 0x00 << 14 //  No flush operation occurs.
	RXFLUSH_1    FIFO = 0x01 << 14 //  All data in the receive FIFO/buffer is cleared out.
	TXFLUSH      FIFO = 0x01 << 15 //+ Transmit FIFO/Buffer Flush
	TXFLUSH_0    FIFO = 0x00 << 15 //  No flush operation occurs.
	TXFLUSH_1    FIFO = 0x01 << 15 //  All data in the transmit FIFO/Buffer is cleared out.
	RXUF         FIFO = 0x01 << 16 //+ Receiver Buffer Underflow Flag
	RXUF_0       FIFO = 0x00 << 16 //  No receive buffer underflow has occurred since the last time the flag was cleared.
	RXUF_1       FIFO = 0x01 << 16 //  At least one receive buffer underflow has occurred since the last time the flag was cleared.
	TXOF         FIFO = 0x01 << 17 //+ Transmitter Buffer Overflow Flag
	TXOF_0       FIFO = 0x00 << 17 //  No transmit buffer overflow has occurred since the last time the flag was cleared.
	TXOF_1       FIFO = 0x01 << 17 //  At least one transmit buffer overflow has occurred since the last time the flag was cleared.
	RXEMPT       FIFO = 0x01 << 22 //+ Receive Buffer/FIFO Empty
	RXEMPT_0     FIFO = 0x00 << 22 //  Receive buffer is not empty.
	RXEMPT_1     FIFO = 0x01 << 22 //  Receive buffer is empty.
	TXEMPT       FIFO = 0x01 << 23 //+ Transmit Buffer/FIFO Empty
	TXEMPT_0     FIFO = 0x00 << 23 //  Transmit buffer is not empty.
	TXEMPT_1     FIFO = 0x01 << 23 //  Transmit buffer is empty.
)

const (
	RXFIFOSIZEn = 0
	RXFEn       = 3
	TXFIFOSIZEn = 4
	TXFEn       = 7
	RXUFEn      = 8
	TXOFEn      = 9
	RXIDENn     = 10
	RXFLUSHn    = 14
	TXFLUSHn    = 15
	RXUFn       = 16
	TXOFn       = 17
	RXEMPTn     = 22
	TXEMPTn     = 23
)

const (
	TXWATER WATER = 0x03 << 0  //+ Transmit Watermark
	TXCOUNT WATER = 0x07 << 8  //+ Transmit Counter
	RXWATER WATER = 0x03 << 16 //+ Receive Watermark
	RXCOUNT WATER = 0x07 << 24 //+ Receive Counter
)

const (
	TXWATERn = 0
	TXCOUNTn = 8
	RXWATERn = 16
	RXCOUNTn = 24
)
