// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package bee provides access to the registers of the BEE peripheral.
//
// Instances:
//  BEE  BEE_BASE  -  BEE*  Bus Encryption Engine
// Registers:
//  0x000 32  CTRL           BEE Control Register
//  0x004 32  ADDR_OFFSET0   no description available
//  0x008 32  ADDR_OFFSET1   no description available
//  0x00C 32  AES_KEY0_W0    no description available
//  0x010 32  AES_KEY0_W1    no description available
//  0x014 32  AES_KEY0_W2    no description available
//  0x018 32  AES_KEY0_W3    no description available
//  0x01C 32  STATUS         no description available
//  0x020 32  CTR_NONCE0_W0  no description available
//  0x024 32  CTR_NONCE0_W1  no description available
//  0x028 32  CTR_NONCE0_W2  no description available
//  0x02C 32  CTR_NONCE0_W3  no description available
//  0x030 32  CTR_NONCE1_W0  no description available
//  0x034 32  CTR_NONCE1_W1  no description available
//  0x038 32  CTR_NONCE1_W2  no description available
//  0x03C 32  CTR_NONCE1_W3  no description available
//  0x040 32  REGION1_TOP    no description available
//  0x044 32  REGION1_BOT    no description available
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package bee

const (
	BEE_ENABLE             CTRL = 0x01 << 0  //+ BEE enable bit
	BEE_ENABLE_0           CTRL = 0x00 << 0  //  Disable BEE
	BEE_ENABLE_1           CTRL = 0x01 << 0  //  Enable BEE
	CTRL_CLK_EN            CTRL = 0x01 << 1  //+ Clock enable input, low inactive
	CTRL_SFTRST_N          CTRL = 0x01 << 2  //+ Soft reset input, low active
	KEY_VALID              CTRL = 0x01 << 4  //+ AES-128 key is ready
	KEY_REGION_SEL         CTRL = 0x01 << 5  //+ AES key region select
	KEY_REGION_SEL_0       CTRL = 0x00 << 5  //  Load AES key for region0
	KEY_REGION_SEL_1       CTRL = 0x01 << 5  //  Load AES key for region1
	AC_PROT_EN             CTRL = 0x01 << 6  //+ Enable access permission control When AC_PROT_EN is asserted, all encrypted regions are limited to be ARM core access only
	LITTLE_ENDIAN          CTRL = 0x01 << 7  //+ Endian swap control for the 16 bytes input and output data of AES core.
	LITTLE_ENDIAN_0        CTRL = 0x00 << 7  //  The input and output data of the AES core is swapped as below: {B15,B14,B13,B12,B11,B10,B9,B8, B7,B6,B5,B4,B3,B2,B1,B0} swap to {B0,B1,B2,B3,B4,B5,B6,B7, B8,B9,B10,B11,B12,B13,B14,B15}, where B0~B15 refers to Byte0 to Byte15.
	LITTLE_ENDIAN_1        CTRL = 0x01 << 7  //  The input and output data of AES core is not swapped.
	SECURITY_LEVEL_R0      CTRL = 0x03 << 8  //+ Security level of the allowed access for memory region0
	CTRL_AES_MODE_R0       CTRL = 0x01 << 10 //+ AES mode of region0
	CTRL_AES_MODE_R0_0     CTRL = 0x00 << 10 //  ECB
	CTRL_AES_MODE_R0_1     CTRL = 0x01 << 10 //  CTR
	SECURITY_LEVEL_R1      CTRL = 0x03 << 12 //+ Security level of the allowed access for memory region1
	CTRL_AES_MODE_R1       CTRL = 0x01 << 14 //+ AES mode of region1
	CTRL_AES_MODE_R1_0     CTRL = 0x00 << 14 //  ECB
	CTRL_AES_MODE_R1_1     CTRL = 0x01 << 14 //  CTR
	BEE_ENABLE_LOCK        CTRL = 0x01 << 16 //+ Lock bit for bee_enable
	CTRL_CLK_EN_LOCK       CTRL = 0x01 << 17 //+ Lock bit for ctrl_clk_en
	CTRL_SFTRST_N_LOCK     CTRL = 0x01 << 18 //+ Lock bit for ctrl_sftrst
	REGION1_ADDR_LOCK      CTRL = 0x01 << 19 //+ Lock bit for region1 address boundary
	KEY_VALID_LOCK         CTRL = 0x01 << 20 //+ Lock bit for key_valid
	KEY_REGION_SEL_LOCK    CTRL = 0x01 << 21 //+ Lock bit for key_region_sel
	AC_PROT_EN_LOCK        CTRL = 0x01 << 22 //+ Lock bit for ac_prot
	LITTLE_ENDIAN_LOCK     CTRL = 0x01 << 23 //+ Lock bit for little_endian
	SECURITY_LEVEL_R0_LOCK CTRL = 0x03 << 24 //+ Lock bits for security_level_r0
	CTRL_AES_MODE_R0_LOCK  CTRL = 0x01 << 26 //+ Lock bit for region0 ctrl_aes_mode
	REGION0_KEY_LOCK       CTRL = 0x01 << 27 //+ Lock bit for region0 AES key
	SECURITY_LEVEL_R1_LOCK CTRL = 0x03 << 28 //+ Lock bits for security_level_r1
	CTRL_AES_MODE_R1_LOCK  CTRL = 0x01 << 30 //+ Lock bit for region1 ctrl_aes_mode
	REGION1_KEY_LOCK       CTRL = 0x01 << 31 //+ Lock bit for region1 AES key
)

const (
	BEE_ENABLEn             = 0
	CTRL_CLK_ENn            = 1
	CTRL_SFTRST_Nn          = 2
	KEY_VALIDn              = 4
	KEY_REGION_SELn         = 5
	AC_PROT_ENn             = 6
	LITTLE_ENDIANn          = 7
	SECURITY_LEVEL_R0n      = 8
	CTRL_AES_MODE_R0n       = 10
	SECURITY_LEVEL_R1n      = 12
	CTRL_AES_MODE_R1n       = 14
	BEE_ENABLE_LOCKn        = 16
	CTRL_CLK_EN_LOCKn       = 17
	CTRL_SFTRST_N_LOCKn     = 18
	REGION1_ADDR_LOCKn      = 19
	KEY_VALID_LOCKn         = 20
	KEY_REGION_SEL_LOCKn    = 21
	AC_PROT_EN_LOCKn        = 22
	LITTLE_ENDIAN_LOCKn     = 23
	SECURITY_LEVEL_R0_LOCKn = 24
	CTRL_AES_MODE_R0_LOCKn  = 26
	REGION0_KEY_LOCKn       = 27
	SECURITY_LEVEL_R1_LOCKn = 28
	CTRL_AES_MODE_R1_LOCKn  = 30
	REGION1_KEY_LOCKn       = 31
)

const (
	ADDR_OFFSET0      ADDR_OFFSET0 = 0xFFFF << 0  //+ Signed offset for BEE region 0
	ADDR_OFFSET0_LOCK ADDR_OFFSET0 = 0xFFFF << 16 //+ Lock bits for addr_offset0
)

const (
	ADDR_OFFSET0n      = 0
	ADDR_OFFSET0_LOCKn = 16
)

const (
	ADDR_OFFSET1      ADDR_OFFSET1 = 0xFFFF << 0  //+ Signed offset for BEE region 1
	ADDR_OFFSET1_LOCK ADDR_OFFSET1 = 0xFFFF << 16 //+ Lock bits for addr_offset1
)

const (
	ADDR_OFFSET1n      = 0
	ADDR_OFFSET1_LOCKn = 16
)

const (
	KEY0 AES_KEY0_W0 = 0xFFFFFFFF << 0 //+ AES 128 key from software
)

const (
	KEY0n = 0
)

const (
	KEY1 AES_KEY0_W1 = 0xFFFFFFFF << 0 //+ AES 128 key from software
)

const (
	KEY1n = 0
)

const (
	KEY2 AES_KEY0_W2 = 0xFFFFFFFF << 0 //+ AES 128 key from software
)

const (
	KEY2n = 0
)

const (
	KEY3 AES_KEY0_W3 = 0xFFFFFFFF << 0 //+ AES 128 key from software
)

const (
	KEY3n = 0
)

const (
	IRQ_VEC  STATUS = 0xFF << 0 //+ bit 7: Protected region-3 access violation bit 6: Protected region-2 access violation bit 5: Protected region-1 access violation bit 4: Protected region-0 access violation bit 3: Region-1 read channel security violation bit 2: Read channel illegal access detected bit 1: Region-0 read channel security violation bit 0: Disable abort
	BEE_IDLE STATUS = 0x01 << 8 //+ 1'b1: BEE is idle; 1'b0: BEE is active
)

const (
	IRQ_VECn  = 0
	BEE_IDLEn = 8
)

const (
	NONCE00 CTR_NONCE0_W0 = 0xFFFFFFFF << 0 //+ Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
)

const (
	NONCE00n = 0
)

const (
	NONCE01 CTR_NONCE0_W1 = 0xFFFFFFFF << 0 //+ Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
)

const (
	NONCE01n = 0
)

const (
	NONCE02 CTR_NONCE0_W2 = 0xFFFFFFFF << 0 //+ Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
)

const (
	NONCE02n = 0
)

const (
	NONCE03 CTR_NONCE0_W3 = 0xFFFFFFFF << 0 //+ Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
)

const (
	NONCE03n = 0
)

const (
	NONCE10 CTR_NONCE1_W0 = 0xFFFFFFFF << 0 //+ Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
)

const (
	NONCE10n = 0
)

const (
	NONCE11 CTR_NONCE1_W1 = 0xFFFFFFFF << 0 //+ Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
)

const (
	NONCE11n = 0
)

const (
	NONCE12 CTR_NONCE1_W2 = 0xFFFFFFFF << 0 //+ Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
)

const (
	NONCE12n = 0
)

const (
	NONCE13 CTR_NONCE1_W3 = 0xFFFFFFFF << 0 //+ Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
)

const (
	NONCE13n = 0
)

const (
	REGION1_TOP REGION1_TOP = 0xFFFFFFFF << 0 //+ Address upper limit of region1
)

const (
	REGION1_TOPn = 0
)

const (
	REGION1_BOT REGION1_BOT = 0xFFFFFFFF << 0 //+ Address lower limit of region1
)

const (
	REGION1_BOTn = 0
)
