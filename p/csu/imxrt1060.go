// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package csu provides access to the registers of the CSU peripheral.
//
// Instances:
//  CSU  CSU_BASE  -  CSU*  CSU registers
// Registers:
//  0x000 32  CSL[32]     Config security level register
//  0x200 32  HP0         HP0 register
//  0x218 32  SA          Secure access register
//  0x358 32  HPCONTROL0  HPCONTROL0 register
// Import:
//  github.com/embeddedgo/imxrt/p/mmap
package csu

const (
	SUR_S2    CSL = 0x01 << 0  //+ Secure user read access control for the second slave
	SUR_S2_0  CSL = 0x00 << 0  //  The secure user read access is disabled for the second slave.
	SUR_S2_1  CSL = 0x01 << 0  //  The secure user read access is enabled for the second slave.
	SSR_S2    CSL = 0x01 << 1  //+ Secure supervisor read access control for the second slave
	SSR_S2_0  CSL = 0x00 << 1  //  The secure supervisor read access is disabled for the second slave.
	SSR_S2_1  CSL = 0x01 << 1  //  The secure supervisor read access is enabled for the second slave.
	NUR_S2    CSL = 0x01 << 2  //+ Non-secure user read access control for the second slave
	NUR_S2_0  CSL = 0x00 << 2  //  The non-secure user read access is disabled for the second slave.
	NUR_S2_1  CSL = 0x01 << 2  //  The non-secure user read access is enabled for the second slave.
	NSR_S2    CSL = 0x01 << 3  //+ Non-secure supervisor read access control for the second slave
	NSR_S2_0  CSL = 0x00 << 3  //  The non-secure supervisor read access is disabled for the second slave.
	NSR_S2_1  CSL = 0x01 << 3  //  The non-secure supervisor read access is enabled for the second slave.
	SUW_S2    CSL = 0x01 << 4  //+ Secure user write access control for the second slave
	SUW_S2_0  CSL = 0x00 << 4  //  The secure user write access is disabled for the second slave.
	SUW_S2_1  CSL = 0x01 << 4  //  The secure user write access is enabled for the second slave.
	SSW_S2    CSL = 0x01 << 5  //+ Secure supervisor write access control for the second slave
	SSW_S2_0  CSL = 0x00 << 5  //  The secure supervisor write access is disabled for the second slave.
	SSW_S2_1  CSL = 0x01 << 5  //  The secure supervisor write access is enabled for the second slave.
	NUW_S2    CSL = 0x01 << 6  //+ Non-secure user write access control for the second slave
	NUW_S2_0  CSL = 0x00 << 6  //  The non-secure user write access is disabled for the second slave.
	NUW_S2_1  CSL = 0x01 << 6  //  The non-secure user write access is enabled for the second slave.
	NSW_S2    CSL = 0x01 << 7  //+ Non-secure supervisor write access control for the second slave
	NSW_S2_0  CSL = 0x00 << 7  //  The non-secure supervisor write access is disabled for the second slave.
	NSW_S2_1  CSL = 0x01 << 7  //  The non-secure supervisor write access is enabled for the second slave.
	LOCK_S2   CSL = 0x01 << 8  //+ The lock bit corresponding to the second slave. It is written by the secure software.
	LOCK_S2_0 CSL = 0x00 << 8  //  Not locked. Bits 7-0 can be written by the software.
	LOCK_S2_1 CSL = 0x01 << 8  //  Bits 7-0 are locked and cannot be written by the software
	SUR_S1    CSL = 0x01 << 16 //+ Secure user read access control for the first slave
	SUR_S1_0  CSL = 0x00 << 16 //  The secure user read access is disabled for the first slave.
	SUR_S1_1  CSL = 0x01 << 16 //  The secure user read access is enabled for the first slave.
	SSR_S1    CSL = 0x01 << 17 //+ Secure supervisor read access control for the first slave
	SSR_S1_0  CSL = 0x00 << 17 //  The secure supervisor read access is disabled for the first slave.
	SSR_S1_1  CSL = 0x01 << 17 //  The secure supervisor read access is enabled for the first slave.
	NUR_S1    CSL = 0x01 << 18 //+ Non-secure user read access control for the first slave
	NUR_S1_0  CSL = 0x00 << 18 //  The non-secure user read access is disabled for the first slave.
	NUR_S1_1  CSL = 0x01 << 18 //  The non-secure user read access is enabled for the first slave.
	NSR_S1    CSL = 0x01 << 19 //+ Non-secure supervisor read access control for the first slave
	NSR_S1_0  CSL = 0x00 << 19 //  The non-secure supervisor read access is disabled for the first slave.
	NSR_S1_1  CSL = 0x01 << 19 //  The non-secure supervisor read access is enabled for the first slave.
	SUW_S1    CSL = 0x01 << 20 //+ Secure user write access control for the first slave
	SUW_S1_0  CSL = 0x00 << 20 //  The secure user write access is disabled for the first slave.
	SUW_S1_1  CSL = 0x01 << 20 //  The secure user write access is enabled for the first slave.
	SSW_S1    CSL = 0x01 << 21 //+ Secure supervisor write access control for the first slave
	SSW_S1_0  CSL = 0x00 << 21 //  The secure supervisor write access is disabled for the first slave.
	SSW_S1_1  CSL = 0x01 << 21 //  The secure supervisor write access is enabled for the first slave.
	NUW_S1    CSL = 0x01 << 22 //+ Non-secure user write access control for the first slave
	NUW_S1_0  CSL = 0x00 << 22 //  The non-secure user write access is disabled for the first slave.
	NUW_S1_1  CSL = 0x01 << 22 //  The non-secure user write access is enabled for the first slave.
	NSW_S1    CSL = 0x01 << 23 //+ Non-secure supervisor write access control for the first slave
	NSW_S1_0  CSL = 0x00 << 23 //  The non-secure supervisor write access is disabled for the first slave.
	NSW_S1_1  CSL = 0x01 << 23 //  The non-secure supervisor write access is enabled for the first slave
	LOCK_S1   CSL = 0x01 << 24 //+ The lock bit corresponding to the first slave. It is written by the secure software.
	LOCK_S1_0 CSL = 0x00 << 24 //  Not locked. The bits 16-23 can be written by the software.
	LOCK_S1_1 CSL = 0x01 << 24 //  The bits 16-23 are locked and can't be written by the software.
)

const (
	SUR_S2n  = 0
	SSR_S2n  = 1
	NUR_S2n  = 2
	NSR_S2n  = 3
	SUW_S2n  = 4
	SSW_S2n  = 5
	NUW_S2n  = 6
	NSW_S2n  = 7
	LOCK_S2n = 8
	SUR_S1n  = 16
	SSR_S1n  = 17
	NUR_S1n  = 18
	NSR_S1n  = 19
	SUW_S1n  = 20
	SSW_S1n  = 21
	NUW_S1n  = 22
	NSW_S1n  = 23
	LOCK_S1n = 24
)

const (
	HP_DMA      HP0 = 0x01 << 2  //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the eDMA
	HP_DMA_0    HP0 = 0x00 << 2  //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_DMA_1    HP0 = 0x01 << 2  //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_DMA       HP0 = 0x01 << 3  //+ Lock bit set by the TZ software for the eDMA
	L_DMA_0     HP0 = 0x00 << 3  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DMA_1     HP0 = 0x01 << 3  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_LCDIF    HP0 = 0x01 << 4  //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the LCDIF
	HP_LCDIF_0  HP0 = 0x00 << 4  //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_LCDIF_1  HP0 = 0x01 << 4  //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_LCDIF     HP0 = 0x01 << 5  //+ Lock bit set by the TZ software for the LCDIF
	L_LCDIF_0   HP0 = 0x00 << 5  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_LCDIF_1   HP0 = 0x01 << 5  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_CSI      HP0 = 0x01 << 6  //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the CSI
	HP_CSI_0    HP0 = 0x00 << 6  //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_CSI_1    HP0 = 0x01 << 6  //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_CSI       HP0 = 0x01 << 7  //+ Lock bit set by the TZ software for the CSI
	L_CSI_0     HP0 = 0x00 << 7  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_CSI_1     HP0 = 0x01 << 7  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_PXP      HP0 = 0x01 << 8  //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the PXP
	HP_PXP_0    HP0 = 0x00 << 8  //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_PXP_1    HP0 = 0x01 << 8  //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_PXP       HP0 = 0x01 << 9  //+ Lock bit set by the TZ software for the PXP
	L_PXP_0     HP0 = 0x00 << 9  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_PXP_1     HP0 = 0x01 << 9  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_DCP      HP0 = 0x01 << 10 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the DCP
	HP_DCP_0    HP0 = 0x00 << 10 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_DCP_1    HP0 = 0x01 << 10 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_DCP       HP0 = 0x01 << 11 //+ Lock bit set by the TZ software for the DCP
	L_DCP_0     HP0 = 0x00 << 11 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DCP_1     HP0 = 0x01 << 11 //  Lock-the adjacent (next lower) bit cannot be written by the software.
	HP_ENET     HP0 = 0x01 << 14 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the ENET
	HP_ENET_0   HP0 = 0x00 << 14 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_ENET_1   HP0 = 0x01 << 14 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_ENET      HP0 = 0x01 << 15 //+ Lock bit set by the TZ software for the ENET
	L_ENET_0    HP0 = 0x00 << 15 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_ENET_1    HP0 = 0x01 << 15 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_USDHC1   HP0 = 0x01 << 16 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC1
	HP_USDHC1_0 HP0 = 0x00 << 16 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_USDHC1_1 HP0 = 0x01 << 16 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_USDHC1    HP0 = 0x01 << 17 //+ Lock bit set by the TZ software for the USDHC1
	L_USDHC1_0  HP0 = 0x00 << 17 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC1_1  HP0 = 0x01 << 17 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_USDHC2   HP0 = 0x01 << 18 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC2
	HP_USDHC2_0 HP0 = 0x00 << 18 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_USDHC2_1 HP0 = 0x01 << 18 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_USDHC2    HP0 = 0x01 << 19 //+ Lock bit set by the TZ software for the USDHC2
	L_USDHC2_0  HP0 = 0x00 << 19 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC2_1  HP0 = 0x01 << 19 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_TPSMP    HP0 = 0x01 << 20 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the TPSMP
	HP_TPSMP_0  HP0 = 0x00 << 20 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_TPSMP_1  HP0 = 0x01 << 20 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_TPSMP     HP0 = 0x01 << 21 //+ Lock bit set by the TZ software for the TPSMP
	L_TPSMP_0   HP0 = 0x00 << 21 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_TPSMP_1   HP0 = 0x01 << 21 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HP_USB      HP0 = 0x01 << 22 //+ Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USB
	HP_USB_0    HP0 = 0x00 << 22 //  The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	HP_USB_1    HP0 = 0x01 << 22 //  The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	L_USB       HP0 = 0x01 << 23 //+ Lock bit set by the TZ software for the USB
	L_USB_0     HP0 = 0x00 << 23 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USB_1     HP0 = 0x01 << 23 //  Lock-the adjacent (next lower) bit can't be written by the software.
)

const (
	HP_DMAn    = 2
	L_DMAn     = 3
	HP_LCDIFn  = 4
	L_LCDIFn   = 5
	HP_CSIn    = 6
	L_CSIn     = 7
	HP_PXPn    = 8
	L_PXPn     = 9
	HP_DCPn    = 10
	L_DCPn     = 11
	HP_ENETn   = 14
	L_ENETn    = 15
	HP_USDHC1n = 16
	L_USDHC1n  = 17
	HP_USDHC2n = 18
	L_USDHC2n  = 19
	HP_TPSMPn  = 20
	L_TPSMPn   = 21
	HP_USBn    = 22
	L_USBn     = 23
)

const (
	NSA_DMA      SA = 0x01 << 2  //+ Non-secure access policy indicator bit
	NSA_DMA_0    SA = 0x00 << 2  //  Secure access for the corresponding type-1 master
	NSA_DMA_1    SA = 0x01 << 2  //  Non-secure access for the corresponding type-1 master
	L_DMA        SA = 0x01 << 3  //+ Lock bit set by the TZ software for the eDMA
	L_DMA_0      SA = 0x00 << 3  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DMA_1      SA = 0x01 << 3  //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_LCDIF    SA = 0x01 << 4  //+ Non-secure access policy indicator bit
	NSA_LCDIF_0  SA = 0x00 << 4  //  Secure access for the corresponding type-1 master
	NSA_LCDIF_1  SA = 0x01 << 4  //  Non-secure access for the corresponding type-1 master
	L_LCDIF      SA = 0x01 << 5  //+ Lock bit set by the TZ software for the LCDIF
	L_LCDIF_0    SA = 0x00 << 5  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_LCDIF_1    SA = 0x01 << 5  //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_CSI      SA = 0x01 << 6  //+ Non-secure access policy indicator bit
	NSA_CSI_0    SA = 0x00 << 6  //  Secure access for the corresponding type-1 master
	NSA_CSI_1    SA = 0x01 << 6  //  Non-secure access for the corresponding type-1 master
	L_CSI        SA = 0x01 << 7  //+ Lock bit set by the TZ software for the CSI
	L_CSI_0      SA = 0x00 << 7  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_CSI_1      SA = 0x01 << 7  //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_PXP      SA = 0x01 << 8  //+ Non-Secure Access Policy indicator bit
	NSA_PXP_0    SA = 0x00 << 8  //  Secure access for the corresponding type-1 master
	NSA_PXP_1    SA = 0x01 << 8  //  Non-secure access for the corresponding type-1 master
	L_PXP        SA = 0x01 << 9  //+ Lock bit set by the TZ software for the PXP
	L_PXP_0      SA = 0x00 << 9  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_PXP_1      SA = 0x01 << 9  //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_DCP      SA = 0x01 << 10 //+ Non-secure access policy indicator bit
	NSA_DCP_0    SA = 0x00 << 10 //  Secure access for the corresponding type-1 master
	NSA_DCP_1    SA = 0x01 << 10 //  Non-secure access for the corresponding type-1 master
	L_DCP        SA = 0x01 << 11 //+ Lock bit set by the TZ software for the DCP
	L_DCP_0      SA = 0x00 << 11 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DCP_1      SA = 0x01 << 11 //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_ENET     SA = 0x01 << 14 //+ Non-secure access policy indicator bit
	NSA_ENET_0   SA = 0x00 << 14 //  Secure access for the corresponding type-1 master
	NSA_ENET_1   SA = 0x01 << 14 //  Non-secure access for the corresponding type-1 master
	L_ENET       SA = 0x01 << 15 //+ Lock bit set by the TZ software for the ENET1 and ENET2
	L_ENET_0     SA = 0x00 << 15 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_ENET_1     SA = 0x01 << 15 //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_USDHC1   SA = 0x01 << 16 //+ Non-secure access policy indicator bit
	NSA_USDHC1_0 SA = 0x00 << 16 //  Secure access for the corresponding type-1 master
	NSA_USDHC1_1 SA = 0x01 << 16 //  Non-secure access for the corresponding type-1 master
	L_USDHC1     SA = 0x01 << 17 //+ Lock bit set by the TZ software for the USDHC1
	L_USDHC1_0   SA = 0x00 << 17 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC1_1   SA = 0x01 << 17 //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_USDHC2   SA = 0x01 << 18 //+ Non-secure access policy indicator bit
	NSA_USDHC2_0 SA = 0x00 << 18 //  Secure access for the corresponding type-1 master
	NSA_USDHC2_1 SA = 0x01 << 18 //  Non-secure access for the corresponding type-1 master
	L_USDHC2     SA = 0x01 << 19 //+ Lock bit set by the TZ software for the USDHC2
	L_USDHC2_0   SA = 0x00 << 19 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC2_1   SA = 0x01 << 19 //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_TPSMP    SA = 0x01 << 20 //+ Non-secure access policy indicator bit
	NSA_TPSMP_0  SA = 0x00 << 20 //  Secure access for the corresponding type-1 master
	NSA_TPSMP_1  SA = 0x01 << 20 //  Non-secure access for the corresponding type-1 master
	L_TPSMP      SA = 0x01 << 21 //+ Lock bit set by the TZ software for the TPSMP
	L_TPSMP_0    SA = 0x00 << 21 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_TPSMP_1    SA = 0x01 << 21 //  Lock-the adjacent (next lower) bit can't be written by the software.
	NSA_USB      SA = 0x01 << 22 //+ Non-secure access policy indicator bit
	NSA_USB_0    SA = 0x00 << 22 //  Secure access for the corresponding type-1 master
	NSA_USB_1    SA = 0x01 << 22 //  Non-secure access for the corresponding type-1 master
	L_USB        SA = 0x01 << 23 //+ Lock bit set by the TZ software for the USB
	L_USB_0      SA = 0x00 << 23 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USB_1      SA = 0x01 << 23 //  Lock-the adjacent (next lower) bit can't be written by the software.
)

const (
	NSA_DMAn    = 2
	L_DMAn      = 3
	NSA_LCDIFn  = 4
	L_LCDIFn    = 5
	NSA_CSIn    = 6
	L_CSIn      = 7
	NSA_PXPn    = 8
	L_PXPn      = 9
	NSA_DCPn    = 10
	L_DCPn      = 11
	NSA_ENETn   = 14
	L_ENETn     = 15
	NSA_USDHC1n = 16
	L_USDHC1n   = 17
	NSA_USDHC2n = 18
	L_USDHC2n   = 19
	NSA_TPSMPn  = 20
	L_TPSMPn    = 21
	NSA_USBn    = 22
	L_USBn      = 23
)

const (
	HPC_DMA      HPCONTROL0 = 0x01 << 2  //+ Indicates the privilege/user mode for the eDMA
	HPC_DMA_0    HPCONTROL0 = 0x00 << 2  //  User mode for the corresponding master
	HPC_DMA_1    HPCONTROL0 = 0x01 << 2  //  Supervisor mode for the corresponding master
	L_DMA        HPCONTROL0 = 0x01 << 3  //+ Lock bit set by the TZ software for the eDMA
	L_DMA_0      HPCONTROL0 = 0x00 << 3  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DMA_1      HPCONTROL0 = 0x01 << 3  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_LCDIF    HPCONTROL0 = 0x01 << 4  //+ Indicates the privilege/user mode for the LCDIF
	HPC_LCDIF_0  HPCONTROL0 = 0x00 << 4  //  User mode for the corresponding master
	HPC_LCDIF_1  HPCONTROL0 = 0x01 << 4  //  Supervisor mode for the corresponding master
	L_LCDIF      HPCONTROL0 = 0x01 << 5  //+ Lock bit set by the TZ software for the LCDIF
	L_LCDIF_0    HPCONTROL0 = 0x00 << 5  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_LCDIF_1    HPCONTROL0 = 0x01 << 5  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_CSI      HPCONTROL0 = 0x01 << 6  //+ Indicates the privilege/user mode for the CSI
	HPC_CSI_0    HPCONTROL0 = 0x00 << 6  //  User mode for the corresponding master
	HPC_CSI_1    HPCONTROL0 = 0x01 << 6  //  Supervisor mode for the corresponding master
	L_CSI        HPCONTROL0 = 0x01 << 7  //+ Lock bit set by the TZ software for the CSI
	L_CSI_0      HPCONTROL0 = 0x00 << 7  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_CSI_1      HPCONTROL0 = 0x01 << 7  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_PXP      HPCONTROL0 = 0x01 << 8  //+ Indicates the privilege/user mode for the PXP
	HPC_PXP_0    HPCONTROL0 = 0x00 << 8  //  User mode for the corresponding master
	HPC_PXP_1    HPCONTROL0 = 0x01 << 8  //  Supervisor mode for the corresponding master
	L_PXP        HPCONTROL0 = 0x01 << 9  //+ Lock bit set by the TZ software for the PXP
	L_PXP_0      HPCONTROL0 = 0x00 << 9  //  No lock-the adjacent (next lower) bit can be written by the software.
	L_PXP_1      HPCONTROL0 = 0x01 << 9  //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_DCP      HPCONTROL0 = 0x01 << 10 //+ Indicates the privilege/user mode for the DCP
	HPC_DCP_0    HPCONTROL0 = 0x00 << 10 //  User mode for the corresponding master
	HPC_DCP_1    HPCONTROL0 = 0x01 << 10 //  Supervisor mode for the corresponding master
	L_DCP        HPCONTROL0 = 0x01 << 11 //+ Lock bit set by the TZ software for the DCP
	L_DCP_0      HPCONTROL0 = 0x00 << 11 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_DCP_1      HPCONTROL0 = 0x01 << 11 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_ENET     HPCONTROL0 = 0x01 << 14 //+ Indicates the privilege/user mode for the ENET
	HPC_ENET_0   HPCONTROL0 = 0x00 << 14 //  User mode for the corresponding master
	HPC_ENET_1   HPCONTROL0 = 0x01 << 14 //  Supervisor mode for the corresponding master
	L_ENET       HPCONTROL0 = 0x01 << 15 //+ Lock bit set by the TZ software for the ENET
	L_ENET_0     HPCONTROL0 = 0x00 << 15 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_ENET_1     HPCONTROL0 = 0x01 << 15 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_USDHC1   HPCONTROL0 = 0x01 << 16 //+ Indicates the privilege/user mode for the USDHC1
	HPC_USDHC1_0 HPCONTROL0 = 0x00 << 16 //  User mode for the corresponding master
	HPC_USDHC1_1 HPCONTROL0 = 0x01 << 16 //  Supervisor mode for the corresponding master
	L_USDHC1     HPCONTROL0 = 0x01 << 17 //+ Lock bit set by the TZ software for the USDHC1
	L_USDHC1_0   HPCONTROL0 = 0x00 << 17 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC1_1   HPCONTROL0 = 0x01 << 17 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_USDHC2   HPCONTROL0 = 0x01 << 18 //+ Indicates the privilege/user mode for the USDHC2
	HPC_USDHC2_0 HPCONTROL0 = 0x00 << 18 //  User mode for the corresponding master
	HPC_USDHC2_1 HPCONTROL0 = 0x01 << 18 //  Supervisor mode for the corresponding master
	L_USDHC2     HPCONTROL0 = 0x01 << 19 //+ Lock bit set by the TZ software for the USDHC2.
	L_USDHC2_0   HPCONTROL0 = 0x00 << 19 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USDHC2_1   HPCONTROL0 = 0x01 << 19 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_TPSMP    HPCONTROL0 = 0x01 << 20 //+ Indicates the privilege/user mode for the TPSMP
	HPC_TPSMP_0  HPCONTROL0 = 0x00 << 20 //  User mode for the corresponding master
	HPC_TPSMP_1  HPCONTROL0 = 0x01 << 20 //  Supervisor mode for the corresponding master
	L_TPSMP      HPCONTROL0 = 0x01 << 21 //+ Lock bit set by the TZ software for the TPSMP.
	L_TPSMP_0    HPCONTROL0 = 0x00 << 21 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_TPSMP_1    HPCONTROL0 = 0x01 << 21 //  Lock-the adjacent (next lower) bit can't be written by the software.
	HPC_USB      HPCONTROL0 = 0x01 << 22 //+ Indicates the privilege/user mode for the USB
	HPC_USB_0    HPCONTROL0 = 0x00 << 22 //  User mode for the corresponding master
	HPC_USB_1    HPCONTROL0 = 0x01 << 22 //  Supervisor mode for the corresponding master
	L_USB        HPCONTROL0 = 0x01 << 23 //+ Lock bit set by the TZ software for the USB.
	L_USB_0      HPCONTROL0 = 0x00 << 23 //  No lock-the adjacent (next lower) bit can be written by the software.
	L_USB_1      HPCONTROL0 = 0x01 << 23 //  Lock-the adjacent (next lower) bit can't be written by the software.
)

const (
	HPC_DMAn    = 2
	L_DMAn      = 3
	HPC_LCDIFn  = 4
	L_LCDIFn    = 5
	HPC_CSIn    = 6
	L_CSIn      = 7
	HPC_PXPn    = 8
	L_PXPn      = 9
	HPC_DCPn    = 10
	L_DCPn      = 11
	HPC_ENETn   = 14
	L_ENETn     = 15
	HPC_USDHC1n = 16
	L_USDHC1n   = 17
	HPC_USDHC2n = 18
	L_USDHC2n   = 19
	HPC_TPSMPn  = 20
	L_TPSMPn    = 21
	HPC_USBn    = 22
	L_USBn      = 23
)
