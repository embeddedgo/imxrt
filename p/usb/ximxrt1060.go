// Code generated by xgen -g; DO NOT EDIT.

//go:build imxrt1060

package usb

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/imxrt/p/mmap"
)

type Periph struct {
	ID                  mmio.R32[uint32]
	HWGENERAL           mmio.R32[HWGENERAL]
	HWHOST              mmio.R32[HWHOST]
	HWDEVICE            mmio.R32[HWDEVICE]
	HWTXBUF             mmio.R32[HWTXBUF]
	HWRXBUF             mmio.R32[HWRXBUF]
	_                   [26]uint32
	GPTIMER             [2]SGPTIMER
	SBUSCFG             mmio.R32[SBUSCFG]
	_                   [27]uint32
	CAPLENGTH           mmio.R8[uint8]
	_                   uint8
	HCIVERSION          mmio.R16[uint16]
	HCSPARAMS           mmio.R32[HCSPARAMS]
	HCCPARAMS           mmio.R32[HCCPARAMS]
	_                   [5]uint32
	DCIVERSION          mmio.R16[uint16]
	_                   uint16
	DCCPARAMS           mmio.R32[DCCPARAMS]
	_                   [6]uint32
	USBCMD              mmio.R32[USBCMD]
	USBSTS              mmio.R32[USBSTS]
	USBINTR             mmio.R32[USBINTR]
	FRINDEX             mmio.R32[uint32]
	_                   uint32
	DEVADDR_PLISTBASE   mmio.R32[uint32]
	ASYNC_ENDPTLISTADDR mmio.R32[uint32]
	_                   uint32
	BURSTSIZE           mmio.R32[BURSTSIZE]
	TXFILLTUNING        mmio.R32[TXFILLTUNING]
	_                   [4]uint32
	ENDPTNAK            mmio.R32[uint32]
	ENDPTNAKEN          mmio.R32[uint32]
	CONFIGFLAG          mmio.R32[CONFIGFLAG]
	PORTSC1             mmio.R32[PORTSC1]
	_                   [7]uint32
	OTGSC               mmio.R32[OTGSC]
	USBMODE             mmio.R32[USBMODE]
	ENDPTSETUPSTAT      mmio.R32[uint32]
	ENDPTPRIME          mmio.R32[uint32]
	ENDPTFLUSH          mmio.R32[uint32]
	ENDPTSTAT           mmio.R32[uint32]
	ENDPTCOMPLETE       mmio.R32[uint32]
	ENDPTCTRL           [8]mmio.R32[ENDPTCTRL]
}

func USB1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USB1_BASE))) }
func USB2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.USB2_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type HWGENERAL uint32

func PHYW_(p *Periph) mmio.RM32[HWGENERAL] { return mmio.RM32[HWGENERAL]{R: &p.HWGENERAL, Mask: PHYW} }
func PHYM_(p *Periph) mmio.RM32[HWGENERAL] { return mmio.RM32[HWGENERAL]{R: &p.HWGENERAL, Mask: PHYM} }
func SM_(p *Periph) mmio.RM32[HWGENERAL]   { return mmio.RM32[HWGENERAL]{R: &p.HWGENERAL, Mask: SM} }

type HWHOST uint32

func HC_(p *Periph) mmio.RM32[HWHOST]    { return mmio.RM32[HWHOST]{R: &p.HWHOST, Mask: HC} }
func NPORT_(p *Periph) mmio.RM32[HWHOST] { return mmio.RM32[HWHOST]{R: &p.HWHOST, Mask: NPORT} }

type HWDEVICE uint32

func DC_(p *Periph) mmio.RM32[HWDEVICE]    { return mmio.RM32[HWDEVICE]{R: &p.HWDEVICE, Mask: DC} }
func DEVEP_(p *Periph) mmio.RM32[HWDEVICE] { return mmio.RM32[HWDEVICE]{R: &p.HWDEVICE, Mask: DEVEP} }

type HWTXBUF uint32

func TXBURST_(p *Periph) mmio.RM32[HWTXBUF] { return mmio.RM32[HWTXBUF]{R: &p.HWTXBUF, Mask: TXBURST} }
func TXCHANADD_(p *Periph) mmio.RM32[HWTXBUF] {
	return mmio.RM32[HWTXBUF]{R: &p.HWTXBUF, Mask: TXCHANADD}
}

type HWRXBUF uint32

func RXBURST_(p *Periph) mmio.RM32[HWRXBUF] { return mmio.RM32[HWRXBUF]{R: &p.HWRXBUF, Mask: RXBURST} }
func RXADD_(p *Periph) mmio.RM32[HWRXBUF]   { return mmio.RM32[HWRXBUF]{R: &p.HWRXBUF, Mask: RXADD} }

type SGPTIMER struct {
	LD   mmio.R32[uint32]
	CTRL mmio.R32[GPTCTRL]
}

type GPTCTRL uint32

type SBUSCFG uint32

func AHBBRST_(p *Periph) mmio.RM32[SBUSCFG] { return mmio.RM32[SBUSCFG]{R: &p.SBUSCFG, Mask: AHBBRST} }

type HCSPARAMS uint32

func N_PORTS_(p *Periph) mmio.RM32[HCSPARAMS] {
	return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: N_PORTS}
}
func PPC_(p *Periph) mmio.RM32[HCSPARAMS] { return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: PPC} }
func N_PCC_(p *Periph) mmio.RM32[HCSPARAMS] {
	return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: N_PCC}
}
func N_CC_(p *Periph) mmio.RM32[HCSPARAMS] { return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: N_CC} }
func PI_(p *Periph) mmio.RM32[HCSPARAMS]   { return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: PI} }
func N_PTT_(p *Periph) mmio.RM32[HCSPARAMS] {
	return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: N_PTT}
}
func N_TT_(p *Periph) mmio.RM32[HCSPARAMS] { return mmio.RM32[HCSPARAMS]{R: &p.HCSPARAMS, Mask: N_TT} }

type HCCPARAMS uint32

func HPADC_(p *Periph) mmio.RM32[HCCPARAMS] {
	return mmio.RM32[HCCPARAMS]{R: &p.HCCPARAMS, Mask: HPADC}
}
func HPPFL_(p *Periph) mmio.RM32[HCCPARAMS] {
	return mmio.RM32[HCCPARAMS]{R: &p.HCCPARAMS, Mask: HPPFL}
}
func HPASP_(p *Periph) mmio.RM32[HCCPARAMS] {
	return mmio.RM32[HCCPARAMS]{R: &p.HCCPARAMS, Mask: HPASP}
}
func HPIST_(p *Periph) mmio.RM32[HCCPARAMS] {
	return mmio.RM32[HCCPARAMS]{R: &p.HCCPARAMS, Mask: HPIST}
}
func HPEECP_(p *Periph) mmio.RM32[HCCPARAMS] {
	return mmio.RM32[HCCPARAMS]{R: &p.HCCPARAMS, Mask: HPEECP}
}

type DCCPARAMS uint32

func DPDEN_(p *Periph) mmio.RM32[DCCPARAMS] {
	return mmio.RM32[DCCPARAMS]{R: &p.DCCPARAMS, Mask: DPDEN}
}
func DPDC_(p *Periph) mmio.RM32[DCCPARAMS] { return mmio.RM32[DCCPARAMS]{R: &p.DCCPARAMS, Mask: DPDC} }
func DPHC_(p *Periph) mmio.RM32[DCCPARAMS] { return mmio.RM32[DCCPARAMS]{R: &p.DCCPARAMS, Mask: DPHC} }

type USBCMD uint32

func RS_(p *Periph) mmio.RM32[USBCMD]    { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: RS} }
func RST_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: RST} }
func FS_1_(p *Periph) mmio.RM32[USBCMD]  { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: FS_1} }
func PSE_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: PSE} }
func ASE_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: ASE} }
func IAA_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: IAA} }
func ASP_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: ASP} }
func ASPE_(p *Periph) mmio.RM32[USBCMD]  { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: ASPE} }
func ATDTW_(p *Periph) mmio.RM32[USBCMD] { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: ATDTW} }
func SUTW_(p *Periph) mmio.RM32[USBCMD]  { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: SUTW} }
func FS_2_(p *Periph) mmio.RM32[USBCMD]  { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: FS_2} }
func ITC_(p *Periph) mmio.RM32[USBCMD]   { return mmio.RM32[USBCMD]{R: &p.USBCMD, Mask: ITC} }

type USBSTS uint32

func UI_(p *Periph) mmio.RM32[USBSTS]    { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: UI} }
func UEI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: UEI} }
func PCI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: PCI} }
func FRI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: FRI} }
func SEI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: SEI} }
func AAI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: AAI} }
func URI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: URI} }
func SRI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: SRI} }
func SLI_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: SLI} }
func ULPII_(p *Periph) mmio.RM32[USBSTS] { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: ULPII} }
func HCH_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: HCH} }
func RCL_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: RCL} }
func PS_(p *Periph) mmio.RM32[USBSTS]    { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: PS} }
func AS_(p *Periph) mmio.RM32[USBSTS]    { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: AS} }
func NAKI_(p *Periph) mmio.RM32[USBSTS]  { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: NAKI} }
func TI0_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: TI0} }
func TI1_(p *Periph) mmio.RM32[USBSTS]   { return mmio.RM32[USBSTS]{R: &p.USBSTS, Mask: TI1} }

type USBINTR uint32

func UE_(p *Periph) mmio.RM32[USBINTR]    { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: UE} }
func UEE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: UEE} }
func PCE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: PCE} }
func FRE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: FRE} }
func SEE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: SEE} }
func AAE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: AAE} }
func URE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: URE} }
func SRE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: SRE} }
func SLE_(p *Periph) mmio.RM32[USBINTR]   { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: SLE} }
func ULPIE_(p *Periph) mmio.RM32[USBINTR] { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: ULPIE} }
func NAKE_(p *Periph) mmio.RM32[USBINTR]  { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: NAKE} }
func UAIE_(p *Periph) mmio.RM32[USBINTR]  { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: UAIE} }
func UPIE_(p *Periph) mmio.RM32[USBINTR]  { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: UPIE} }
func TIE0_(p *Periph) mmio.RM32[USBINTR]  { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: TIE0} }
func TIE1_(p *Periph) mmio.RM32[USBINTR]  { return mmio.RM32[USBINTR]{R: &p.USBINTR, Mask: TIE1} }

type BURSTSIZE uint32

func RXPBURST_(p *Periph) mmio.RM32[BURSTSIZE] {
	return mmio.RM32[BURSTSIZE]{R: &p.BURSTSIZE, Mask: RXPBURST}
}
func TXPBURST_(p *Periph) mmio.RM32[BURSTSIZE] {
	return mmio.RM32[BURSTSIZE]{R: &p.BURSTSIZE, Mask: TXPBURST}
}

type TXFILLTUNING uint32

func TXSCHOH_(p *Periph) mmio.RM32[TXFILLTUNING] {
	return mmio.RM32[TXFILLTUNING]{R: &p.TXFILLTUNING, Mask: TXSCHOH}
}
func TXSCHHEALTH_(p *Periph) mmio.RM32[TXFILLTUNING] {
	return mmio.RM32[TXFILLTUNING]{R: &p.TXFILLTUNING, Mask: TXSCHHEALTH}
}
func TXFIFOTHRES_(p *Periph) mmio.RM32[TXFILLTUNING] {
	return mmio.RM32[TXFILLTUNING]{R: &p.TXFILLTUNING, Mask: TXFIFOTHRES}
}

type CONFIGFLAG uint32

func CF_(p *Periph) mmio.RM32[CONFIGFLAG] { return mmio.RM32[CONFIGFLAG]{R: &p.CONFIGFLAG, Mask: CF} }

type PORTSC1 uint32

func CCS_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: CCS} }
func CSC_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: CSC} }
func PE_(p *Periph) mmio.RM32[PORTSC1]    { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PE} }
func PEC_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PEC} }
func OCA_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: OCA} }
func OCC_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: OCC} }
func FPR_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: FPR} }
func SUSP_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: SUSP} }
func PR_(p *Periph) mmio.RM32[PORTSC1]    { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PR} }
func HSP_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: HSP} }
func LS_(p *Periph) mmio.RM32[PORTSC1]    { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: LS} }
func PP_(p *Periph) mmio.RM32[PORTSC1]    { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PP} }
func PO_(p *Periph) mmio.RM32[PORTSC1]    { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PO} }
func PIC_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PIC} }
func PTC_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PTC} }
func WKCN_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: WKCN} }
func WKDC_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: WKDC} }
func WKOC_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: WKOC} }
func PHCD_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PHCD} }
func PFSC_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PFSC} }
func PTS_2_(p *Periph) mmio.RM32[PORTSC1] { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PTS_2} }
func PSPD_(p *Periph) mmio.RM32[PORTSC1]  { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PSPD} }
func PTW_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PTW} }
func STS_(p *Periph) mmio.RM32[PORTSC1]   { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: STS} }
func PTS_1_(p *Periph) mmio.RM32[PORTSC1] { return mmio.RM32[PORTSC1]{R: &p.PORTSC1, Mask: PTS_1} }

type OTGSC uint32

func VD_(p *Periph) mmio.RM32[OTGSC]         { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: VD} }
func VC_(p *Periph) mmio.RM32[OTGSC]         { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: VC} }
func OT_(p *Periph) mmio.RM32[OTGSC]         { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: OT} }
func DP_(p *Periph) mmio.RM32[OTGSC]         { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: DP} }
func IDPU_(p *Periph) mmio.RM32[OTGSC]       { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: IDPU} }
func ID_(p *Periph) mmio.RM32[OTGSC]         { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: ID} }
func AVV_(p *Periph) mmio.RM32[OTGSC]        { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: AVV} }
func ASV_(p *Periph) mmio.RM32[OTGSC]        { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: ASV} }
func BSV_(p *Periph) mmio.RM32[OTGSC]        { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSV} }
func BSE_(p *Periph) mmio.RM32[OTGSC]        { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSE} }
func TOG_1MS_(p *Periph) mmio.RM32[OTGSC]    { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: TOG_1MS} }
func DPS_(p *Periph) mmio.RM32[OTGSC]        { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: DPS} }
func IDIS_(p *Periph) mmio.RM32[OTGSC]       { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: IDIS} }
func AVVIS_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: AVVIS} }
func ASVIS_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: ASVIS} }
func BSVIS_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSVIS} }
func BSEIS_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSEIS} }
func STATUS_1MS_(p *Periph) mmio.RM32[OTGSC] { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: STATUS_1MS} }
func DPIS_(p *Periph) mmio.RM32[OTGSC]       { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: DPIS} }
func IDIE_(p *Periph) mmio.RM32[OTGSC]       { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: IDIE} }
func AVVIE_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: AVVIE} }
func ASVIE_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: ASVIE} }
func BSVIE_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSVIE} }
func BSEIE_(p *Periph) mmio.RM32[OTGSC]      { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: BSEIE} }
func EN_1MS_(p *Periph) mmio.RM32[OTGSC]     { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: EN_1MS} }
func DPIE_(p *Periph) mmio.RM32[OTGSC]       { return mmio.RM32[OTGSC]{R: &p.OTGSC, Mask: DPIE} }

type USBMODE uint32

func CM_(p *Periph) mmio.RM32[USBMODE]   { return mmio.RM32[USBMODE]{R: &p.USBMODE, Mask: CM} }
func ES_(p *Periph) mmio.RM32[USBMODE]   { return mmio.RM32[USBMODE]{R: &p.USBMODE, Mask: ES} }
func SLOM_(p *Periph) mmio.RM32[USBMODE] { return mmio.RM32[USBMODE]{R: &p.USBMODE, Mask: SLOM} }
func SDIS_(p *Periph) mmio.RM32[USBMODE] { return mmio.RM32[USBMODE]{R: &p.USBMODE, Mask: SDIS} }

type ENDPTCTRL uint32

func RXS_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXS}
}
func RXD_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXD}
}
func RXT_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXT}
}
func RXI_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXI}
}
func RXR_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXR}
}
func RXE_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: RXE}
}
func TXS_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXS}
}
func TXD_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXD}
}
func TXT_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXT}
}
func TXI_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXI}
}
func TXR_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXR}
}
func TXE_(p *Periph, i int) mmio.RM32[ENDPTCTRL] {
	return mmio.RM32[ENDPTCTRL]{R: &p.ENDPTCTRL[i], Mask: TXE}
}
