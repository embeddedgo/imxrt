// Code generated by svdxgen; DO NOT EDIT.

//go:build imxrt1060

// Package usb provides access to the registers of the USB peripheral.
//
// Instances:
//
//	USB1  USB1_BASE  -  USB_OTG1*
//	USB2  USB2_BASE  -  USB_OTG2*
//
// Registers:
//
//	0x000 32  ID                            Identification register
//	0x004 32  HWGENERAL                     Hardware General
//	0x008 32  HWHOST                        Host Hardware Parameters
//	0x00C 32  HWDEVICE                      Device Hardware Parameters
//	0x010 32  HWTXBUF                       TX Buffer Hardware Parameters
//	0x014 32  HWRXBUF                       RX Buffer Hardware Parameters
//	0x080 32  GPTIMER{LD,CTRL(GPTCTRL)}[2]  General Purpose Timers
//	0x090 32  SBUSCFG                       System Bus Config
//	0x100  8  CAPLENGTH                     Capability Registers Length
//	0x102 16  HCIVERSION                    Host Controller Interface Version
//	0x104 32  HCSPARAMS                     Host Controller Structural Parameters
//	0x108 32  HCCPARAMS                     Host Controller Capability Parameters
//	0x120 16  DCIVERSION                    Device Controller Interface Version
//	0x124 32  DCCPARAMS                     Device Controller Capability Parameters
//	0x140 32  USBCMD                        USB Command Register
//	0x144 32  USBSTS                        USB Status Register
//	0x148 32  USBINTR                       Interrupt Enable Register
//	0x14C 32  FRINDEX                       USB Frame Index
//	0x154 32  DEVADDR_PLISTBASE             Device Address / Frame List Base Address
//	0x158 32  ASYNC_ENDPTLISTADDR           Next Asynch. Address / Endpoint List Address
//	0x160 32  BURSTSIZE                     Programmable Burst Size
//	0x164 32  TXFILLTUNING                  TX FIFO Fill Tuning
//	0x178 32  ENDPTNAK                      Endpoint NAK
//	0x17C 32  ENDPTNAKEN                    Endpoint NAK Enable
//	0x180 32  CONFIGFLAG                    Configure Flag Register
//	0x184 32  PORTSC1                       Port Status & Control
//	0x1A4 32  OTGSC                         On-The-Go Status & control
//	0x1A8 32  USBMODE                       USB Device Mode
//	0x1AC 32  ENDPTSETUPSTAT                Endpoint Setup Status
//	0x1B0 32  ENDPTPRIME                    Endpoint Prime
//	0x1B4 32  ENDPTFLUSH                    Endpoint Flush
//	0x1B8 32  ENDPTSTAT                     Endpoint Status
//	0x1BC 32  ENDPTCOMPLETE                 Endpoint Complete
//	0x1C0 32  ENDPTCTRL[8]                  Endpoint Control
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package usb

const (
	PHYW   HWGENERAL = 0x03 << 4 //+ Data width of the transciever connected to the controller core. PHYW bit reset value is
	PHYW_0 HWGENERAL = 0x00 << 4 //  8 bit wide data bus Software non-programmable
	PHYW_1 HWGENERAL = 0x01 << 4 //  16 bit wide data bus Software non-programmable
	PHYW_2 HWGENERAL = 0x02 << 4 //  Reset to 8 bit wide data bus Software programmable
	PHYW_3 HWGENERAL = 0x03 << 4 //  Reset to 16 bit wide data bus Software programmable
	PHYM   HWGENERAL = 0x07 << 6 //+ Transciever type
	PHYM_0 HWGENERAL = 0x00 << 6 //  UTMI/UMTI+
	PHYM_1 HWGENERAL = 0x01 << 6 //  ULPI DDR
	PHYM_2 HWGENERAL = 0x02 << 6 //  ULPI
	PHYM_3 HWGENERAL = 0x03 << 6 //  Serial Only
	PHYM_4 HWGENERAL = 0x04 << 6 //  Software programmable - reset to UTMI/UTMI+
	PHYM_5 HWGENERAL = 0x05 << 6 //  Software programmable - reset to ULPI DDR
	PHYM_6 HWGENERAL = 0x06 << 6 //  Software programmable - reset to ULPI
	PHYM_7 HWGENERAL = 0x07 << 6 //  Software programmable - reset to Serial
	SM     HWGENERAL = 0x03 << 9 //+ Serial interface mode capability
	SM_0   HWGENERAL = 0x00 << 9 //  No Serial Engine, always use parallel signalling.
	SM_1   HWGENERAL = 0x01 << 9 //  Serial Engine present, always use serial signalling for FS/LS.
	SM_2   HWGENERAL = 0x02 << 9 //  Software programmable - Reset to use parallel signalling for FS/LS
	SM_3   HWGENERAL = 0x03 << 9 //  Software programmable - Reset to use serial signalling for FS/LS
)

const (
	PHYWn = 4
	PHYMn = 6
	SMn   = 9
)

const (
	HC    HWHOST = 0x01 << 0 //+ Host Capable. Indicating whether host operation mode is supported or not.
	NPORT HWHOST = 0x07 << 1 //+ The Nmber of downstream ports supported by the host controller is (NPORT+1)
)

const (
	HCn    = 0
	NPORTn = 1
)

const (
	DC    HWDEVICE = 0x01 << 0 //+ Device Capable. Indicating whether device operation mode is supported or not.
	DEVEP HWDEVICE = 0x1F << 1 //+ Device Endpoint Number
)

const (
	DCn    = 0
	DEVEPn = 1
)

const (
	TXBURST   HWTXBUF = 0xFF << 0  //+ Default burst size for memory to TX buffer transfer
	TXCHANADD HWTXBUF = 0xFF << 16 //+ TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes
)

const (
	TXBURSTn   = 0
	TXCHANADDn = 16
)

const (
	RXBURST HWRXBUF = 0xFF << 0 //+ Default burst size for memory to RX buffer transfer
	RXADD   HWRXBUF = 0xFF << 8 //+ Buffer total size for all receive endpoints is (2^RXADD)
)

const (
	RXBURSTn = 0
	RXADDn   = 8
)

const (
	GPTCNT  GPTCTRL = 0xFFFFFF << 0 //+ General Purpose Timer Counter. This field is the count value of the countdown timer.
	GPTMODE GPTCTRL = 0x01 << 24    //+ General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again
	GPTRST  GPTCTRL = 0x01 << 30    //+ General Purpose Timer Reset
	GPTRUN  GPTCTRL = 0x01 << 31    //+ General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit.
)

const (
	GPTCNTn  = 0
	GPTMODEn = 24
	GPTRSTn  = 30
	GPTRUNn  = 31
)

const (
	AHBBRST   SBUSCFG = 0x07 << 0 //+ AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)
	AHBBRST_0 SBUSCFG = 0x00 << 0 //  Incremental burst of unspecified length only
	AHBBRST_1 SBUSCFG = 0x01 << 0 //  INCR4 burst, then single transfer
	AHBBRST_2 SBUSCFG = 0x02 << 0 //  INCR8 burst, INCR4 burst, then single transfer
	AHBBRST_3 SBUSCFG = 0x03 << 0 //  INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
	AHBBRST_5 SBUSCFG = 0x05 << 0 //  INCR4 burst, then incremental burst of unspecified length
	AHBBRST_6 SBUSCFG = 0x06 << 0 //  INCR8 burst, INCR4 burst, then incremental burst of unspecified length
	AHBBRST_7 SBUSCFG = 0x07 << 0 //  INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length
)

const (
	AHBBRSTn = 0
)

const (
	N_PORTS HCSPARAMS = 0x0F << 0  //+ Number of downstream ports
	PPC     HCSPARAMS = 0x01 << 4  //+ Port Power Control This field indicates whether the host controller implementation includes port power control
	N_PCC   HCSPARAMS = 0x0F << 8  //+ Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller
	N_CC    HCSPARAMS = 0x0F << 12 //+ Number of Companion Controller (N_CC)
	N_CC_0  HCSPARAMS = 0x00 << 12 //  There is no internal Companion Controller and port-ownership hand-off is not supported.
	N_CC_1  HCSPARAMS = 0x01 << 12 //  There are internal companion controller(s) and port-ownership hand-offs is supported.
	PI      HCSPARAMS = 0x01 << 16 //+ Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control
	N_PTT   HCSPARAMS = 0x0F << 20 //+ Number of Ports per Transaction Translator (N_PTT)
	N_TT    HCSPARAMS = 0x0F << 24 //+ Number of Transaction Translators (N_TT)
)

const (
	N_PORTSn = 0
	PPCn     = 4
	N_PCCn   = 8
	N_CCn    = 12
	PIn      = 16
	N_PTTn   = 20
	N_TTn    = 24
)

const (
	HPADC  HCCPARAMS = 0x01 << 0 //+ 64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported
	HPPFL  HCCPARAMS = 0x01 << 1 //+ Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller
	HPASP  HCCPARAMS = 0x01 << 2 //+ Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule
	HPIST  HCCPARAMS = 0x0F << 4 //+ Isochronous Scheduling Threshold
	HPEECP HCCPARAMS = 0xFF << 8 //+ EHCI Extended Capabilities Pointer
)

const (
	HPADCn  = 0
	HPPFLn  = 1
	HPASPn  = 2
	HPISTn  = 4
	HPEECPn = 8
)

const (
	DPDEN DCCPARAMS = 0x1F << 0 //+ Device Endpoint Number This field indicates the number of endpoints built into the device controller
	DPDC  DCCPARAMS = 0x01 << 7 //+ Device Capable When this bit is 1, this controller is capable of operating as a USB 2.0 device.
	DPHC  DCCPARAMS = 0x01 << 8 //+ Host Capable When this bit is 1, this controller is capable of operating as an EHCI compatible USB 2
)

const (
	DPDENn = 0
	DPDCn  = 7
	DPHCn  = 8
)

const (
	RS     USBCMD = 0x01 << 0  //+ Run/Stop (RS) - Read/Write
	RST    USBCMD = 0x01 << 1  //+ Controller Reset (RESET) - Read/Write
	FS_1   USBCMD = 0x03 << 2  //+ See description at bit 15
	PSE    USBCMD = 0x01 << 4  //+ Periodic Schedule Enable- Read/Write
	ASE    USBCMD = 0x01 << 5  //+ Asynchronous Schedule Enable - Read/Write
	IAA    USBCMD = 0x01 << 6  //+ Interrupt on Async Advance Doorbell - Read/Write
	ASP    USBCMD = 0x03 << 8  //+ Asynchronous Schedule Park Mode Count - Read/Write
	ASPE   USBCMD = 0x01 << 11 //+ Asynchronous Schedule Park Mode Enable - Read/Write
	ATDTW  USBCMD = 0x01 << 14 //+ Add dTD TripWire - Read/Write
	SUTW   USBCMD = 0x01 << 13 //+ Setup TripWire - Read/Write
	FS_2   USBCMD = 0x01 << 15 //+ See also bits 3-2 Frame List Size - (Read/Write or Read Only)
	ITC    USBCMD = 0xFF << 16 //+ Interrupt Threshold Control -Read/Write
	ITC_0  USBCMD = 0x00 << 16 //  Immediate (no threshold)
	ITC_1  USBCMD = 0x01 << 16 //  1 micro-frame
	ITC_2  USBCMD = 0x02 << 16 //  2 micro-frames
	ITC_4  USBCMD = 0x04 << 16 //  4 micro-frames
	ITC_8  USBCMD = 0x08 << 16 //  8 micro-frames
	ITC_16 USBCMD = 0x10 << 16 //  16 micro-frames
	ITC_32 USBCMD = 0x20 << 16 //  32 micro-frames
	ITC_64 USBCMD = 0x40 << 16 //  64 micro-frames
)

const (
	RSn    = 0
	RSTn   = 1
	FS_1n  = 2
	PSEn   = 4
	ASEn   = 5
	IAAn   = 6
	ASPn   = 8
	ASPEn  = 11
	ATDTWn = 14
	SUTWn  = 13
	FS_2n  = 15
	ITCn   = 16
)

const (
	UI    USBSTS = 0x01 << 0  //+ USB Interrupt (USBINT) - R/WC
	UEI   USBSTS = 0x01 << 1  //+ USB Error Interrupt (USBERRINT) - R/WC
	PCI   USBSTS = 0x01 << 2  //+ Port Change Detect - R/WC
	FRI   USBSTS = 0x01 << 3  //+ Frame List Rollover - R/WC
	SEI   USBSTS = 0x01 << 4  //+ System Error- R/WC
	AAI   USBSTS = 0x01 << 5  //+ Interrupt on Async Advance - R/WC
	URI   USBSTS = 0x01 << 6  //+ USB Reset Received - R/WC
	SRI   USBSTS = 0x01 << 7  //+ SOF Received - R/WC
	SLI   USBSTS = 0x01 << 8  //+ DCSuspend - R/WC
	ULPII USBSTS = 0x01 << 10 //+ ULPI Interrupt - R/WC
	HCH   USBSTS = 0x01 << 12 //+ HCHaIted - Read Only
	RCL   USBSTS = 0x01 << 13 //+ Reclamation - Read Only
	PS    USBSTS = 0x01 << 14 //+ Periodic Schedule Status - Read Only
	AS    USBSTS = 0x01 << 15 //+ Asynchronous Schedule Status - Read Only
	NAKI  USBSTS = 0x01 << 16 //+ NAK Interrupt Bit--RO
	TI0   USBSTS = 0x01 << 24 //+ General Purpose Timer Interrupt 0(GPTINT0)--R/WC
	TI1   USBSTS = 0x01 << 25 //+ General Purpose Timer Interrupt 1(GPTINT1)--R/WC
)

const (
	UIn    = 0
	UEIn   = 1
	PCIn   = 2
	FRIn   = 3
	SEIn   = 4
	AAIn   = 5
	URIn   = 6
	SRIn   = 7
	SLIn   = 8
	ULPIIn = 10
	HCHn   = 12
	RCLn   = 13
	PSn    = 14
	ASn    = 15
	NAKIn  = 16
	TI0n   = 24
	TI1n   = 25
)

const (
	UE    USBINTR = 0x01 << 0  //+ USB Interrupt Enable When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt
	UEE   USBINTR = 0x01 << 1  //+ USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt
	PCE   USBINTR = 0x01 << 2  //+ Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt
	FRE   USBINTR = 0x01 << 3  //+ Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt
	SEE   USBINTR = 0x01 << 4  //+ System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt
	AAE   USBINTR = 0x01 << 5  //+ Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt
	URE   USBINTR = 0x01 << 6  //+ USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt
	SRE   USBINTR = 0x01 << 7  //+ SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt
	SLE   USBINTR = 0x01 << 8  //+ Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt
	ULPIE USBINTR = 0x01 << 10 //+ ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt
	NAKE  USBINTR = 0x01 << 16 //+ NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt
	UAIE  USBINTR = 0x01 << 18 //+ USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold
	UPIE  USBINTR = 0x01 << 19 //+ USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold
	TIE0  USBINTR = 0x01 << 24 //+ General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt
	TIE1  USBINTR = 0x01 << 25 //+ General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt
)

const (
	UEn    = 0
	UEEn   = 1
	PCEn   = 2
	FREn   = 3
	SEEn   = 4
	AAEn   = 5
	UREn   = 6
	SREn   = 7
	SLEn   = 8
	ULPIEn = 10
	NAKEn  = 16
	UAIEn  = 18
	UPIEn  = 19
	TIE0n  = 24
	TIE1n  = 25
)

const (
	RXPBURST BURSTSIZE = 0xFF << 0  //+ Programmable RX Burst Size
	TXPBURST BURSTSIZE = 0x1FF << 8 //+ Programmable TX Burst Size
)

const (
	RXPBURSTn = 0
	TXPBURSTn = 8
)

const (
	TXSCHOH     TXFILLTUNING = 0xFF << 0  //+ Scheduler Overhead
	TXSCHHEALTH TXFILLTUNING = 0x1F << 8  //+ Scheduler Health Counter
	TXFIFOTHRES TXFILLTUNING = 0x3F << 16 //+ FIFO Burst Threshold
)

const (
	TXSCHOHn     = 0
	TXSCHHEALTHn = 8
	TXFIFOTHRESn = 16
)

const (
	CF CONFIGFLAG = 0x01 << 0 //+ Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller
)

const (
	CFn = 0
)

const (
	CCS    PORTSC1 = 0x01 << 0  //+ Current Connect Status-Read Only
	CSC    PORTSC1 = 0x01 << 1  //+ Connect Status Change-R/WC
	PE     PORTSC1 = 0x01 << 2  //+ Port Enabled/Disabled-Read/Write
	PEC    PORTSC1 = 0x01 << 3  //+ Port Enable/Disable Change-R/WC
	OCA    PORTSC1 = 0x01 << 4  //+ Over-current Active-Read Only
	OCC    PORTSC1 = 0x01 << 5  //+ Over-current Change-R/WC
	FPR    PORTSC1 = 0x01 << 6  //+ Force Port Resume -Read/Write
	SUSP   PORTSC1 = 0x01 << 7  //+ Suspend - Read/Write or Read Only
	PR     PORTSC1 = 0x01 << 8  //+ Port Reset - Read/Write or Read Only
	HSP    PORTSC1 = 0x01 << 9  //+ High-Speed Port - Read Only
	LS     PORTSC1 = 0x03 << 10 //+ Line Status-Read Only
	LS_0   PORTSC1 = 0x00 << 10 //  SE0
	LS_1   PORTSC1 = 0x01 << 10 //  K-state
	LS_2   PORTSC1 = 0x02 << 10 //  J-state
	LS_3   PORTSC1 = 0x03 << 10 //  Undefined
	PP     PORTSC1 = 0x01 << 12 //+ Port Power (PP)-Read/Write or Read Only
	PO     PORTSC1 = 0x01 << 13 //+ Port Owner-Read/Write
	PIC    PORTSC1 = 0x03 << 14 //+ Port Indicator Control - Read/Write
	PIC_0  PORTSC1 = 0x00 << 14 //  Port indicators are off
	PIC_1  PORTSC1 = 0x01 << 14 //  Amber
	PIC_2  PORTSC1 = 0x02 << 14 //  Green
	PIC_3  PORTSC1 = 0x03 << 14 //  Undefined
	PTC    PORTSC1 = 0x0F << 16 //+ Port Test Control - Read/Write
	PTC_0  PORTSC1 = 0x00 << 16 //  TEST_MODE_DISABLE
	PTC_1  PORTSC1 = 0x01 << 16 //  J_STATE
	PTC_2  PORTSC1 = 0x02 << 16 //  K_STATE
	PTC_3  PORTSC1 = 0x03 << 16 //  SE0 (host) / NAK (device)
	PTC_4  PORTSC1 = 0x04 << 16 //  Packet
	PTC_5  PORTSC1 = 0x05 << 16 //  FORCE_ENABLE_HS
	PTC_6  PORTSC1 = 0x06 << 16 //  FORCE_ENABLE_FS
	PTC_7  PORTSC1 = 0x07 << 16 //  FORCE_ENABLE_LS
	WKCN   PORTSC1 = 0x01 << 20 //+ Wake on Connect Enable (WKCNNT_E) - Read/Write
	WKDC   PORTSC1 = 0x01 << 21 //+ Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write
	WKOC   PORTSC1 = 0x01 << 22 //+ Wake on Over-current Enable (WKOC_E) - Read/Write
	PHCD   PORTSC1 = 0x01 << 23 //+ PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write
	PFSC   PORTSC1 = 0x01 << 24 //+ Port Force Full Speed Connect - Read/Write
	PTS_2  PORTSC1 = 0x01 << 25 //+ See description at bits 31-30
	PSPD   PORTSC1 = 0x03 << 26 //+ Port Speed - Read Only. This register field indicates the speed at which the port is operating.
	PSPD_0 PORTSC1 = 0x00 << 26 //  Full Speed
	PSPD_1 PORTSC1 = 0x01 << 26 //  Low Speed
	PSPD_2 PORTSC1 = 0x02 << 26 //  High Speed
	PSPD_3 PORTSC1 = 0x03 << 26 //  Undefined
	PTW    PORTSC1 = 0x01 << 28 //+ Parallel Transceiver Width This bit has no effect if serial interface engine is used
	STS    PORTSC1 = 0x01 << 29 //+ Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals
	PTS_1  PORTSC1 = 0x03 << 30 //+ All USB port interface modes are listed in this field description, but not all are supported
)

const (
	CCSn   = 0
	CSCn   = 1
	PEn    = 2
	PECn   = 3
	OCAn   = 4
	OCCn   = 5
	FPRn   = 6
	SUSPn  = 7
	PRn    = 8
	HSPn   = 9
	LSn    = 10
	PPn    = 12
	POn    = 13
	PICn   = 14
	PTCn   = 16
	WKCNn  = 20
	WKDCn  = 21
	WKOCn  = 22
	PHCDn  = 23
	PFSCn  = 24
	PTS_2n = 25
	PSPDn  = 26
	PTWn   = 28
	STSn   = 29
	PTS_1n = 30
)

const (
	VD         OTGSC = 0x01 << 0  //+ VBUS_Discharge - Read/Write. Setting this bit causes VBus to discharge through a resistor.
	VC         OTGSC = 0x01 << 1  //+ VBUS Charge - Read/Write
	OT         OTGSC = 0x01 << 3  //+ OTG Termination - Read/Write
	DP         OTGSC = 0x01 << 4  //+ Data Pulsing - Read/Write
	IDPU       OTGSC = 0x01 << 5  //+ ID Pullup - Read/Write This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]
	ID         OTGSC = 0x01 << 8  //+ USB ID - Read Only. 0 = A device, 1 = B device
	AVV        OTGSC = 0x01 << 9  //+ A VBus Valid - Read Only. Indicates VBus is above the A VBus valid threshold.
	ASV        OTGSC = 0x01 << 10 //+ A Session Valid - Read Only. Indicates VBus is above the A session valid threshold.
	BSV        OTGSC = 0x01 << 11 //+ B Session Valid - Read Only. Indicates VBus is above the B session valid threshold.
	BSE        OTGSC = 0x01 << 12 //+ B Session End - Read Only. Indicates VBus is below the B session end threshold.
	TOG_1MS    OTGSC = 0x01 << 13 //+ 1 millisecond timer toggle - Read Only. This bit toggles once per millisecond.
	DPS        OTGSC = 0x01 << 14 //+ Data Bus Pulsing Status - Read Only
	IDIS       OTGSC = 0x01 << 16 //+ USB ID Interrupt Status - Read/Write
	AVVIS      OTGSC = 0x01 << 17 //+ A VBus Valid Interrupt Status - Read/Write to Clear
	ASVIS      OTGSC = 0x01 << 18 //+ A Session Valid Interrupt Status - Read/Write to Clear
	BSVIS      OTGSC = 0x01 << 19 //+ B Session Valid Interrupt Status - Read/Write to Clear
	BSEIS      OTGSC = 0x01 << 20 //+ B Session End Interrupt Status - Read/Write to Clear
	STATUS_1MS OTGSC = 0x01 << 21 //+ 1 millisecond timer Interrupt Status - Read/Write to Clear
	DPIS       OTGSC = 0x01 << 22 //+ Data Pulse Interrupt Status - Read/Write to Clear
	IDIE       OTGSC = 0x01 << 24 //+ USB ID Interrupt Enable - Read/Write. Setting this bit enables the USB ID interrupt.
	AVVIE      OTGSC = 0x01 << 25 //+ A VBus Valid Interrupt Enable - Read/Write. Setting this bit enables the A VBus valid interrupt.
	ASVIE      OTGSC = 0x01 << 26 //+ A Session Valid Interrupt Enable - Read/Write
	BSVIE      OTGSC = 0x01 << 27 //+ B Session Valid Interrupt Enable - Read/Write
	BSEIE      OTGSC = 0x01 << 28 //+ B Session End Interrupt Enable - Read/Write. Setting this bit enables the B session end interrupt.
	EN_1MS     OTGSC = 0x01 << 29 //+ 1 millisecond timer Interrupt Enable - Read/Write
	DPIE       OTGSC = 0x01 << 30 //+ Data Pulse Interrupt Enable
)

const (
	VDn         = 0
	VCn         = 1
	OTn         = 3
	DPn         = 4
	IDPUn       = 5
	IDn         = 8
	AVVn        = 9
	ASVn        = 10
	BSVn        = 11
	BSEn        = 12
	TOG_1MSn    = 13
	DPSn        = 14
	IDISn       = 16
	AVVISn      = 17
	ASVISn      = 18
	BSVISn      = 19
	BSEISn      = 20
	STATUS_1MSn = 21
	DPISn       = 22
	IDIEn       = 24
	AVVIEn      = 25
	ASVIEn      = 26
	BSVIEn      = 27
	BSEIEn      = 28
	EN_1MSn     = 29
	DPIEn       = 30
)

const (
	CM   USBMODE = 0x03 << 0 //+ Controller Mode - R/WO
	CM_0 USBMODE = 0x00 << 0 //  Idle [Default for combination host/device]
	CM_2 USBMODE = 0x02 << 0 //  Device Controller [Default for device only controller]
	CM_3 USBMODE = 0x03 << 0 //  Host Controller [Default for host only controller]
	ES   USBMODE = 0x01 << 2 //+ Endian Select - Read/Write
	SLOM USBMODE = 0x01 << 3 //+ Setup Lockout Mode
	SDIS USBMODE = 0x01 << 4 //+ Stream Disable Mode
)

const (
	CMn   = 0
	ESn   = 2
	SLOMn = 3
	SDISn = 4
)

const (
	RXS ENDPTCTRL = 0x01 << 0  //+ RX Endpoint Stall - Read/Write 0 End Point OK
	RXD ENDPTCTRL = 0x01 << 1  //+ RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
	RXT ENDPTCTRL = 0x03 << 2  //+ RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
	RXI ENDPTCTRL = 0x01 << 5  //+ RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
	RXR ENDPTCTRL = 0x01 << 6  //+ RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
	RXE ENDPTCTRL = 0x01 << 7  //+ RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
	TXS ENDPTCTRL = 0x01 << 16 //+ TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
	TXD ENDPTCTRL = 0x01 << 17 //+ TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
	TXT ENDPTCTRL = 0x03 << 18 //+ TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
	TXI ENDPTCTRL = 0x01 << 21 //+ TX Data Toggle Inhibit 0 PID Sequencing Enabled
	TXR ENDPTCTRL = 0x01 << 22 //+ TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
	TXE ENDPTCTRL = 0x01 << 23 //+ TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
)

const (
	RXSn = 0
	RXDn = 1
	RXTn = 2
	RXIn = 5
	RXRn = 6
	RXEn = 7
	TXSn = 16
	TXDn = 17
	TXTn = 18
	TXIn = 21
	TXRn = 22
	TXEn = 23
)
