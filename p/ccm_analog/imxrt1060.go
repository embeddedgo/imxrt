// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build imxrt1060

// Package ccm_analog provides access to the registers of the CCM_ANALOG peripheral.
//
// Instances:
//
//	CCM_ANALOG  CCM_ANALOG_BASE  -  -
//
// Registers:
//
//	0x000 32  PLL_ARM                  Analog ARM PLL control Register
//	0x004 32  PLL_ARM_SET(PLL_ARM)     Analog ARM PLL control Register
//	0x008 32  PLL_ARM_CLR(PLL_ARM)     Analog ARM PLL control Register
//	0x00C 32  PLL_ARM_TOG(PLL_ARM)     Analog ARM PLL control Register
//	0x010 32  PLL_USB1(PLL_USB)        Analog USB1 480MHz PLL Control Register
//	0x014 32  PLL_USB1_SET(PLL_USB)    Analog USB1 480MHz PLL Control Register
//	0x018 32  PLL_USB1_CLR(PLL_USB)    Analog USB1 480MHz PLL Control Register
//	0x01C 32  PLL_USB1_TOG(PLL_USB)    Analog USB1 480MHz PLL Control Register
//	0x020 32  PLL_USB2(PLL_USB)        Analog USB2 480MHz PLL Control Register
//	0x024 32  PLL_USB2_SET(PLL_USB)    Analog USB2 480MHz PLL Control Register
//	0x028 32  PLL_USB2_CLR(PLL_USB)    Analog USB2 480MHz PLL Control Register
//	0x02C 32  PLL_USB2_TOG(PLL_USB)    Analog USB2 480MHz PLL Control Register
//	0x030 32  PLL_SYS                  Analog System PLL Control Register
//	0x034 32  PLL_SYS_SET(PLL_SYS)     Analog System PLL Control Register
//	0x038 32  PLL_SYS_CLR(PLL_SYS)     Analog System PLL Control Register
//	0x03C 32  PLL_SYS_TOG(PLL_SYS)     Analog System PLL Control Register
//	0x040 32  PLL_SYS_SS               528MHz System PLL Spread Spectrum Register
//	0x050 32  PLL_SYS_NUM              Numerator of 528MHz System PLL Fractional Loop Divider Register
//	0x060 32  PLL_SYS_DENOM            Denominator of 528MHz System PLL Fractional Loop Divider Register
//	0x070 32  PLL_AUDIO(PLL_AV)        Analog Audio PLL control Register
//	0x074 32  PLL_AUDIO_SET(PLL_AV)    Analog Audio PLL control Register
//	0x078 32  PLL_AUDIO_CLR(PLL_AV)    Analog Audio PLL control Register
//	0x07C 32  PLL_AUDIO_TOG(PLL_AV)    Analog Audio PLL control Register
//	0x080 32  PLL_AUDIO_NUM(PLL_AV)    Numerator of Audio PLL Fractional Loop Divider Register
//	0x090 32  PLL_AUDIO_DENOM(PLL_AV)  Denominator of Audio PLL Fractional Loop Divider Register
//	0x0A0 32  PLL_VIDEO(PLL_AV)        Analog Video PLL control Register
//	0x0A4 32  PLL_VIDEO_SET(PLL_AV)    Analog Video PLL control Register
//	0x0A8 32  PLL_VIDEO_CLR(PLL_AV)    Analog Video PLL control Register
//	0x0AC 32  PLL_VIDEO_TOG(PLL_AV)    Analog Video PLL control Register
//	0x0B0 32  PLL_VIDEO_NUM(PLL_AV)    Numerator of Video PLL Fractional Loop Divider Register
//	0x0C0 32  PLL_VIDEO_DENOM(PLL_AV)  Denominator of Video PLL Fractional Loop Divider Register
//	0x0E0 32  PLL_ENET                 Analog ENET PLL Control Register
//	0x0E4 32  PLL_ENET_SET(PLL_ENET)   Analog ENET PLL Control Register
//	0x0E8 32  PLL_ENET_CLR(PLL_ENET)   Analog ENET PLL Control Register
//	0x0EC 32  PLL_ENET_TOG(PLL_ENET)   Analog ENET PLL Control Register
//	0x0F0 32  PFD_480(PFD)             480MHz Clock (PLL3) Phase Fractional Divider Control Register
//	0x0F4 32  PFD_480_SET(PFD)         480MHz Clock (PLL3) Phase Fractional Divider Control Register
//	0x0F8 32  PFD_480_CLR(PFD)         480MHz Clock (PLL3) Phase Fractional Divider Control Register
//	0x0FC 32  PFD_480_TOG(PFD)         480MHz Clock (PLL3) Phase Fractional Divider Control Register
//	0x100 32  PFD_528(PFD)             528MHz Clock (PLL2) Phase Fractional Divider Control Register
//	0x104 32  PFD_528_SET(PFD)         528MHz Clock (PLL2) Phase Fractional Divider Control Register
//	0x108 32  PFD_528_CLR(PFD)         528MHz Clock (PLL2) Phase Fractional Divider Control Register
//	0x10C 32  PFD_528_TOG(PFD)         528MHz Clock (PLL2) Phase Fractional Divider Control Register
//	0x150 32  MISC0                    Miscellaneous Register 0
//	0x154 32  MISC0_SET(MISC0)         Miscellaneous Register 0
//	0x158 32  MISC0_CLR(MISC0)         Miscellaneous Register 0
//	0x15C 32  MISC0_TOG(MISC0)         Miscellaneous Register 0
//	0x160 32  MISC1                    Miscellaneous Register 1
//	0x164 32  MISC1_SET(MISC1)         Miscellaneous Register 1
//	0x168 32  MISC1_CLR(MISC1)         Miscellaneous Register 1
//	0x16C 32  MISC1_TOG(MISC1)         Miscellaneous Register 1
//	0x170 32  MISC2                    Miscellaneous Register 2
//	0x174 32  MISC2_SET(MISC2)         Miscellaneous Register 2
//	0x178 32  MISC2_CLR(MISC2)         Miscellaneous Register 2
//	0x17C 32  MISC2_TOG(MISC2)         Miscellaneous Register 2
//
// Import:
//
//	github.com/embeddedgo/imxrt/p/mmap
package ccm_analog

const (
	PLL_ARM_DIV_SELECT     PLL_ARM = 0x7F << 0  //+ This field controls the PLL loop divider
	PLL_ARM_POWERDOWN      PLL_ARM = 0x01 << 12 //+ Powers down the PLL.
	PLL_ARM_ENABLE         PLL_ARM = 0x01 << 13 //+ Enable the clock output.
	PLL_ARM_BYPASS_CLK_SRC PLL_ARM = 0x03 << 14 //+ Determines the bypass source
	PLL_ARM_REF_CLK_24M    PLL_ARM = 0x00 << 14 //  Select the 24MHz oscillator as source.
	PLL_ARM_CLK1           PLL_ARM = 0x01 << 14 //  Select the CLK1_N / CLK1_P as source.
	PLL_ARM_BYPASS         PLL_ARM = 0x01 << 16 //+ Bypass the PLL.
	PLL_ARM_PLL_SEL        PLL_ARM = 0x01 << 19 //+ Reserved
	PLL_ARM_LOCK           PLL_ARM = 0x01 << 31 //+ 1 - PLL is currently locked. 0 - PLL is not currently locked.
)

const (
	PLL_ARM_DIV_SELECTn     = 0
	PLL_ARM_POWERDOWNn      = 12
	PLL_ARM_ENABLEn         = 13
	PLL_ARM_BYPASS_CLK_SRCn = 14
	PLL_ARM_BYPASSn         = 16
	PLL_ARM_PLL_SELn        = 19
	PLL_ARM_LOCKn           = 31
)

const (
	PLL_USB_DIV_SELECT     PLL_USB = 0x01 << 1  //+ This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
	PLL_USB_EN_USB_CLKS    PLL_USB = 0x01 << 6  //+ Powers the 9-phase PLL outputs for USBPHYn
	PLL_USB_POWER          PLL_USB = 0x01 << 12 //+ Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
	PLL_USB_ENABLE         PLL_USB = 0x01 << 13 //+ Enable the PLL clock output.
	PLL_USB_BYPASS_CLK_SRC PLL_USB = 0x03 << 14 //+ Determines the bypass source.
	PLL_USB_REF_CLK_24M    PLL_USB = 0x00 << 14 //  Select the 24MHz oscillator as source.
	PLL_USB_CLK1           PLL_USB = 0x01 << 14 //  Select the CLK1_N / CLK1_P as source.
	PLL_USB_BYPASS         PLL_USB = 0x01 << 16 //+ Bypass the PLL.
	PLL_USB_LOCK           PLL_USB = 0x01 << 31 //+ 1 - PLL is currently locked. 0 - PLL is not currently locked.
)

const (
	PLL_USB_DIV_SELECTn     = 1
	PLL_USB_EN_USB_CLKSn    = 6
	PLL_USB_POWERn          = 12
	PLL_USB_ENABLEn         = 13
	PLL_USB_BYPASS_CLK_SRCn = 14
	PLL_USB_BYPASSn         = 16
	PLL_USB_LOCKn           = 31
)

const (
	PLL_SYS_DIV_SELECT     PLL_SYS = 0x01 << 0  //+ This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
	PLL_SYS_POWERDOWN      PLL_SYS = 0x01 << 12 //+ Powers down the PLL.
	PLL_SYS_ENABLE         PLL_SYS = 0x01 << 13 //+ Enable PLL output
	PLL_SYS_BYPASS_CLK_SRC PLL_SYS = 0x03 << 14 //+ Determines the bypass source.
	PLL_SYS_REF_CLK_24M    PLL_SYS = 0x00 << 14 //  Select the 24MHz oscillator as source.
	PLL_SYS_CLK1           PLL_SYS = 0x01 << 14 //  Select the CLK1_N / CLK1_P as source.
	PLL_SYS_BYPASS         PLL_SYS = 0x01 << 16 //+ Bypass the PLL.
	PLL_SYS_LOCK           PLL_SYS = 0x01 << 31 //+ 1 - PLL is currently locked; 0 - PLL is not currently locked.
)

const (
	PLL_SYS_DIV_SELECTn     = 0
	PLL_SYS_POWERDOWNn      = 12
	PLL_SYS_ENABLEn         = 13
	PLL_SYS_BYPASS_CLK_SRCn = 14
	PLL_SYS_BYPASSn         = 16
	PLL_SYS_LOCKn           = 31
)

const (
	PLL_SYS_SS_STEP   PLL_SYS_SS = 0x7FFF << 0  //+ Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
	PLL_SYS_SS_ENABLE PLL_SYS_SS = 0x01 << 15   //+ Enable bit
	PLL_SYS_SS_STOP   PLL_SYS_SS = 0xFFFF << 16 //+ Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
)

const (
	PLL_SYS_SS_STEPn   = 0
	PLL_SYS_SS_ENABLEn = 15
	PLL_SYS_SS_STOPn   = 16
)

const (
	PLL_SYS_NUM_A PLL_SYS_NUM = 0x3FFFFFFF << 0 //+ 30 bit numerator (A) of fractional loop divider (signed integer).
)

const (
	PLL_SYS_NUM_An = 0
)

const (
	PLL_SYS_DENOM_B PLL_SYS_DENOM = 0x3FFFFFFF << 0 //+ 30 bit Denominator (B) of fractional loop divider (unsigned integer).
)

const (
	PLL_SYS_DENOM_Bn = 0
)

const (
	PLL_AV_DIV_SELECT        PLL_AV = 0x7F << 0  //+ This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
	PLL_AV_POWERDOWN         PLL_AV = 0x01 << 12 //+ Powers down the PLL.
	PLL_AV_ENABLE            PLL_AV = 0x01 << 13 //+ Enable PLL output
	PLL_AV_BYPASS_CLK_SRC    PLL_AV = 0x03 << 14 //+ Determines the bypass source.
	PLL_AV_REF_CLK_24M       PLL_AV = 0x00 << 14 //  Select the 24MHz oscillator as source.
	PLL_AV_CLK1              PLL_AV = 0x01 << 14 //  Select the CLK1_N / CLK1_P as source.
	PLL_AV_BYPASS            PLL_AV = 0x01 << 16 //+ Bypass the PLL.
	PLL_AV_POST_DIV_SELECT   PLL_AV = 0x03 << 19 //+ These bits implement a divider after the PLL, but before the enable and bypass mux.
	PLL_AV_POST_DIV_SELECT_0 PLL_AV = 0x00 << 19 //  Divide by 4.
	PLL_AV_POST_DIV_SELECT_1 PLL_AV = 0x01 << 19 //  Divide by 2.
	PLL_AV_POST_DIV_SELECT_2 PLL_AV = 0x02 << 19 //  Divide by 1.
	PLL_AV_LOCK              PLL_AV = 0x01 << 31 //+ 1 - PLL is currently locked. 0 - PLL is not currently locked.
)

const (
	PLL_AV_DIV_SELECTn      = 0
	PLL_AV_POWERDOWNn       = 12
	PLL_AV_ENABLEn          = 13
	PLL_AV_BYPASS_CLK_SRCn  = 14
	PLL_AV_BYPASSn          = 16
	PLL_AV_POST_DIV_SELECTn = 19
	PLL_AV_LOCKn            = 31
)

const (
	PLL_ENET_DIV_SELECT         PLL_ENET = 0x03 << 0  //+ Controls the frequency of the ethernet reference clock
	PLL_ENET_ENET2_DIV_SELECT   PLL_ENET = 0x03 << 2  //+ Controls the frequency of the ENET2 reference clock.
	PLL_ENET_ENET2_DIV_SELECT_0 PLL_ENET = 0x00 << 2  //  25MHz
	PLL_ENET_ENET2_DIV_SELECT_1 PLL_ENET = 0x01 << 2  //  50MHz
	PLL_ENET_ENET2_DIV_SELECT_2 PLL_ENET = 0x02 << 2  //  100MHz (not 50% duty cycle)
	PLL_ENET_ENET2_DIV_SELECT_3 PLL_ENET = 0x03 << 2  //  125MHz
	PLL_ENET_POWERDOWN          PLL_ENET = 0x01 << 12 //+ Powers down the PLL.
	PLL_ENET_ENABLE             PLL_ENET = 0x01 << 13 //+ Enable the PLL providing the ENET reference clock.
	PLL_ENET_BYPASS_CLK_SRC     PLL_ENET = 0x03 << 14 //+ Determines the bypass source.
	PLL_ENET_REF_CLK_24M        PLL_ENET = 0x00 << 14 //  Select the 24MHz oscillator as source.
	PLL_ENET_CLK1               PLL_ENET = 0x01 << 14 //  Select the CLK1_N / CLK1_P as source.
	PLL_ENET_BYPASS             PLL_ENET = 0x01 << 16 //+ Bypass the PLL.
	PLL_ENET_ENET2_REF_EN       PLL_ENET = 0x01 << 20 //+ Enable the PLL providing the ENET2 reference clock
	PLL_ENET_ENET_25M_REF_EN    PLL_ENET = 0x01 << 21 //+ Enable the PLL providing ENET 25 MHz reference clock
	PLL_ENET_LOCK               PLL_ENET = 0x01 << 31 //+ 1 - PLL is currently locked; 0 - PLL is not currently locked.
)

const (
	PLL_ENET_DIV_SELECTn       = 0
	PLL_ENET_ENET2_DIV_SELECTn = 2
	PLL_ENET_POWERDOWNn        = 12
	PLL_ENET_ENABLEn           = 13
	PLL_ENET_BYPASS_CLK_SRCn   = 14
	PLL_ENET_BYPASSn           = 16
	PLL_ENET_ENET2_REF_ENn     = 20
	PLL_ENET_ENET_25M_REF_ENn  = 21
	PLL_ENET_LOCKn             = 31
)

const (
	PFD0_FRAC    PFD = 0x3F << 0  //+ This field controls the fractional divide value
	PFD0_STABLE  PFD = 0x01 << 6  //+ This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
	PFD0_CLKGATE PFD = 0x01 << 7  //+ If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
	PFD1_FRAC    PFD = 0x3F << 8  //+ This field controls the fractional divide value
	PFD1_STABLE  PFD = 0x01 << 14 //+ This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
	PFD1_CLKGATE PFD = 0x01 << 15 //+ IO Clock Gate
	PFD2_FRAC    PFD = 0x3F << 16 //+ This field controls the fractional divide value
	PFD2_STABLE  PFD = 0x01 << 22 //+ This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
	PFD2_CLKGATE PFD = 0x01 << 23 //+ IO Clock Gate
	PFD3_FRAC    PFD = 0x3F << 24 //+ This field controls the fractional divide value
	PFD3_STABLE  PFD = 0x01 << 30 //+ This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
	PFD3_CLKGATE PFD = 0x01 << 31 //+ IO Clock Gate
)

const (
	PFD0_FRACn    = 0
	PFD0_STABLEn  = 6
	PFD0_CLKGATEn = 7
	PFD1_FRACn    = 8
	PFD1_STABLEn  = 14
	PFD1_CLKGATEn = 15
	PFD2_FRACn    = 16
	PFD2_STABLEn  = 22
	PFD2_CLKGATEn = 23
	PFD3_FRACn    = 24
	PFD3_STABLEn  = 30
	PFD3_CLKGATEn = 31
)

const (
	MISC0_REFTOP_PWD         MISC0 = 0x01 << 0  //+ Control bit to power-down the analog bandgap reference circuitry
	MISC0_REFTOP_SELFBIASOFF MISC0 = 0x01 << 3  //+ Control bit to disable the self-bias circuit in the analog bandgap
	MISC0_REFTOP_VBGADJ      MISC0 = 0x07 << 4  //+ Not related to CCM. See Power Management Unit (PMU)
	MISC0_REFTOP_VBGADJ_0    MISC0 = 0x00 << 4  //  Nominal VBG
	MISC0_REFTOP_VBGADJ_1    MISC0 = 0x01 << 4  //  VBG+0.78%
	MISC0_REFTOP_VBGADJ_2    MISC0 = 0x02 << 4  //  VBG+1.56%
	MISC0_REFTOP_VBGADJ_3    MISC0 = 0x03 << 4  //  VBG+2.34%
	MISC0_REFTOP_VBGADJ_4    MISC0 = 0x04 << 4  //  VBG-0.78%
	MISC0_REFTOP_VBGADJ_5    MISC0 = 0x05 << 4  //  VBG-1.56%
	MISC0_REFTOP_VBGADJ_6    MISC0 = 0x06 << 4  //  VBG-2.34%
	MISC0_REFTOP_VBGADJ_7    MISC0 = 0x07 << 4  //  VBG-3.12%
	MISC0_REFTOP_VBGUP       MISC0 = 0x01 << 7  //+ Status bit that signals the analog bandgap voltage is up and stable
	MISC0_STOP_MODE_CONFIG   MISC0 = 0x03 << 10 //+ Configure the analog behavior in stop mode.
	MISC0_STOP_MODE_CONFIG_0 MISC0 = 0x00 << 10 //  All analog except RTC powered down on stop mode assertion.
	MISC0_STOP_MODE_CONFIG_1 MISC0 = 0x01 << 10 //  Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	MISC0_STOP_MODE_CONFIG_2 MISC0 = 0x02 << 10 //  Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	MISC0_STOP_MODE_CONFIG_3 MISC0 = 0x03 << 10 //  Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	MISC0_DISCON_HIGH_SNVS   MISC0 = 0x01 << 12 //+ This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
	MISC0_OSC_I              MISC0 = 0x03 << 13 //+ This field determines the bias current in the 24MHz oscillator
	MISC0_NOMINAL            MISC0 = 0x00 << 13 //  Nominal
	MISC0_MINUS_12_5_PERCENT MISC0 = 0x01 << 13 //  Decrease current by 12.5%
	MISC0_MINUS_25_PERCENT   MISC0 = 0x02 << 13 //  Decrease current by 25.0%
	MISC0_MINUS_37_5_PERCENT MISC0 = 0x03 << 13 //  Decrease current by 37.5%
	MISC0_OSC_XTALOK         MISC0 = 0x01 << 15 //+ Status bit that signals that the output of the 24-MHz crystal oscillator is stable
	MISC0_OSC_XTALOK_EN      MISC0 = 0x01 << 16 //+ This bit enables the detector that signals when the 24MHz crystal oscillator is stable
	MISC0_CLKGATE_CTRL       MISC0 = 0x01 << 25 //+ This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
	MISC0_CLKGATE_DELAY      MISC0 = 0x07 << 26 //+ This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
	MISC0_CLKGATE_DELAY_0    MISC0 = 0x00 << 26 //  0.5ms
	MISC0_CLKGATE_DELAY_1    MISC0 = 0x01 << 26 //  1.0ms
	MISC0_CLKGATE_DELAY_2    MISC0 = 0x02 << 26 //  2.0ms
	MISC0_CLKGATE_DELAY_3    MISC0 = 0x03 << 26 //  3.0ms
	MISC0_CLKGATE_DELAY_4    MISC0 = 0x04 << 26 //  4.0ms
	MISC0_CLKGATE_DELAY_5    MISC0 = 0x05 << 26 //  5.0ms
	MISC0_CLKGATE_DELAY_6    MISC0 = 0x06 << 26 //  6.0ms
	MISC0_CLKGATE_DELAY_7    MISC0 = 0x07 << 26 //  7.0ms
	MISC0_RTC_XTAL_SOURCE    MISC0 = 0x01 << 29 //+ This field indicates which chip source is being used for the rtc clock
	MISC0_XTAL_24M_PWD       MISC0 = 0x01 << 30 //+ This field powers down the 24M crystal oscillator if set true
)

const (
	MISC0_REFTOP_PWDn         = 0
	MISC0_REFTOP_SELFBIASOFFn = 3
	MISC0_REFTOP_VBGADJn      = 4
	MISC0_REFTOP_VBGUPn       = 7
	MISC0_STOP_MODE_CONFIGn   = 10
	MISC0_DISCON_HIGH_SNVSn   = 12
	MISC0_OSC_In              = 13
	MISC0_OSC_XTALOKn         = 15
	MISC0_OSC_XTALOK_ENn      = 16
	MISC0_CLKGATE_CTRLn       = 25
	MISC0_CLKGATE_DELAYn      = 26
	MISC0_RTC_XTAL_SOURCEn    = 29
	MISC0_XTAL_24M_PWDn       = 30
)

const (
	MISC1_LVDS1_CLK_SEL       MISC1 = 0x1F << 0  //+ This field selects the clk to be routed to anaclk1/1b.
	MISC1_ARM_PLL             MISC1 = 0x00 << 0  //  Arm PLL
	MISC1_SYS_PLL             MISC1 = 0x01 << 0  //  System PLL
	MISC1_PFD4                MISC1 = 0x02 << 0  //  ref_pfd4_clk == pll2_pfd0_clk
	MISC1_PFD5                MISC1 = 0x03 << 0  //  ref_pfd5_clk == pll2_pfd1_clk
	MISC1_PFD6                MISC1 = 0x04 << 0  //  ref_pfd6_clk == pll2_pfd2_clk
	MISC1_PFD7                MISC1 = 0x05 << 0  //  ref_pfd7_clk == pll2_pfd3_clk
	MISC1_AUDIO_PLL           MISC1 = 0x06 << 0  //  Audio PLL
	MISC1_VIDEO_PLL           MISC1 = 0x07 << 0  //  Video PLL
	MISC1_ETHERNET_REF        MISC1 = 0x09 << 0  //  ethernet ref clock (ENET_PLL)
	MISC1_USB1_PLL            MISC1 = 0x0C << 0  //  USB1 PLL clock
	MISC1_USB2_PLL            MISC1 = 0x0D << 0  //  USB2 PLL clock
	MISC1_PFD0                MISC1 = 0x0E << 0  //  ref_pfd0_clk == pll3_pfd0_clk
	MISC1_PFD1                MISC1 = 0x0F << 0  //  ref_pfd1_clk == pll3_pfd1_clk
	MISC1_PFD2                MISC1 = 0x10 << 0  //  ref_pfd2_clk == pll3_pfd2_clk
	MISC1_PFD3                MISC1 = 0x11 << 0  //  ref_pfd3_clk == pll3_pfd3_clk
	MISC1_XTAL                MISC1 = 0x12 << 0  //  xtal (24M)
	MISC1_LVDSCLK1_OBEN       MISC1 = 0x01 << 10 //+ This enables the LVDS output buffer for anaclk1/1b
	MISC1_LVDSCLK1_IBEN       MISC1 = 0x01 << 12 //+ This enables the LVDS input buffer for anaclk1/1b
	MISC1_PFD_480_AUTOGATE_EN MISC1 = 0x01 << 16 //+ This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
	MISC1_PFD_528_AUTOGATE_EN MISC1 = 0x01 << 17 //+ This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
	MISC1_IRQ_TEMPPANIC       MISC1 = 0x01 << 27 //+ This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
	MISC1_IRQ_TEMPLOW         MISC1 = 0x01 << 28 //+ This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
	MISC1_IRQ_TEMPHIGH        MISC1 = 0x01 << 29 //+ This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
	MISC1_IRQ_ANA_BO          MISC1 = 0x01 << 30 //+ This status bit is set to one when when any of the analog regulator brownout interrupts assert
	MISC1_IRQ_DIG_BO          MISC1 = 0x01 << 31 //+ This status bit is set to one when when any of the digital regulator brownout interrupts assert
)

const (
	MISC1_LVDS1_CLK_SELn       = 0
	MISC1_LVDSCLK1_OBENn       = 10
	MISC1_LVDSCLK1_IBENn       = 12
	MISC1_PFD_480_AUTOGATE_ENn = 16
	MISC1_PFD_528_AUTOGATE_ENn = 17
	MISC1_IRQ_TEMPPANICn       = 27
	MISC1_IRQ_TEMPLOWn         = 28
	MISC1_IRQ_TEMPHIGHn        = 29
	MISC1_IRQ_ANA_BOn          = 30
	MISC1_IRQ_DIG_BOn          = 31
)

const (
	MISC2_REG0_BO_OFFSET       MISC2 = 0x07 << 0  //+ This field defines the brown out voltage offset for the CORE power domain
	MISC2_REG0_BO_OFFSET_4     MISC2 = 0x04 << 0  //  Brownout offset = 0.100V
	MISC2_REG0_BO_OFFSET_7     MISC2 = 0x07 << 0  //  Brownout offset = 0.175V
	MISC2_REG0_BO_STATUS       MISC2 = 0x01 << 3  //+ Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG0_ENABLE_BO       MISC2 = 0x01 << 5  //+ Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG0_OK              MISC2 = 0x01 << 6  //+ ARM supply Not related to CCM. See Power Management Unit (PMU)
	MISC2_PLL3_DISABLE         MISC2 = 0x01 << 7  //+ When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
	MISC2_REG1_BO_OFFSET       MISC2 = 0x07 << 8  //+ This field defines the brown out voltage offset for the xPU power domain
	MISC2_REG1_BO_OFFSET_4     MISC2 = 0x04 << 8  //  Brownout offset = 0.100V
	MISC2_REG1_BO_OFFSET_7     MISC2 = 0x07 << 8  //  Brownout offset = 0.175V
	MISC2_REG1_BO_STATUS       MISC2 = 0x01 << 11 //+ Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG1_ENABLE_BO       MISC2 = 0x01 << 13 //+ Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG1_OK              MISC2 = 0x01 << 14 //+ GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
	MISC2_AUDIO_DIV_LSB        MISC2 = 0x01 << 15 //+ LSB of Post-divider for Audio PLL
	MISC2_REG2_BO_OFFSET       MISC2 = 0x07 << 16 //+ This field defines the brown out voltage offset for the xPU power domain
	MISC2_REG2_BO_OFFSET_4     MISC2 = 0x04 << 16 //  Brownout offset = 0.100V
	MISC2_REG2_BO_OFFSET_7     MISC2 = 0x07 << 16 //  Brownout offset = 0.175V
	MISC2_REG2_BO_STATUS       MISC2 = 0x01 << 19 //+ Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG2_ENABLE_BO       MISC2 = 0x01 << 21 //+ Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG2_OK              MISC2 = 0x01 << 22 //+ Signals that the voltage is above the brownout level for the SOC supply
	MISC2_AUDIO_DIV_MSB        MISC2 = 0x01 << 23 //+ MSB of Post-divider for Audio PLL
	MISC2_REG0_STEP_TIME       MISC2 = 0x03 << 24 //+ Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG0_STEP_64_CLOCKS  MISC2 = 0x00 << 24 //  64
	MISC2_REG0_STEP_128_CLOCKS MISC2 = 0x01 << 24 //  128
	MISC2_REG0_STEP_256_CLOCKS MISC2 = 0x02 << 24 //  256
	MISC2_REG0_STEP_512_CLOCKS MISC2 = 0x03 << 24 //  512
	MISC2_REG1_STEP_TIME       MISC2 = 0x03 << 26 //+ Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG1_STEP_64_CLOCKS  MISC2 = 0x00 << 26 //  64
	MISC2_REG1_STEP_128_CLOCKS MISC2 = 0x01 << 26 //  128
	MISC2_REG1_STEP_256_CLOCKS MISC2 = 0x02 << 26 //  256
	MISC2_REG1_STEP_512_CLOCKS MISC2 = 0x03 << 26 //  512
	MISC2_REG2_STEP_TIME       MISC2 = 0x03 << 28 //+ Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
	MISC2_REG2_STEP_64_CLOCKS  MISC2 = 0x00 << 28 //  64
	MISC2_REG2_STEP_128_CLOCKS MISC2 = 0x01 << 28 //  128
	MISC2_REG2_STEP_256_CLOCKS MISC2 = 0x02 << 28 //  256
	MISC2_REG2_STEP_512_CLOCKS MISC2 = 0x03 << 28 //  512
	MISC2_VIDEO_DIV            MISC2 = 0x03 << 30 //+ Post-divider for video
	MISC2_VIDEO_DIV_0          MISC2 = 0x00 << 30 //  divide by 1 (Default)
	MISC2_VIDEO_DIV_1          MISC2 = 0x01 << 30 //  divide by 2
	MISC2_VIDEO_DIV_2          MISC2 = 0x02 << 30 //  divide by 1
	MISC2_VIDEO_DIV_3          MISC2 = 0x03 << 30 //  divide by 4
)

const (
	MISC2_REG0_BO_OFFSETn = 0
	MISC2_REG0_BO_STATUSn = 3
	MISC2_REG0_ENABLE_BOn = 5
	MISC2_REG0_OKn        = 6
	MISC2_PLL3_DISABLEn   = 7
	MISC2_REG1_BO_OFFSETn = 8
	MISC2_REG1_BO_STATUSn = 11
	MISC2_REG1_ENABLE_BOn = 13
	MISC2_REG1_OKn        = 14
	MISC2_AUDIO_DIV_LSBn  = 15
	MISC2_REG2_BO_OFFSETn = 16
	MISC2_REG2_BO_STATUSn = 19
	MISC2_REG2_ENABLE_BOn = 21
	MISC2_REG2_OKn        = 22
	MISC2_AUDIO_DIV_MSBn  = 23
	MISC2_REG0_STEP_TIMEn = 24
	MISC2_REG1_STEP_TIMEn = 26
	MISC2_REG2_STEP_TIMEn = 28
	MISC2_VIDEO_DIVn      = 30
)
